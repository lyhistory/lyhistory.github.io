<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>计算机基础教程</title>
    <meta name="generator" content="VuePress 1.9.7">
    <script async="true" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9742852210287449" crossorigin="anonymous"></script>
    <script>
			(function() { // DON'T EDIT BELOW THIS LINE
			
			})();
		 </script>
    <meta name="description" content="软件开发教程，白帽黑客入门教程，区块链入门教程，物联网，大数据">
    
    <link rel="preload" href="/docs/assets/css/0.styles.d4eb5ad8.css" as="style"><link rel="preload" href="/docs/assets/js/app.2a7e14f6.js" as="script"><link rel="preload" href="/docs/assets/js/2.37e66b58.js" as="script"><link rel="preload" href="/docs/assets/js/42.dee66438.js" as="script"><link rel="preload" href="/docs/assets/js/11.f6e7f18e.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.d81249de.js"><link rel="prefetch" href="/docs/assets/js/100.975bfa82.js"><link rel="prefetch" href="/docs/assets/js/101.98486d66.js"><link rel="prefetch" href="/docs/assets/js/102.2c313f4a.js"><link rel="prefetch" href="/docs/assets/js/103.98a9e322.js"><link rel="prefetch" href="/docs/assets/js/104.31e20236.js"><link rel="prefetch" href="/docs/assets/js/105.cf6b6061.js"><link rel="prefetch" href="/docs/assets/js/106.de2e630d.js"><link rel="prefetch" href="/docs/assets/js/107.ac68eb9f.js"><link rel="prefetch" href="/docs/assets/js/108.7ec05f84.js"><link rel="prefetch" href="/docs/assets/js/109.19ebcd39.js"><link rel="prefetch" href="/docs/assets/js/110.e74e7bf3.js"><link rel="prefetch" href="/docs/assets/js/111.54f67dda.js"><link rel="prefetch" href="/docs/assets/js/112.80a23661.js"><link rel="prefetch" href="/docs/assets/js/113.459f42b6.js"><link rel="prefetch" href="/docs/assets/js/114.7f539d4b.js"><link rel="prefetch" href="/docs/assets/js/115.ff57869d.js"><link rel="prefetch" href="/docs/assets/js/116.f1c35763.js"><link rel="prefetch" href="/docs/assets/js/117.e2e92612.js"><link rel="prefetch" href="/docs/assets/js/118.c032bf47.js"><link rel="prefetch" href="/docs/assets/js/119.de708818.js"><link rel="prefetch" href="/docs/assets/js/12.26dc9b65.js"><link rel="prefetch" href="/docs/assets/js/120.84257c4e.js"><link rel="prefetch" href="/docs/assets/js/121.60e4ab24.js"><link rel="prefetch" href="/docs/assets/js/122.0a837130.js"><link rel="prefetch" href="/docs/assets/js/123.166ea9ad.js"><link rel="prefetch" href="/docs/assets/js/124.4a0fa31e.js"><link rel="prefetch" href="/docs/assets/js/125.33da73e4.js"><link rel="prefetch" href="/docs/assets/js/126.779e0ad8.js"><link rel="prefetch" href="/docs/assets/js/127.1019fbca.js"><link rel="prefetch" href="/docs/assets/js/128.66e3ef3e.js"><link rel="prefetch" href="/docs/assets/js/129.11202513.js"><link rel="prefetch" href="/docs/assets/js/13.23a019b3.js"><link rel="prefetch" href="/docs/assets/js/130.b8a829fb.js"><link rel="prefetch" href="/docs/assets/js/131.474016b9.js"><link rel="prefetch" href="/docs/assets/js/132.423c3904.js"><link rel="prefetch" href="/docs/assets/js/133.4323a5b6.js"><link rel="prefetch" href="/docs/assets/js/134.6a839418.js"><link rel="prefetch" href="/docs/assets/js/135.f6108e86.js"><link rel="prefetch" href="/docs/assets/js/136.03faa6bd.js"><link rel="prefetch" href="/docs/assets/js/137.676b9d2a.js"><link rel="prefetch" href="/docs/assets/js/138.cf6d5ee0.js"><link rel="prefetch" href="/docs/assets/js/139.643256a0.js"><link rel="prefetch" href="/docs/assets/js/14.4e21288c.js"><link rel="prefetch" href="/docs/assets/js/140.a3590f97.js"><link rel="prefetch" href="/docs/assets/js/141.4e840d6a.js"><link rel="prefetch" href="/docs/assets/js/142.0ef3d264.js"><link rel="prefetch" href="/docs/assets/js/143.50c335b8.js"><link rel="prefetch" href="/docs/assets/js/144.69ccb644.js"><link rel="prefetch" href="/docs/assets/js/145.acaf5863.js"><link rel="prefetch" href="/docs/assets/js/146.ff33cc26.js"><link rel="prefetch" href="/docs/assets/js/147.a259689f.js"><link rel="prefetch" href="/docs/assets/js/148.259a17a3.js"><link rel="prefetch" href="/docs/assets/js/149.6a746376.js"><link rel="prefetch" href="/docs/assets/js/15.3f619bf5.js"><link rel="prefetch" href="/docs/assets/js/150.8bbeed94.js"><link rel="prefetch" href="/docs/assets/js/151.f36fbf37.js"><link rel="prefetch" href="/docs/assets/js/152.09c74cb5.js"><link rel="prefetch" href="/docs/assets/js/153.eee651e7.js"><link rel="prefetch" href="/docs/assets/js/154.3cf37891.js"><link rel="prefetch" href="/docs/assets/js/155.fd53f7a8.js"><link rel="prefetch" href="/docs/assets/js/156.73a4d3ab.js"><link rel="prefetch" href="/docs/assets/js/157.e1191ece.js"><link rel="prefetch" href="/docs/assets/js/158.423fa25d.js"><link rel="prefetch" href="/docs/assets/js/159.d5c35ec2.js"><link rel="prefetch" href="/docs/assets/js/16.d4b42272.js"><link rel="prefetch" href="/docs/assets/js/160.4f8675fb.js"><link rel="prefetch" href="/docs/assets/js/161.d050f4ce.js"><link rel="prefetch" href="/docs/assets/js/162.3459f4f8.js"><link rel="prefetch" href="/docs/assets/js/163.aa8fce19.js"><link rel="prefetch" href="/docs/assets/js/164.e9fb04b7.js"><link rel="prefetch" href="/docs/assets/js/165.18d78d24.js"><link rel="prefetch" href="/docs/assets/js/166.2c134d61.js"><link rel="prefetch" href="/docs/assets/js/167.67a7c0dd.js"><link rel="prefetch" href="/docs/assets/js/168.3ac4e065.js"><link rel="prefetch" href="/docs/assets/js/169.9c0bd70c.js"><link rel="prefetch" href="/docs/assets/js/17.fee6f3a3.js"><link rel="prefetch" href="/docs/assets/js/170.faffbbc9.js"><link rel="prefetch" href="/docs/assets/js/171.a46f9c0f.js"><link rel="prefetch" href="/docs/assets/js/172.7463fe0c.js"><link rel="prefetch" href="/docs/assets/js/173.498879ae.js"><link rel="prefetch" href="/docs/assets/js/174.90fd550c.js"><link rel="prefetch" href="/docs/assets/js/175.a9c28536.js"><link rel="prefetch" href="/docs/assets/js/176.a847793e.js"><link rel="prefetch" href="/docs/assets/js/177.c9eecbee.js"><link rel="prefetch" href="/docs/assets/js/178.12af6908.js"><link rel="prefetch" href="/docs/assets/js/179.48aba899.js"><link rel="prefetch" href="/docs/assets/js/18.76346048.js"><link rel="prefetch" href="/docs/assets/js/180.0fb10942.js"><link rel="prefetch" href="/docs/assets/js/181.f5858a47.js"><link rel="prefetch" href="/docs/assets/js/182.fb98208a.js"><link rel="prefetch" href="/docs/assets/js/183.41ef2775.js"><link rel="prefetch" href="/docs/assets/js/184.03e5e03a.js"><link rel="prefetch" href="/docs/assets/js/185.790cac25.js"><link rel="prefetch" href="/docs/assets/js/186.f938b5a0.js"><link rel="prefetch" href="/docs/assets/js/187.43fda8a3.js"><link rel="prefetch" href="/docs/assets/js/188.8e9c1da2.js"><link rel="prefetch" href="/docs/assets/js/189.df64466c.js"><link rel="prefetch" href="/docs/assets/js/19.45344bed.js"><link rel="prefetch" href="/docs/assets/js/190.5470a757.js"><link rel="prefetch" href="/docs/assets/js/191.fdb63b27.js"><link rel="prefetch" href="/docs/assets/js/192.4aff5331.js"><link rel="prefetch" href="/docs/assets/js/193.747f1c08.js"><link rel="prefetch" href="/docs/assets/js/194.32243a83.js"><link rel="prefetch" href="/docs/assets/js/195.e3778c26.js"><link rel="prefetch" href="/docs/assets/js/196.73738522.js"><link rel="prefetch" href="/docs/assets/js/197.86431788.js"><link rel="prefetch" href="/docs/assets/js/198.3d4c032e.js"><link rel="prefetch" href="/docs/assets/js/199.f43852a3.js"><link rel="prefetch" href="/docs/assets/js/20.3b03f76e.js"><link rel="prefetch" href="/docs/assets/js/200.bf4ac3b1.js"><link rel="prefetch" href="/docs/assets/js/201.e1737767.js"><link rel="prefetch" href="/docs/assets/js/202.57217d02.js"><link rel="prefetch" href="/docs/assets/js/203.bc2e1ac4.js"><link rel="prefetch" href="/docs/assets/js/204.28f630f9.js"><link rel="prefetch" href="/docs/assets/js/205.9f596b95.js"><link rel="prefetch" href="/docs/assets/js/206.fdefdc14.js"><link rel="prefetch" href="/docs/assets/js/207.aa6a0ed6.js"><link rel="prefetch" href="/docs/assets/js/208.bb3e4226.js"><link rel="prefetch" href="/docs/assets/js/209.f16a6253.js"><link rel="prefetch" href="/docs/assets/js/21.f6d80f99.js"><link rel="prefetch" href="/docs/assets/js/22.0cdc13ce.js"><link rel="prefetch" href="/docs/assets/js/23.ef74f4d3.js"><link rel="prefetch" href="/docs/assets/js/24.e36ed569.js"><link rel="prefetch" href="/docs/assets/js/25.4c47c325.js"><link rel="prefetch" href="/docs/assets/js/26.cb59b1f5.js"><link rel="prefetch" href="/docs/assets/js/27.8647b3b5.js"><link rel="prefetch" href="/docs/assets/js/28.ed56511b.js"><link rel="prefetch" href="/docs/assets/js/29.2742d47f.js"><link rel="prefetch" href="/docs/assets/js/3.a2555baa.js"><link rel="prefetch" href="/docs/assets/js/30.a3239934.js"><link rel="prefetch" href="/docs/assets/js/31.42588eb9.js"><link rel="prefetch" href="/docs/assets/js/32.719a76b1.js"><link rel="prefetch" href="/docs/assets/js/33.2abb2d01.js"><link rel="prefetch" href="/docs/assets/js/34.a86bbffb.js"><link rel="prefetch" href="/docs/assets/js/35.af768465.js"><link rel="prefetch" href="/docs/assets/js/36.8744b541.js"><link rel="prefetch" href="/docs/assets/js/37.8fef0518.js"><link rel="prefetch" href="/docs/assets/js/38.42b85d7c.js"><link rel="prefetch" href="/docs/assets/js/39.c278fbba.js"><link rel="prefetch" href="/docs/assets/js/4.ad7f2bad.js"><link rel="prefetch" href="/docs/assets/js/40.59298f87.js"><link rel="prefetch" href="/docs/assets/js/41.b0d1e127.js"><link rel="prefetch" href="/docs/assets/js/43.a2715259.js"><link rel="prefetch" href="/docs/assets/js/44.d93216e4.js"><link rel="prefetch" href="/docs/assets/js/45.fe02feed.js"><link rel="prefetch" href="/docs/assets/js/46.ac4440e9.js"><link rel="prefetch" href="/docs/assets/js/47.069e91ae.js"><link rel="prefetch" href="/docs/assets/js/48.6ea31014.js"><link rel="prefetch" href="/docs/assets/js/49.270673fc.js"><link rel="prefetch" href="/docs/assets/js/5.cdaab8f6.js"><link rel="prefetch" href="/docs/assets/js/50.4a171900.js"><link rel="prefetch" href="/docs/assets/js/51.8576d727.js"><link rel="prefetch" href="/docs/assets/js/52.2702a784.js"><link rel="prefetch" href="/docs/assets/js/53.182313c0.js"><link rel="prefetch" href="/docs/assets/js/54.a3b267c6.js"><link rel="prefetch" href="/docs/assets/js/55.7fdeaece.js"><link rel="prefetch" href="/docs/assets/js/56.0c57bec3.js"><link rel="prefetch" href="/docs/assets/js/57.9dcbf925.js"><link rel="prefetch" href="/docs/assets/js/58.0c1b31a2.js"><link rel="prefetch" href="/docs/assets/js/59.db8f1193.js"><link rel="prefetch" href="/docs/assets/js/6.b13411ed.js"><link rel="prefetch" href="/docs/assets/js/60.c6faaf3e.js"><link rel="prefetch" href="/docs/assets/js/61.8bcd8ab6.js"><link rel="prefetch" href="/docs/assets/js/62.1e8d46dc.js"><link rel="prefetch" href="/docs/assets/js/63.b64d9349.js"><link rel="prefetch" href="/docs/assets/js/64.8febc86e.js"><link rel="prefetch" href="/docs/assets/js/65.6391ebeb.js"><link rel="prefetch" href="/docs/assets/js/66.8f3fb5c0.js"><link rel="prefetch" href="/docs/assets/js/67.3534c7dd.js"><link rel="prefetch" href="/docs/assets/js/68.9190d92c.js"><link rel="prefetch" href="/docs/assets/js/69.4684df1e.js"><link rel="prefetch" href="/docs/assets/js/7.dd805d38.js"><link rel="prefetch" href="/docs/assets/js/70.d907b81b.js"><link rel="prefetch" href="/docs/assets/js/71.b3e7b393.js"><link rel="prefetch" href="/docs/assets/js/72.f67d5ef8.js"><link rel="prefetch" href="/docs/assets/js/73.cca4e66d.js"><link rel="prefetch" href="/docs/assets/js/74.dc827d76.js"><link rel="prefetch" href="/docs/assets/js/75.773dd759.js"><link rel="prefetch" href="/docs/assets/js/76.534ed2d2.js"><link rel="prefetch" href="/docs/assets/js/77.6d093c2a.js"><link rel="prefetch" href="/docs/assets/js/78.7d63f0b0.js"><link rel="prefetch" href="/docs/assets/js/79.b6e62f10.js"><link rel="prefetch" href="/docs/assets/js/8.fdea0b20.js"><link rel="prefetch" href="/docs/assets/js/80.a7f980ca.js"><link rel="prefetch" href="/docs/assets/js/81.fe17a01e.js"><link rel="prefetch" href="/docs/assets/js/82.3db398ca.js"><link rel="prefetch" href="/docs/assets/js/83.e6162d07.js"><link rel="prefetch" href="/docs/assets/js/84.e6367218.js"><link rel="prefetch" href="/docs/assets/js/85.fd468a49.js"><link rel="prefetch" href="/docs/assets/js/86.6f3d0fc9.js"><link rel="prefetch" href="/docs/assets/js/87.eb1b1d5b.js"><link rel="prefetch" href="/docs/assets/js/88.bcb1d0b7.js"><link rel="prefetch" href="/docs/assets/js/89.68502325.js"><link rel="prefetch" href="/docs/assets/js/9.c3849850.js"><link rel="prefetch" href="/docs/assets/js/90.8ca56c14.js"><link rel="prefetch" href="/docs/assets/js/91.c01ee367.js"><link rel="prefetch" href="/docs/assets/js/92.93fc77a0.js"><link rel="prefetch" href="/docs/assets/js/93.31ee1d5a.js"><link rel="prefetch" href="/docs/assets/js/94.51c52371.js"><link rel="prefetch" href="/docs/assets/js/95.7b48da2b.js"><link rel="prefetch" href="/docs/assets/js/96.3a3a1ebe.js"><link rel="prefetch" href="/docs/assets/js/97.b5e873a3.js"><link rel="prefetch" href="/docs/assets/js/98.86e288cf.js"><link rel="prefetch" href="/docs/assets/js/99.4d640b1b.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.d4eb5ad8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><!----> <span class="site-name">计算机基础教程</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/docs/" class="nav-link">
  机器指令
</a></div><div class="nav-item"><a href="/docs/software/" class="nav-link">
  软件基础
</a></div><div class="nav-item"><a href="/docs/coder2hacker/" class="nav-link">
  白帽黑客
</a></div><div class="nav-item"><a href="/docs/blockchain/" class="nav-link router-link-active">
  区块链
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/docs/" class="nav-link">
  机器指令
</a></div><div class="nav-item"><a href="/docs/software/" class="nav-link">
  软件基础
</a></div><div class="nav-item"><a href="/docs/coder2hacker/" class="nav-link">
  白帽黑客
</a></div><div class="nav-item"><a href="/docs/blockchain/" class="nav-link router-link-active">
  区块链
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/docs/software/" class="sidebar-link">软件基础</a></li><li><a href="/docs/coder2hacker/" class="sidebar-link">黑客入门</a></li><li><a href="/docs/blockchain/" aria-current="page" class="sidebar-link">区块链入门</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>refer 8.2</p> <h2 id="groups"><a href="#groups" class="header-anchor">#</a> Groups</h2> <h3 id="definition-8-2-1-group"><a href="#definition-8-2-1-group" class="header-anchor">#</a> Definition 8.2.1 Group</h3> <p>A group is a set of elements G together with an operation ◦ which combines two elements of G. A group has the following properties.</p> <p><strong>Note:</strong></p> <p>in cryptography we use both <strong>multiplicative groups</strong>, i.e., the operation “◦” denotes multiplication, and <strong>additive groups</strong> where “◦” denotes addition. The latter notation is used for elliptic curves as we’ll see later. Roughly speaking, a group is set with one operation and the corresponding inverse operation. If the operation is called addition, the inverse operation is subtraction; if the operation is multiplication, the inverse operation is division (or multiplication with the inverse element).</p> <h4 id="closure"><a href="#closure" class="header-anchor">#</a> Closure</h4> <p>The group operation ◦ is closed. That is, for all a,b,∈ G, it holds that a ◦ b = c ∈ G.</p> <h4 id="associative"><a href="#associative" class="header-anchor">#</a> Associative</h4> <p>The group operation is <strong>associative 结合律</strong> . That is, a◦(b◦c) = (a◦b)◦c for all a,b,c ∈ G.</p> <p><strong>Note: associative is non trivial</strong></p> <p>例1：</p> <table><thead><tr><th>◦</th> <th>x1</th> <th>x2</th> <th>x3</th></tr></thead> <tbody><tr><td>x1</td> <td></td> <td>x1◦x2</td> <td></td></tr> <tr><td>x2</td> <td></td> <td></td> <td>x2◦x3</td></tr> <tr><td>x3</td> <td></td> <td></td> <td></td></tr></tbody></table> <p>假设G只有三个元素 x1 x2 x3</p> <p>(x1◦x2)◦x3 	根据闭合属性，x1◦x2 的值肯定是属于G也就是x1/x2/x3其中一个，所以 (x1◦x2)◦x3的值就落在最后一列</p> <p>x1◦(x2◦x3) 	同理，(x2◦x3) 的值也是属于G也就是x1/x2/x3其中一个，所以其值落在第一行</p> <p>可见想让第一行的某个值和最后一列的某个值相等并不是显而易见的事情，所以说non trivial</p> <p>例2：</p> <p>集合set {a, b}，定义set permutation如下：</p> <p>i(identity):</p> <p>a-&gt;a</p> <p>b-&gt;b</p> <p>t(transform):</p> <p>a-&gt;b</p> <p>b-&gt;a</p> <p>然后在此基础定义Group G={i, t}，即将两个set permutation操作符号本身抽象为G的元素，</p> <p>然后定义composition 操作，如</p> <p>i◦t是指在t的基础上进行i操作：</p> <p>a-&gt;b -&gt;b</p> <p>b-&gt;a -&gt;a</p> <p>=&gt;</p> <p>a-&gt;b</p> <p>b-&gt;a</p> <p>即i◦t=t</p> <p>很容易得到</p> <table><thead><tr><th>◦</th> <th>i</th> <th>t</th></tr></thead> <tbody><tr><td>i</td> <td>i</td> <td>t</td></tr> <tr><td>t</td> <td>t</td> <td>i</td></tr></tbody></table> <p>很容易理解：</p> <p>i◦t◦t = (i◦t)◦t = i◦(t◦t)</p> <p>所以由此也可以看出Group定义中的Associativity也是一种元素排列的复杂数据结构</p> <h4 id="neutrual-identity-element"><a href="#neutrual-identity-element" class="header-anchor">#</a> Neutrual/Identity element</h4> <p>There is an element 1 ∈ G, called the <strong>neutral element (or identity element)</strong>, such that a ◦ 1 = 1 ◦ a = a for all a ∈ G.</p> <h4 id="inverse"><a href="#inverse" class="header-anchor">#</a> Inverse</h4> <p>For each a ∈ G there exists an element a<sup>−1</sup> ∈ G, called the inverse of a, such that a ◦ a<sup>−1</sup> = a<sup>−1</sup> ◦ a = 1.</p> <h4 id="commutative-abelian-group"><a href="#commutative-abelian-group" class="header-anchor">#</a> Commutative(Abelian Group)</h4> <p>A group G is <strong>abelian (or commutative) 交换律</strong> if, furthermore, a ◦ b = b ◦ a for all a,b ∈ G.</p> <p>take above example, commutative means that in the table it's symmetric down the diagonal line</p> <h3 id="example-to-illustrate-the-definition-of-groups"><a href="#example-to-illustrate-the-definition-of-groups" class="header-anchor">#</a> Example: To illustrate the definition of groups</h3> <ul><li><p>(Z,+) is a group, i.e., the set of integers Z = {. . . ,−2,−1,0,1,2, . . .} together with the usual addition forms an abelian group, where e = 0 is the identity element and −a is the inverse of an element a ∈ Z.</p> <ul><li><p>加法模</p> <p>The set of integers Z<sub>m</sub> = {-m+1, . . . , -1,0,1, . . . ,m−1} and the operation addition modulo m form a group with the neutral element 0. Every element a has an inverse −a such that a+(−a) =0 mod m.</p></li> <li><p>乘法模</p> <p>Note that this set Z<sub>m</sub> does not form a group with the operation multiplication because most elements a do not have an inverse such that aa<sup>−1</sup> =1 mod m.</p></li></ul></li> <li><p>(Z without 0, ·) is not a group, i.e., the set of integers Z (without the element 0) and the usual multiplication does not form a group since there exists no inverse a<sup>−1</sup>for an element a ∈ Z with the exception of the elements −1 and 1. -1+1=0而0不存在，破坏了group 闭合的定义</p></li> <li><p>(C, ·) is a group, i.e., the set of complex numbers u+iv with u,v ∈ R and i<sup>2</sup> =−1 together with the complex multiplication defined by (u1+iv1) · (u2+iv2) = (u1u2−v1v2)+i(u1v2+v1u2) forms an abelian group. The identity element of this group is e = 1, and the
inverse a−1 of an element a = u+iv ∈ C is given by a<sup>−1</sup> = (u−iv)/(u<sup>2</sup>+v<sup>2</sup>).</p></li> <li><p>(Z<sub>n</sub><sup>*</sup>, ·): is defined as the set of positive integers smaller than n which are relatively prime to n. Thus,</p> <p>the cardinality of  Z<sub>n</sub><sup>*</sup>equals Euler’s phi function evaluated for n, i.e.,</p> <p>|Z<sub>n</sub><sup>*</sup>| =Φ(n). For instance,</p> <p>the group Z<sub>9</sub><sup>*</sup> has a cardinality ofΦ(9)=3<sup>2</sup>−3<sup>1</sup> =6.  the group consist of the six elements {1,2,4,5,7,8}.</p></li></ul> <p>However, all of these groups do not play a significant role in cryptography <strong>because we need groups with a finite number of elements</strong>. Let us now consider the group Z<sub>n</sub><sup>∗</sup> which is very important for many cryptographic schemes such as：</p> <ul><li><p>DHKE,</p></li> <li><p>Elgamal encryption,</p></li> <li><p>digital signature algorithm</p></li> <li><p>and many others.</p></li></ul> <h3 id="构造group-set-group"><a href="#构造group-set-group" class="header-anchor">#</a> 构造Group(Set=&gt;Group)</h3> <p>假设自然数 natural number</p> <p>n ∈ N = {1, 2, 3, 4, 5, 6, ..........}</p> <p>Set集合 S1 S2 ........ Sn</p> <p>n=1，S1 = {1}</p> <p>n=2，S2 = {1,2}</p> <p>如果通过Set构造Group呢？</p> <h4 id="构造1-set-permutation-symmetric-group"><a href="#构造1-set-permutation-symmetric-group" class="header-anchor">#</a> 构造1：Set Permutation (Symmetric Group)</h4> <p>n=2</p> <p>集合set S2={1, 2}，定义set permutation如下（1对1全映射 bijections，不能多对1）：</p> <p>i(identity):</p> <p>1-&gt;1</p> <p>2-&gt;2</p> <p>t(transform):</p> <p>1-&gt;2</p> <p>2-&gt;1</p> <p>然后在此基础定义Group G={i, t}，即将两个set permutation Symbols操作符号本身抽象为G的元素，</p> <p>然后定义composition 操作，如</p> <p>i◦t是指在t的基础上进行i操作：</p> <p>1-&gt;2 -&gt;2</p> <p>2-&gt;1 -&gt;1</p> <p>=&gt;</p> <p>1-&gt;2</p> <p>2-&gt;1</p> <p>即i◦t=t</p> <p>很容易得到</p> <table><thead><tr><th>◦</th> <th>i</th> <th>t</th></tr></thead> <tbody><tr><td>i</td> <td>i</td> <td>t</td></tr> <tr><td>t</td> <td>t</td> <td>i</td></tr></tbody></table> <h4 id="构造2-模运算-theorem-8-2-1"><a href="#构造2-模运算-theorem-8-2-1" class="header-anchor">#</a> 构造2：模运算 Theorem 8.2.1</h4> <p>The set Z<sub>n</sub><sup>∗</sup> which consists of all integers i=0,1, . . . ,n−1 for which gcd(i,n) = 1 forms an abelian group under multiplication modulo
n. The identity element is e = 1.</p> <p>Example 8.3. If we choose n = 9,  Z<sub>n</sub><sup>∗</sup> consists of the elements {1,2,4,5,7,8}.</p> <p>Multiplication table for Z<sub>9</sub><sup>∗</sup></p> <table><thead><tr><th>× mod 9</th> <th>1 2 4 5 7 8</th></tr></thead> <tbody><tr><td>1</td> <td>1 2 4 5 7 8</td></tr> <tr><td>2</td> <td>2 4 8 1 5 7</td></tr> <tr><td>4</td> <td>4 8 7 2 1 5</td></tr> <tr><td>5</td> <td>5 1 2 7 8 4</td></tr> <tr><td>7</td> <td>7 5 1 8 4 2</td></tr> <tr><td>8</td> <td>8 7 5 4 2 1</td></tr></tbody></table> <p>从上面的表很容易看到定义的 1 3 5都满足，2不能直接从上表看出，但是也是满足的，至于4逆元也可以通过 extended Euclidean algorithm 来计算出</p> <p>这不就是一种set permutation吗，</p> <p>S={1 2 4 5 7 8}</p> <p>permutation1: S*1 mod 9	结果映射   1 2 4 5 7 8</p> <p>permutation2: S*2 mod 9	结果映射	2 4 8 1 5 7</p> <p>。。。。。</p> <p>其实更适合后面 Cayley's theorem, 对于 G={1 2 4 5 7 8} ，aG=G</p> <h4 id="group的序-size-order"><a href="#group的序-size-order" class="header-anchor">#</a> Group的序 Size/Order</h4> <p>从上面两个例子可以看出，模运算的构造其实也是一种Set Permutation！</p> <p>本质都是Set集合一对一的全排列，</p> <p>比如Sn:</p> <p>1,2,3.......n 映射到 1,2,3.......n</p> <p>从1开始，1有n种选择，2有n-1种........</p> <p>总共</p> <p><s>Sn的序 Order = |Sn| = n(n-1)(n-2).....1 = n!</s></p> <p>其实应该是Sn构造的Group的序 =  n(n-1)(n-2).....1 = n!</p> <h2 id="symmetric-groups"><a href="#symmetric-groups" class="header-anchor">#</a> Symmetric Groups</h2> <p>上面例子通过Set Permutation构造的Sn就是Symmetric Group，</p> <p>注意S1和S2比较简单，都满足communitative，所以都是abliean group，</p> <p>但是S3不满足！</p> <p><strong>所以Symmetric Group不一定是abliean group</strong></p> <p>定义：</p> <p>In abstract algebra, the symmetric group defined over any set is the group whose elements are all the bijections from the set to itself, and whose group operations is the composition of functions. In particular, the finite symmetric group Sn defined over a finite set of n symbols consists of the permutations that can be performed on the n symbols.</p> <p>举例：</p> <p>S3</p> <table><thead><tr><th>i</th> <th>t12</th> <th>t13</th> <th>t23</th> <th>σ</th> <th>σ<sup>2</sup></th></tr></thead> <tbody><tr><td>1-&gt;1<br>2-&gt;2<br>3-&gt;3</td> <td>1-&gt;2<br>2-&gt;1<br>3-&gt;3</td> <td>1-&gt;3<br>2-&gt;2<br>3-&gt;1</td> <td>1-&gt;1<br>2-&gt;3<br>3-&gt;2</td> <td>1-&gt;2<br>2-&gt;3<br>3-&gt;1</td> <td>1-&gt;3<br>2-&gt;1<br>3-&gt;2</td></tr></tbody></table> <table><thead><tr><th>◦</th> <th>i</th> <th>t12</th> <th>t13</th> <th>t23</th> <th>σ</th> <th>σ<sup>2</sup></th></tr></thead> <tbody><tr><td>i</td> <td>i</td> <td>t12</td> <td>t12</td> <td>t23</td> <td>σ</td> <td>σ<sup>2</sup></td></tr> <tr><td>t12</td> <td>t12</td> <td></td> <td>σ<sup>2</sup></td> <td></td> <td></td> <td></td></tr> <tr><td>t13</td> <td>t13</td> <td>σ</td> <td></td> <td></td> <td></td> <td></td></tr> <tr><td>t23</td> <td>t23</td> <td></td> <td></td> <td></td> <td></td> <td></td></tr> <tr><td>σ</td> <td>σ</td> <td></td> <td></td> <td></td> <td></td> <td></td></tr> <tr><td>σ<sup>2</sup></td> <td>σ<sup>2</sup></td> <td></td> <td></td> <td></td> <td></td> <td></td></tr></tbody></table> <p>t12 ◦ t13 =   σ<sup>2</sup></p> <p>t13 ◦ t12 =   σ</p> <p>所以S3不是abelian group</p> <h2 id="cyclic-groups"><a href="#cyclic-groups" class="header-anchor">#</a> Cyclic Groups</h2> <p>Definition 8.2.3 Order of an element
The order ord(a) of an element a of a group (G,◦) is the smallest positive integer k such that
a<sup>k</sup> = a	 ◦ a ◦. . . ◦ a (k times)= 1, where 1 is the identity element of G.</p> <p>Definition 8.2.4 Cyclic Group
A group G which contains an element α with maximum order
ord(α) = |G| is said to be cyclic. Elements with maximum order
are called primitive elements or generators.</p> <p>假设自然数 natural number</p> <p>n ∈ N = {1, 2, 3, 4, 5, 6, ..........n}</p> <p>跟Sn类似，这次用 Cn 表示，Cn构造的Group的元素也类似前面的Set Permutation，这次换成了 Cyclic Permutation：</p> <p>想象一个圆盘/钟表，将其按照360度/n等分为n份，从刻度1开始，下一个刻度2，。。。。直到n，</p> <p>比如n=2，就是12点钟刻度位置放1，6点钟刻度位置放2</p> <p>然后，Cyclic Permutation就是rotate旋转圆盘（每次旋转360/n），所以</p> <p>旋转0次：</p> <p>1-&gt;1 2-&gt;2 .............n-&gt;n	用i表示</p> <p>旋转一次就是：</p> <p>1-&gt;2 2-&gt;3 ..........n-&gt;1	用<em>σ</em> 表示</p> <p>旋转两次</p> <p>1-&gt;3 2-&gt;4...........n-1-&gt;1 n-&gt;2	用<em>σ<sup>2</sup></em> 表示</p> <p>......</p> <p>旋转n-1次</p> <p>1-&gt;n 2-&gt;1 ..........n-&gt;n-1	用<em>σ<sup>n-1</sup></em> 表示</p> <p>首先这种构造满足Group的定义：</p> <ol><li>closure, x,y ∈ Cn x◦y ∈ Cn</li></ol> <p>证明：Cn包含了所有的Cyclic Permutation/rotation的可能性，所以任意的xy组合也一定属于Cn</p> <ol start="2"><li><p>Associativity</p></li> <li><p>Identity: i 旋转0次</p></li> <li><p>Inverse ∀ g ∈ Cn, ∃ g<sup>-1</sup>∈ Cn, s.t. g◦g<sup>-1</sup>=g<sup>-1</sup>◦g=i</p></li></ol> <p>证明：假设g是旋转m次，即 m(360/n)，其inverse就是(n-m)(360/n)，因为两者加起来就是旋转360度，相当于旋转0度，即等于i</p> <ol start="5"><li>并且还满足commutative，即Cyclic Group必然是Abelian Group</li></ol> <p>证明：x◦y和y◦x都是代表总共旋转x+y次，所以结果是一样的</p> <p>容易得到，|Cn|的序=n 也就是所有的Cyclic Permutation总共有n种可能，可以联想之所以set Permutation是n阶乘，而这里是n，主要是这里1 2 3。。。。n这些元素是联动的，也就是当1旋转到了2，2必然对应3，而set Permutation中可以自由选择</p> <p>举例：</p> <p>C4</p> <table><thead><tr><th>i</th> <th>σ</th> <th>σ<sup>2</sup></th> <th>σ<sup>3</sup></th></tr></thead> <tbody><tr><td>1-&gt;1<br>2-&gt;2<br>3-&gt;3<br>4-&gt;4</td> <td>1-&gt;2<br>2-&gt;3<br>3-&gt;4<br>4-&gt;1</td> <td>1-&gt;3<br>2-&gt;4<br>3-&gt;1<br>4-&gt;2</td> <td>1-&gt;4<br>2-&gt;1<br>3-&gt;2<br>4-&gt;3</td></tr></tbody></table> <table><thead><tr><th>◦</th> <th>i</th> <th>σ</th> <th>σ<sup>2</sup></th> <th>σ<sup>3</sup></th></tr></thead> <tbody><tr><td>i</td> <td>i</td> <td>σ</td> <td>σ<sup>2</sup></td> <td>σ<sup>3</sup></td></tr> <tr><td>σ</td> <td>σ</td> <td>σ<sup>2</sup></td> <td>σ<sup>3</sup></td> <td>i</td></tr> <tr><td>σ<sup>2</sup></td> <td>σ<sup>2</sup></td> <td>σ<sup>3</sup></td> <td>i</td> <td>σ</td></tr> <tr><td>σ<sup>3</sup></td> <td>σ<sup>3</sup></td> <td>i</td> <td>σ</td> <td>σ<sup>2</sup></td></tr></tbody></table> <p>example 2: a = 3 is not a primitive element  of Z<sub>11</sub><sup>*</sup> = {1,2,3,4,5,6,7,8,9,10}.,</p> <p>a = 3 only generate partial of Z<sub>11</sub><sup>*</sup> {3,9,5,4,1}</p> <p>a<sup>1</sup> = 3
a<sup>2</sup> = a · a = 3 · 3 = 9
a<sup>3</sup> = a<sup>2</sup>  · a = 9 · 3 = 27 ≡ 5 mod 11
a<sup>4</sup> = a<sup>3</sup>  · a = 5 · 3 = 15 ≡ 4 mod 11
a<sup>5</sup> = a<sup>4</sup> · a = 4 · 3 = 12 ≡ 1 mod 11</p> <p>We see that from this point on, the powers of a run through the sequence {3,9,5,4,1}
indefinitely.</p> <p>a<sup>6</sup> = a<sup>5</sup> · a ≡ 1 · a ≡ 3 mod 11
a<sup>7</sup> = a<sup>5</sup> · a<sup>2</sup> ≡ 1 · a<sup>2</sup> ≡ 9 mod 11
a<sup>8</sup> = a<sup>5</sup> · a<sup>3</sup> ≡ 1 · a<sup>3</sup> ≡ 5 mod 11
a<sup>9</sup> = a<sup>5</sup> · a<sup>4</sup> ≡ 1 · a<sup>4</sup>≡ 4 mod 11
a<sup>10</sup> = a<sup>5</sup> · a<sup>5</sup> ≡ 1 · 1 ≡ 1 mod 11
a<sup>11</sup> = a<sup>10</sup> · a ≡ 1 · a ≡ 3 mod 11</p> <p>example 3: a = 2 is a primitive element  of Z<sub>11</sub><sup>*</sup> = {1,2,3,4,5,6,7,8,9,10}.,</p> <p>a = 2 generate the whole Z<sub>11</sub><sup>*</sup></p> <p>a = 2 							a<sup>6</sup> ≡ 9 mod 11
a<sup>2</sup> = 4 							a<sup>7</sup> ≡ 7 mod 11
a<sup>3</sup> = 8 							a<sup>8</sup> ≡ 3 mod 11
a<sup>4</sup> ≡ 5 mod 11 			a<sup>9</sup>≡ 6 mod 11
a<sup>5</sup>  ≡ 10 mod 11 			a<sup>10</sup> ≡ 1 mod 11</p> <p>From the last result it follows that ord(a) = 10 = |Z<sub>11</sub><sup>*</sup>|.</p> <p>This implies that a = 2 is a primitive element and Z<sub>11</sub><sup>*</sup> is cyclic</p> <p>Theorem 8.2.4 Let G be a finite cyclic group. Then it holds that</p> <ol><li>The number of primitive elements of G is Φ(|G|).</li> <li>If |G| is prime, then all elements a &lt;&gt; 1 ∈ G are primitive.</li></ol> <p>很容易理解，G是Cyclic  group，说明存在一个Cyclic set Permutation，由后面的Cayley's theorem可以知道每个元素本身就代表一种Cyclic set Permutation，比如1代表G-&gt;1G即旋转0度，2代表G-&gt;2G即旋转360/|G|度，3代表G-&gt;3G即旋转2*360/|G|度，依次类推，总之每个元素都代表旋转某个角度，但是:</p> <p>对于奇数个元素的G来说，旋转任意角度都能生成整个group，所以每个元素都是primitive element，</p> <p>而对于偶数个元素的G来说，只有旋转特定角度才能生成整个group，其他只能生成sub group</p> <p>Theorem 8.2.5 Cyclic Subgroup Theorem
Let (G,◦) be a cyclic group. Then every element a ∈ G withord(a) = s is the primitive element of a cyclic subgroup with s elements.</p> <p>例子：</p> <p>Z<sub>11</sub><sup>*</sup> ={x mod 11| x=1,2....10} ,</p> <p>Z<sub>11</sub><sup>*</sup> = {1,2,3,4,5,6,7,8,9,10}.</p> <p>| Z<sub>11</sub><sup>*</sup> | = 10 不是prime，Φ(10) = (5−1)(2−1) = 4, 刚好对应下面只有2 6 7 8 可以生成整个group</p> <p>x=1, &lt;x&gt; ={1} ord(1) =1</p> <p>x=2, &lt;x&gt; ={1,2,3,4,5,6,7,8,9,10} ord(2) =10</p> <p>x=3, &lt;x&gt; ={3,9,5,4,1} ord(3) =5</p> <p>x=4, &lt;x&gt; ={4,5,9,3,1} ord(4) =5</p> <p>x=5, &lt;x&gt; ={5,3,4,9,1} ord(5) =5</p> <p>x=6, &lt;x&gt; ={1,2,3,4,5,6,7,8,9,10} ord(6) =10</p> <p>x=7, &lt;x&gt; ={1,2,3,4,5,6,7,8,9,10} ord(7) =10</p> <p>x=8, &lt;x&gt; ={1,2,3,4,5,6,7,8,9,10} ord(8) =10</p> <p>x=9, &lt;x&gt; ={9,4,3,5,1} ord(9) =5</p> <p>x=10, &lt;x&gt; ={10,1} ord(10) =2</p> <h2 id="dihedral-groups"><a href="#dihedral-groups" class="header-anchor">#</a> Dihedral Groups</h2> <p>假设自然数 natural number</p> <p>n ∈ N = {1, 2, 3, 4, 5, 6, ..........n}</p> <p>这次用 Dn 表示</p> <p>这次的Permutation是在rotation/Cyclic Permutation的基础上增加了flipping，按照对称轴翻转，</p> <p>比如 {1,2,3,4}就可以按照1-3 2-4两条对称轴+12和34间的轴线+14和23之间的轴线，总共4条对称轴，</p> <p>对于{1,2,3,4,5} 五条对称轴则都是穿过每个数字</p> <p>所以</p> <p>|Dn|=n(cyclic permutation)+n(flipping) = 2n</p> <p>那么Cyclic Permutation和flipping结合起来呢？结论是也会落在这2n个可能性里面</p> <p>D1=S1, D2=S2, D3=S3</p> <p>但是D4!=S4而是介于 C4和S4之间，当然D4不是abelian Group</p> <p>Dn不是abelian group</p> <h2 id="klein-4-group"><a href="#klein-4-group" class="header-anchor">#</a> Klein 4 Group</h2> <p>n {1, 2, 3, 4}</p> <p>V = Klein 4 Group = {i, t12, t34, D}4</p> <table><thead><tr><th>i</th> <th>t12</th> <th>t34</th> <th>D</th></tr></thead> <tbody><tr><td>1-&gt;1<br>2-&gt;2<br>3-&gt;3<br>4-&gt;4</td> <td>1-&gt;2<br>2-&gt;1<br>3-&gt;3<br>4-&gt;4</td> <td>1-&gt;1<br>2-&gt;2<br>3-&gt;4<br>4-&gt;3</td> <td>1-&gt;2<br>2-&gt;1<br>3-&gt;4<br>4-&gt;3</td></tr></tbody></table> <table><thead><tr><th>◦</th> <th>i</th> <th>t12</th> <th>t34</th> <th>D</th></tr></thead> <tbody><tr><td>i</td> <td>i</td> <td>t12</td> <td>t34</td> <td>D</td></tr> <tr><td>t12</td> <td>t12</td> <td>i</td> <td>D</td> <td>t34</td></tr> <tr><td>t34</td> <td>t34</td> <td>D</td> <td>i</td> <td>t12</td></tr> <tr><td>D</td> <td>D</td> <td>t34</td> <td>t12</td> <td>i</td></tr></tbody></table> <h2 id="group-isomorphisms-同构"><a href="#group-isomorphisms-同构" class="header-anchor">#</a> Group Isomorphisms 同构</h2> <p>G = S2 = {i, t}</p> <p>G'= {+1, -1}</p> <p>G和G' 两者除了符号不同，性质相同，可以relabeling</p> <p>i&lt;-&gt;+1</p> <p>t&lt;-&gt;-1</p> <p>G&amp;G' are isomorphic if exists:</p> <p>φ: G&lt;-&gt;G' φ is bijective</p> <p>for ∀ x,y ∈ G, φ(x ◦ y) = φ(x)  ◦ φ(y)</p> <table><thead><tr><th>G</th> <th>...</th> <th>y</th> <th>....</th></tr></thead> <tbody><tr><td>...</td> <td></td> <td></td> <td></td></tr> <tr><td>x</td> <td></td> <td>x ◦ y</td> <td></td></tr> <tr><td>...</td> <td></td> <td></td> <td></td></tr></tbody></table> <table><thead><tr><th>G'</th> <th>...</th> <th>φ(y)</th> <th>...</th></tr></thead> <tbody><tr><td>...</td> <td></td> <td></td> <td></td></tr> <tr><td>φ(x)</td> <td></td> <td>φ(x) ◦ φ(y)</td> <td></td></tr> <tr><td>...</td> <td></td> <td></td> <td></td></tr></tbody></table> <p>注意：order相同的两个group未必是isomorphic的，比如 C4和Klein 4 group，对比两者的 i 明显规律不同！klein 4 group的每个元素都是自己跟自己互逆，而C4则不是</p> <p><strong>Isomorphism Class:</strong></p> <p>taking all groups that are isomorphic to one another and sticking them into a great big class, all of them are just the equivalent algebraic structure but with difference symbols used to denote the different elements of the group</p> <p>举例：</p> <p>G:</p> <p>(R, +)	实数是Filed，不过这里只考虑其在加法结构上的Abelian Group结构</p> <p>G':</p> <p>(R<sup>+</sup>, *)  R<sup>+</sup> = {x ∈ R | x &gt; 0 }	正实数在乘法结构上是Abelian Group</p> <p>φ: G-&gt;G'</p> <p>x,y ∈ G, ◦ 是 +， x ◦ y = x + y</p> <p>φ(x),φ(y) ∈ G', ◦ 是 *, φ(x) = e<sup>x</sup>, φ(y) = e<sup>y</sup></p> <p>for ∀ x,y ∈ G,</p> <p>φ(x ◦ y) = φ(x + y) = e<sup>x+y</sup>= e<sup>x</sup>e<sup>y</sup> = φ(x)φ(y) = φ(x)  ◦ φ(y)</p> <h2 id="subgroups"><a href="#subgroups" class="header-anchor">#</a> Subgroups</h2> <p>H ⊂ G 或 H &lt; G , every subgroup is a subset</p> <p>closure for H suddenly becomes non-trivial, because it's hard to say that for  ∀ x,y ∈ H, x ◦ y also ∈ H not outside of H</p> <p>H需要包含G的identity</p> <p>two trivial sub group：identity &amp; the entire group</p> <p>例子1：</p> <p>S3= {  i, t12, t13, t23, σ, σ<sup>2</sup> }</p> <p>C3  = {  i, σ, σ<sup>2</sup> }</p> <p>C3 ⊂  S3</p> <p>H = { i, t12 }	(isomorphic to S2)</p> <p>H ⊂  S3</p> <p>例子2：</p> <p>Integer Z= {0, 1, -1, 2, -2, ..........}</p> <p>aZ = {za | z ∈ Z } = { 0, a, -a, 2a, -2a, .......}</p> <p>aZ ⊂ Z</p> <p>0Z = {0} 1Z = Z 刚好是Z的two trivia sub group</p> <p>如何证明aZ也是group？</p> <p>closure： 利用ring的分配律（因为Integer是ring）：za+z'a = (z+z')a = z''a, z''=z+z' ∈ Z, z''a ∈ aZ</p> <p>其他 associative inverse identity都很显然</p> <p>结论：H &lt; Z and b ∈ H and b is the smallest positive integer, prove that H = bZ ⊂ Z</p> <p>证明：</p> <p>先证明 bZ ⊂ H</p> <p>b存在inverse -b，b+b=2b............从而构造出</p> <p>{0, b, -b, 2b, -2b, ......} 如果任何一个元素不存在与H中，那么H就不是闭合的，就不是group，所以bZ ⊂ H</p> <p>再证明H can't contain any other integers that are not within the set bZ</p> <p>let a  ∈ H but not in bZ, so:</p> <p>if a&lt;b, contradict to b is the smallest integers;</p> <p>if a&gt;b, then a = zb + r, z ∈ Z and b&gt;r&gt;0 (if r=b then a=(z+1)b, contradict to a not in bz)</p> <p>=&gt; r = a + (-zb) , because a ∈ H, -zb also ∈ H, so we have r ∈ H, contradict to b is the smallest integers</p> <p>结论：it's impossible for a finite group to be isomorphic to it's subgroup, however in infinite group very that's not the case.</p> <p>aZ isomorphic to Z</p> <p>aZ = {za | z ∈ Z }</p> <p>φ:  aZ -&gt; Z</p> <p>for ∀ x,y ∈ G, φ(x) = x/a</p> <p>φ(x ◦ y) = φ(x + y) = φ(za+z'a) = φ((z+z')a) =  z+z'</p> <p>φ(x)  ◦ φ(y) = φ(x) + φ(y) = φ(za) + φ(z'a) = z+z'</p> <p>结论：subgroup intersection交集也是subgroup</p> <p>H1,H2 &lt; G ,H1 ∩ H2 &lt; G</p> <p>H1 ∩ H2 = { g ∈ G | g∈H1,g∈H2 }</p> <p>证明H1 ∩ H2是group即可：</p> <p>首先不需要担心associativity 因为很显然如果其交集不遵守的话，H1和H2也就不是group，identity也显然即存在于H1又存在于H2,主要看其他几个性质：</p> <p>关于closure, for ∀ x,y ∈ H1 ∩ H2 证明 xy ∈ H1 ∩ H2，很简单由于 x,y ∈ H1，所以xy ∈ H1，同理xy ∈ H2，得证</p> <p>关于inverse，∀ x ∈ H1 ∩ H2，证明 x<sup>-1</sup> ∈ H1 ∩ H2，跟closure的证明一样x ∈ H1，所以x<sup>-1</sup> ∈ H1 ，同理x<sup>-1</sup> ∈ H2</p> <h2 id="cyclic-groups-and-subgroups"><a href="#cyclic-groups-and-subgroups" class="header-anchor">#</a> Cyclic Groups and subgroups</h2> <h3 id="finite-infinite-cyclic-group"><a href="#finite-infinite-cyclic-group" class="header-anchor">#</a> finite &amp; infinite Cyclic group</h3> <p>n ∈ N = {1, 2, 3, 4, 5, 6, ..........n}</p> <p>Cyclic Permutation就是rotate旋转圆盘（每次旋转360/n），所以</p> <p>旋转0次：</p> <p>1-&gt;1 2-&gt;2 .............n-&gt;n	用i表示</p> <p>旋转一次就是：</p> <p>1-&gt;2 2-&gt;3 ..........n-&gt;1	用<em>σ</em> 表示</p> <p>旋转两次</p> <p>1-&gt;3 2-&gt;4...........n-1-&gt;1 n-&gt;2	用<em>σ<sup>2</sup></em> 表示</p> <p>......</p> <p>旋转n-1次</p> <p>1-&gt;n 2-&gt;1 ..........n-&gt;n-1	用<em>σ<sup>n-1</sup></em> 表示</p> <p>前面是finite Cyclic group，</p> <p>但是如果我们假设研究infinite Cyclic group，比如整个自然数就会在旋转一次的时候遇到问题：</p> <p>1-&gt;2 2-&gt;3 .......... 由于是整个自然数，无法得到自然数的最后一个数让其指向1，所以无法实现Permutation，</p> <p>现在考虑更大的集合 Integer 整数，Z = { 0, 1, -1, 2, -2, .......}</p> <p>旋转一次就是：</p> <p>..... -3-&gt;-2 -2-&gt;-1 -1-&gt;0 0-&gt;1 1-&gt;2 2-&gt;3 ................. 现在随便找一个Integer 都能找到其对应的map</p> <p>但是现在又有个问题，前面的finite Cyclic group Cn当旋转n-1次相当于逆时针旋转1次，旋转a次的逆是n-a次，旋转n次就回到了i，但是这里因为是infinite，如果向一个方向旋转是回不到i的，所以这里需要引入反方向的旋转，反方向旋转一次：</p> <p>....-2-&gt;-3 -1-&gt;-2 0-&gt;-1 1-&gt;0 2-&gt;1 3-&gt;2............</p> <p>现在定义一组新的符号：</p> <p>identity：0</p> <p>顺时针（向右旋转）一次：+1</p> <p>逆时针（向左旋转）一次：-1</p> <p>{ 0, 1, -1, 2, -2,...... } 神奇的发现产生的这个infinite Cyclic group跟我们考虑的整个Integer Z是完全一样的</p> <h3 id="cyclic-subgroup"><a href="#cyclic-subgroup" class="header-anchor">#</a> Cyclic Subgroup</h3> <p>for cyclic group G, x ∈ G (x is not identity element), &lt;x&gt; called Cyclic subgroup generated by x</p> <p>&lt;x&gt; = {e, x, x<sup>2</sup>,x<sup>3</sup>............. x<sup>-1</sup>, x<sup>-2</sup>......} 根据group的性质，肯定包含identity,e= x<sup>0</sup>，然后根据闭合性质，x跟自己compose成 x<sup>2</sup>（参考前面Cyclic Permutation的例子，相当于旋转两次），接着生成 x<sup>3</sup>等，并且每个元素都存在逆</p> <p>注意：如果G是finite group，那么subgroup &lt;x&gt; 也必然是finite group（x的某个次幂=e），如果&lt;x&gt; 是infinite group，G必然也是infinite group</p> <p>我们下面考虑 infinite group的情况，证明&lt;x&gt; 是group：</p> <p>closure 闭合：∀ a,b ∈ Z (&lt;x&gt; 元素的次幂是Integer)</p> <p>x<sup>a </sup> ◦ x<sup>b</sup> = x<sup>a+b</sup></p> <p>x<sup>a </sup> = x ◦ x ........◦ x 表示x compose自己a次，所以x<sup>a </sup> ◦ x<sup>b</sup>就是x compose with自己a+b次，所以是满足闭合</p> <p>inverse显然存在，</p> <p>例子：</p> <p>for (Z,+) Integer under addition，</p> <p>&lt;2&gt; = { 0, 2, 4, 6........, -2, -4, -6..........} = 2Z（前面subgroup举例的aZ）</p> <p>结论：infinite Cyclic subgroup is always isomorphic to the infinite Cyclic group</p> <p>&lt;x&gt; isomorphic to (Z,+)</p> <p>&lt;x&gt; = {e, x, x<sup>2</sup>,x<sup>3</sup>............. x<sup>-1</sup>, x<sup>-2</sup>......}</p> <p>φ: &lt;x&gt; -&gt;(Z,+) , φ(x<sup>n</sup>) = n</p> <p>for ∀ a,b ∈ &lt;x&gt;,</p> <p>φ(a ◦ b) = φ(x<sup>m</sup> ◦ x<sup>n</sup>) = φ(x<sup>m+n</sup>) =  m+n</p> <p>φ(a)  ◦ φ(b) = φ(x<sup>m</sup>) + φ(x<sup>n</sup>) = m + n 	φ(a ◦ b)= φ(a)  ◦ φ(b) 得证</p> <p>finite Group</p> <p>&lt;x&gt; = {e, x, x<sup>2</sup>,x<sup>3</sup>.............}</p> <p>if &lt;x&gt; is finite group, then must exist m∈N is the smallest that give an entry that already had(start cyclic), so that&lt;x&gt; = {e, x, x<sup>2</sup>, x<sup>3</sup>, ......x<sup>m-1</sup> }, and it must be x<sup>m</sup> = e</p> <p>Prove:</p> <p>suppose x<sup>m</sup> = x<sup>n</sup> ∈N and n&lt;m</p> <p>(x<sup>-1</sup>)<sup>n</sup> x<sup>m</sup> = (x<sup>-1</sup>)<sup>n</sup> x<sup>n</sup></p> <p>=&gt; x<sup>m-n</sup> = e this contradict to m is the smallest that give an entry that already had</p> <p>不难证明 &lt;x&gt; = {e, x, x<sup>2</sup>, x<sup>3</sup>, ......x<sup>m-1</sup> } 是一个group，满足group的属性:</p> <p>closure: x<sup>a</sup> ◦ x<sup>b</sup> = x<sup>a+b</sup> if a+b&lt;m显然属于&lt;x&gt;, 等于m则 x<sup>m</sup> = e ，大于m比如介于(m,2m)则 x<sup>a</sup> ◦ x<sup>b</sup> = x<sup>m</sup>(x<sup>r</sup>)=x<sup>r</sup> r&lt;m</p> <p>inverse: 根据 x<sup>m</sup> = e =&gt; x<sup>1</sup> ◦ x<sup>m-1</sup> = e 找到complementary power即可</p> <p>结论： &lt;x&gt; = {e, x, x<sup>2</sup>, x<sup>3</sup>, ......x<sup>m-1</sup> }  is isomorphic to Cm = {e, σ<sup>1</sup>, σ<sup>2</sup>, ......., σ<sup>m-1</sup>}</p> <p>Theorem 8.2.7
Let G be a finite cyclic group of order n and let α be a generator of G. Then for every integer k that divides n there exists exactly one cyclic subgroup H of G of order k. This subgroup is generated by α<sup>n/k</sup>. H consists exactly of the elements a ∈ G which satisfy the condition a<sup>k</sup> = 1. There are no other subgroups.</p> <p>这个太容易证明了，首先cyclic group |G|=n， α 是generator，因此 a<sup>n</sup> = 1.</p> <p>cyclic subgroup H of G of order k，assume generator为 b，则 b<sup>k</sup> = 1.</p> <p>b属于G，因此b=a<sup>x</sup>	=&gt; (a<sup>x</sup>)<sup>k</sup> = 1 =&gt;  (a<sup>x</sup>)<sup>k</sup> = a<sup>n</sup> =&gt; x=n/k</p> <p>Example 8.10. We again consider the cyclic group Z<sub>11</sub><sup>*</sup>.We saw earlier that α = 8 is a primitive element in the group. If we want to have a generator β for the subgroup of order 2, we compute:
β =α<sup>n/k</sup> = 8<sup>10/2</sup> = 8<sup>5</sup> = 32768 ≡ 10 mod 11.
We can now verify that the element 10 in fact generates the subgroup with two
elements: β<sup>1</sup> = 10, β<sup>2</sup> = 100 ≡ 1 mod 11, β<sup>3</sup> ≡ 10 mod 11, etc.
Remark: Of course, there are smarter ways of computing 8<sup>5</sup> mod 11, e.g., through
8<sup>5</sup> = 8<sup>2</sup> 8<sup>2</sup> 8 ≡ (−2)(−2)8 ≡ 32 ≡ 10 mod 11.</p> <p>由上述得出<strong>Cyclic Group 定义</strong>：</p> <p>Cyclic group both the finite and infinite cyclic groups what they contain basically is they need to <strong>contain</strong> an element x ∈ C such that the subgroup group generated by x &lt;x&gt; is actually equal to the entire group</p> <p>&lt;1&gt; = { 0, +1, +2, +3......., -1, -2, -3,..........}</p> <h2 id="cayley-s-theorem"><a href="#cayley-s-theorem" class="header-anchor">#</a> Cayley's theorem</h2> <p>fundamentally the group is a set of symbols with composition law defined on it, so that raises an interesting question:</p> <p>we know we can use the concept of set permutation of some sets to be able to build a group but is it the case that if you have a group, is it always some set for which you can view the elements of the group as representing set permutations of that set, basically this is the great motivation question for cayley's theorem, the answer is yes</p> <h3 id="引入"><a href="#引入" class="header-anchor">#</a> 引入</h3> <p>前面讲了group的定义和属性，以及如何通过set Permutation来构造group，但是还没有回答一个问题就是：</p> <p>so the questions now becomes is it the case that we can always think of a group as being a set of symbols where these symbols are representing set permutations of some set.</p> <p>G={........}</p> <p>a ∈ G,</p> <p>aG = {a◦g | g ∈ G}</p> <table><thead><tr><th>◦</th> <th>&lt;---G---&gt; every elements in G</th></tr></thead> <tbody><tr><td>...</td> <td></td></tr> <tr><td>a</td> <td>a◦g</td></tr> <tr><td>....</td> <td></td></tr></tbody></table> <p>Ga = {g◦a | g ∈ G}</p> <table><thead><tr><th>◦</th> <th>...</th> <th>a</th> <th>...</th></tr></thead> <tbody><tr><td>&lt;--</td> <td></td> <td>g◦a</td> <td></td></tr> <tr><td>G every elements in G</td> <td></td> <td>g◦a</td> <td></td></tr> <tr><td>--&gt;</td> <td></td> <td>g◦a</td> <td></td></tr></tbody></table> <p>结论：aG = Ga = G for ∀ a ∈ G</p> <p>for aG and Ga, every elements appear once and only once,</p> <p>Prove:</p> <p>首先根据Group闭合的性质，a ∈ G，所以aG ∈ G，然后：</p> <p>先证明appear only once：</p> <p>assume   g&lt;&gt;g' but a◦g = a◦g'</p> <table><thead><tr><th>◦</th> <th>&lt;---</th> <th></th> <th>G every elements in G</th> <th>---&gt;</th></tr></thead> <tbody><tr><td>...</td> <td></td> <td></td> <td></td> <td></td></tr> <tr><td>a</td> <td></td> <td>a◦g</td> <td>a◦g'</td> <td></td></tr> <tr><td>....</td> <td></td> <td></td> <td></td> <td></td></tr></tbody></table> <p>=&gt;   a<sup>-1</sup>◦a◦g = a<sup>-1</sup>◦a◦g'</p> <p>=&gt; g = g' contradict to g&lt;&gt;g'</p> <p>再来证明every elements appear once：</p> <p>对于finite group来说，很简单，因为假设G的order是n，那么由于前面证明了g&lt;&gt;g'=&gt;a◦g &lt;&gt; a◦g' 所以aG产生的n个元素也各不相同，所以得证；</p> <p>然后对于infinite group来说，由于是infinite，换种思路：</p> <p>for 任意 g ∈ G，只要可以找到ax=g, x ∈ G不就可以了么</p> <p>=&gt; x=a<sup>-1</sup>g，所以对于任意g都可以找到x=a<sup>-1</sup>g 从而让ax=g 得证</p> <h3 id="凱萊定理"><a href="#凱萊定理" class="header-anchor">#</a> 凱萊定理</h3> <p>官方定义：</p> <p>In group theory, Cayley's theorem, named in honour of Arthur Cayley, states that every group G is isomorphic to a subgroup of the symmetric group acting on G.[1] This can be understood as an example of the group action of G on the elements of G.[2] The theorem can be obtained by explicitly constructing the representation within the representation of the symmetric group of permutation matrices, which is sometimes known as the regular representation.</p> <p>A permutation of a set G is any bijective function taking G onto G. The set of all permutations of G forms a group under function composition, called the symmetric group on G, and written as Sym(G).[3]</p> <p>解释：</p> <p>for group G={e.....}</p> <p>let's just take the the symbols from the Group G (not taking the composition law, only the symbols), so we got a Set</p> <p>S={e......}</p> <p>this is the SET that we're going to think of every element of the group as representing a set permutation of and the composition law is then going to represent the composition of those set permutations</p> <p>take any g ∈ S, a ∈ G,</p> <p>set permutation is bijective map from the SET to itself,</p> <p>we define **set permutation: a(g) **</p> <p>and because g ∈ S, and it's the same symbol from group G, so we can have:</p> <p>a(g) = a ◦ g，前面已经证明了 aG=G，every elements appear once and only once，所以必然是双射</p> <p>then we can define a new composition law based on this set permutation, it will be the same composition as the Group G</p> <table><thead><tr><th>◦</th> <th>&lt;---------G----------&gt;</th></tr></thead> <tbody><tr><td>e</td> <td>&lt;---------G----------&gt;</td></tr> <tr><td>...</td> <td></td></tr> <tr><td>a</td> <td>&lt;---------aG----------&gt;</td></tr> <tr><td>...</td> <td></td></tr></tbody></table> <p>eG 就像之前set Permutation的i</p> <p>aG 就像之前set Permutation的其他双射 比如之前研究过的t12 ，<em>σ</em>等</p> <p>然后我们定义新的composition就是set Permutation的composition，换句话就是对 i t12 <em>σ</em>这些符号所对应的set Permutation的composition law，当然我们这里不需要使用这些符号了，可以直接用 我们定义的 **set permutation: a(g) **g ∈ S, a ∈ G，假设新的composition符号是&amp;</p> <p>所以对于∀ a,b ∈ G，a&amp;b就代表 先进行set Permutation：b(g)，g ∈ S, b ∈ G，然后再进行set Permutation：a(b(g))， b(g) ∈ S, a ∈ G</p> <p>进而我们可以证明实际上这个a&amp;b = a(b(g)) 等同于 a和b先在G上composite a◦b，然后再进行我们定义的set Permutation (a◦b)(g), g ∈ S, a◦b ∈ G，即：</p> <p>(a◦b)(g) = a(b(g))</p> <p>很容易 根据我们的定义a(g) = a ◦ g 加上G上的associative性质即得证</p> <p>但是注意，我们不可以定义set Permutation：a(g) = g ◦ a 虽然前面知道 Ga也是双射，但是</p> <p>(a◦b)(g) = a(b(g)) 不成立，因为</p> <p>(a◦b)(g) = g◦(a◦b) 而 a(b(g)) = a(g◦b) = (g◦b)◦a = g◦(b◦a) 但是我们知道对于group a◦b并不一定等于b◦a，只有abelian group才有这个属性</p> <h2 id="parity-of-a-permutation"><a href="#parity-of-a-permutation" class="header-anchor">#</a> Parity of a permutation</h2> <table><thead><tr><th>t12 (1 2)</th> <th>t123 (1 2 3)</th> <th>t132 (1 3 2)</th> <th>t13,24 (1 3)(2 4)</th> <th>(1 3 4)(2 5)</th> <th>σ<sup>2</sup></th></tr></thead> <tbody><tr><td>1-&gt;2<br>2-&gt;1<br>3-&gt;3<br>4-&gt;4</td> <td>1-&gt;2<br>2-&gt;3<br>3-&gt;1<br>4-&gt;4</td> <td>1-&gt;3<br>2-&gt;1<br>3-&gt;2<br>4-&gt;4</td> <td>1-&gt;3<br>2-&gt;4<br>3-&gt;1<br>4-&gt;2</td> <td>1-&gt;3<br>2-&gt;5<br>3-&gt;4<br>4-&gt;1<br>5-&gt;2</td> <td>1-&gt;3<br>2-&gt;1<br>3-&gt;2<br>4-&gt;4</td></tr></tbody></table> <p>t12 (1 2) :</p> <p>​	2-cycle 意思是3 4不变，单看1和2就是类似Cyclic Permutation的两个元素的cycle rotate</p> <p>t123 (1 2 3)</p> <p>​	3-cycle 同理，4不变，此时是按 1 2 3的顺序进行的Cyclic Permutation的三个元素的一次rotate</p> <p>t132 (1 3 2)</p> <p>​	3-cycle 同理，只不过顺序变成了 1 3 2 进行的一次rotate</p> <p>t13,24 (1 3)(2 4)</p> <p>​	two 2-cycle</p> <p>进一步观察发现</p> <p>(1 2 3)=(1 3)(1 2)</p> <p>所有的Permutation都可以分解为多个2-cycle的composition，情况分为：</p> <p>(1 2)(1 2) 这种完全一样的就互相抵消</p> <p>(1 3 2) = (2 3)(1 2) = (1 3)( 2 3) 这种是有一个重合的就有多种写法</p> <p>(1 2)(3 4)=(3 4)(1 2) 这种没有重合的就满足communitative交换</p> <p>(1 3)(1 2) is the inverse of (1 2)(1 3)</p> <p>can only have even or odd decompositions</p> <p>(1 2)(1 3)(1 3)(1 2) = e 很简单 (1 3)(1 3) = e 抵消</p> <p>a = tn tn-1.....t1</p> <p>a<sup>-1</sup> = t1t2.....tn</p> <p>a = tn..........t1 n = even</p> <p>a = sm........s1 m = odd</p> <p>a<sup>-1</sup> =  s1.....sm</p> <p>a<sup>-1</sup> a = s1......smtn........t1 =e identity必须是even number of transpositions，如果是odd无法互相抵消</p> <h2 id="group-homomorphisms-同态"><a href="#group-homomorphisms-同态" class="header-anchor">#</a> Group Homomorphisms 同态</h2> <p>φ: G-&gt;G' φ doesn't have to be bijective</p> <p>for ∀ x,y ∈ G, φ(x ◦ y) = φ(x)  ◦ φ(y)</p> <ol><li>不需要满足 surjective 满射，即：</li></ol> <p>for ∀ g' ∈ G' ∃ g ∈ G, s.t. φ(g)  = g'</p> <p>2）不需要满足injective 单射</p> <p>for ∀ g' ∈ Im(φ)	Im(φ)={φ(g) | g ∈ G},</p> <p>∃ only one g ∈ G, s.t. φ(g)  = g'</p> <p>Prove:	φ(e<sub>G</sub>) = e<sub>G'</sub>	e<sub>G</sub>代表G的e  e<sub>G'</sub>是G'的e</p> <p>we know that:</p> <p>x ∈ G,  x ◦ x = x =&gt; x=e only solution for x compose with itself equal to itself is the identity</p> <p>so, to prove φ(e<sub>G</sub>) = e<sub>G'</sub> we just need to prove that φ(e<sub>G</sub>) ◦ φ(e<sub>G</sub>) = e<sub>G'</sub> ，</p> <p>φ(e<sub>G</sub>) ◦ φ(e<sub>G</sub>)  = φ(e<sub>G</sub>  ◦ e<sub>G</sub>)  and e<sub>G</sub>  ◦ e<sub>G</sub> = e<sub>G</sub></p> <p>=&gt; φ(e<sub>G</sub>) ◦ φ(e<sub>G</sub>) = φ(e<sub>G</sub>)  and because φ(e<sub>G</sub>)  is element in G',</p> <p>so we got the only solution is e<sub>G'</sub></p> <p>Prove:</p> <p>a, a<sup>-1</sup> ∈ G, (a, a<sup>-1</sup>  can be the same element)</p> <p>=&gt; φ(a) inverse is φ(a<sup>-1</sup>)</p> <p>or write as: φ(a<sup>-1</sup>) = InverseOf(φ(a)) 或写作 (φ(a))<sup>-1</sup></p> <p>φ(a) ◦ φ(a<sup>-1</sup>) = φ(a ◦ a<sup>-1</sup>)  = φ(e<sub>G</sub>) = e<sub>G'</sub></p> <p>Prove:</p> <p><strong>Im(φ) &lt; G' 	Im(φ)={φ(g) | g ∈ G}</strong> , means that we can reduce a non-surjective homomorphism to surjective homomorphism</p> <p>if the homomorphisms is surjective, then Im(φ) = G' , else Im(φ) is a proper subset of G',</p> <p>so we konw Im(φ)  is a subset of G', how to prove Im(φ)  is a subgroup of G',仍然是看group的性质：</p> <ol><li>closure	∀ g1,g2 ∈ Im(φ) , g1◦ g2 ∈ Im(φ)</li></ol> <p>prove: if g1,g2 ∈ Im(φ), means exist φ(a)=g1, φ(b)=g2 (a b can be equal, hormomorphism no need to be injective)</p> <p>g1◦ g2 = φ(a) ◦ φ(b) = φ(a ◦ b) ∈ Im(φ) 得证</p> <ol start="2"><li><p>associativity 继承的性质</p></li> <li><p>Identity</p></li></ol> <p>φ(e<sub>G</sub>) = e<sub>G'</sub>	e<sub>G'</sub> ∈ Im(φ)</p> <ol start="4"><li>Inverses	a' ∈ Im(φ) , (a')<sup>-1</sup> ∈ Im(φ)</li></ol> <p>we konw  (a')<sup>-1</sup>  = φ(a<sup>-1</sup>) so we got (a')<sup>-1</sup> ∈ Im(φ) 得证</p> <p>there is no point in considering non-subjective homomorphisms, because you can always reduce it into thining in terms of a subjective homomorphims,</p> <p>Example:</p> <p>φ: (Z, +) -&gt; S2</p> <p>Z={0,1,-1,2,-2.........}</p> <p>S2={+1,-1} 	+1代表identity，-1代表transpose</p> <p>φ(x)= +1 if x is even =-1 if x is odd</p> <p>Prove: (Z, +) -&gt; S2	∀ a,b ∈ Z φ(a+b)=φ(a)φ(b)</p> <p>case 1: a,b are even, φ(a)=φ(b)=1, a+b is even , φ(a+b)=1=φ(a)φ(b) 其他情况同理</p> <p>Kernel(φ) = { g ∈ G | φ(g)=e<sub>G'</sub>}</p> <p>if it's isomorphism,means it's bijective, then e<sub>G</sub> is the only element</p> <p>Prove: Kernel(φ) &lt; G subgroup:</p> <ol><li><p>closure, any a,b  ∈ kernel(φ), φ(a◦b)=e<sub>G'</sub> φ(a)◦φ(b)=e<sub>G'</sub> ◦ e<sub>G'</sub> = e<sub>G'</sub>  得证</p></li> <li><p>associativity 和 identity都很显然</p></li> <li><p>Inverse	a ∈ kernel(φ) prove a<sup>-1</sup> ∈ kernel(φ) 即证明 φ(a<sup>-1</sup>)=e<sub>G'</sub> :</p></li></ol> <p>根据前面的结论知道φ(a) inverse is φ(a<sup>-1</sup>) 所以</p> <p>φ(a<sup>-1</sup>) = InverseOf(φ(a)) 或写作 (φ(a) )<sup>-1</sup> =  InverseOf(e<sub>G'</sub>) =e<sub>G'</sub></p> <p><strong>conjugate element</strong></p> <p>a,g ∈ G, the conjugate of g by a: aga<sup>-1</sup></p> <p>if G is abelian, aga<sup>-1</sup> = aa<sup>-1</sup>g = g</p> <h3 id="normal-subgroup-正规子群"><a href="#normal-subgroup-正规子群" class="header-anchor">#</a> Normal subgroup 正规子群:</h3> <p>H&lt;G, ∀ h ∈ H ∀ g ∈ G, ghg<sup>-1</sup>∈ H, means that H has to be stable under conjugation by any element in G</p> <p>结论：All subgroups of Abelian groups is normal subgroup</p> <p>结论：all kernel group is normal subgroup，</p> <p>Prove: H= Kernel(φ) ∀ h ∈ Kernel(φ), ∀ g ∈ G, ghg<sup>-1</sup> ∈ Kernel(φ)，即证明 φ(ghg<sup>-1</sup>) = e<sub>G'</sub></p> <p>φ(ghg<sup>-1</sup>) = φ(gh) ◦ φ(g<sup>-1</sup>) = φ(g) ◦ φ(h) ◦ φ(g<sup>-1</sup>) =φ(g) ◦  e<sub>G'</sub>◦ φ(g<sup>-1</sup>) =φ(g) ◦  φ(g<sup>-1</sup>)</p> <p>我们知道：</p> <p>φ(g) ◦  φ(g<sup>-1</sup>) = φ(g ◦  g<sup>-1</sup>)  = φ(e<sub>G</sub>) = e<sub>G'</sub></p> <p>或者直接根据φ(g<sup>-1</sup>) 就是φ(g) 的inverse，得到e<sub>G'</sub></p> <p>得证</p> <h2 id="cosets-lagranges"><a href="#cosets-lagranges" class="header-anchor">#</a> Cosets + Lagranges</h2> <p>G={........}</p> <p>a ∈ G,</p> <p>aG = {a◦g | g ∈ G}</p> <p>Ga = {g◦a | g ∈ G}</p> <p>aG == Ga == G, every elements in the group appear once and only once</p> <p><strong>Cosets:</strong></p> <p>a ∈ G, subgroup H&lt;G ,</p> <p>left coset of H under a: aH = {a◦h | h ∈ H}</p> <p>right coset of H under a: Ha</p> <p>a ∈ aH, a ∈ Ha， 因为subgroup H必然包含identity e，left cosets和right cosets必然不包含identity e，因为下面会证明cosets跟H元素完全不同，所以叫cosets而不是group</p> <p>if a ∈ H，跟前面的Cayley's theorem讲的内容一样，aH=Ha=H	(aH=Ha 还有几种情况：G是abelian group；或者H是normal subgroup)</p> <p>if a ∉ H, aH Ha are free of H (distinct from H), Prove by contradiction:</p> <p>aH = {a◦h | h ∈ H} , h' = a◦h, assume h' ∈ H</p> <p>h' = a◦h=&gt; h'◦h<sup>-1</sup> = a , h<sup>-1</sup> ∈ H (h ∈ group H, exist inverse), so h'◦h<sup>-1</sup> ∈ H (closure), so a ∈ H, contradict to a ∉ H得证</p> <p>note: 当然很容易知道，aH的元素不仅distinct from H，各自也是不同的，也是利用反证，比如假设存在不同的h1 h2使得ah1=ah2，两边取a的逆就得到反证，因此aH的元素个数跟H的元素个数相同，即order相同</p> <p>if H is a Normal subgroup of G: ∀ a ∈ G, left cosets equal to right cosets:aH=Ha，即 aH ⊂ Ha  AND Ha ⊂ aH</p> <p>Prove: a◦h ∈ aH, h ∈ H, to show ∃ h' ∈ H, s.t. h'a = ah =&gt; h' = aha<sup>-1</sup> ,</p> <p>because H is a normal subgroup of G, by the definition of normal subgroup:</p> <blockquote><p>H&lt;G, ∀ h ∈ H ∀ g ∈ G, ghg<sup>-1</sup>∈ H, means that H has to be stable under conjugation by any element in G</p></blockquote> <p>so  h' = aha<sup>-1</sup> is true 得证</p> <p><strong>Properties of Coset</strong></p> <p>a◦h ∈ aH,	(a◦h)H = aH</p> <p>(a◦h)H =  {(a◦h)◦h' | h' ∈ H} = {a◦(h◦h')| h' ∈ H} 	再次使用 Cayley's theorem，{h◦h'| h' ∈ H} = hH =H</p> <p>=&gt; (a◦h)H ={a◦(h◦h')| h' ∈ H} ={a◦h''| h'' ∈ H}</p> <p>Example:</p> <p>G=(Z, +)</p> <p>subgroup一节讲过 H=5Z={ 5z|z∈Z} = {0, 5, -5, 10, -10.......}</p> <p>because (Z, +) is abelian group, left coset is the same as right coset</p> <p>a = 1</p> <p>aH = 1+H = 1+5Z = {1, 6, -4, 11, -9, ........}</p> <p>Partition of set, split SET into N partition, P = { subset1, subset2, .....,subsetN}</p> <p>H&lt;G,</p> <p>if H not G, then there must be some elements outside of H but inside of G,</p> <p>a ∉ H, 从前面结论知道 element in aH totally distinct from H, then:</p> <p>H union aH 可能等于 G，否则就存在</p> <p>b ∉ H union aH，that bH totally distinct from  (H union aH)，我们已经知道同理aH，bH totally distinct from  H，但是怎么证明 bH totally distinct from  aH，prove by contradiction:</p> <p>aH =  {a◦h | h ∈ H}</p> <p>bH =  {b◦h | h ∈ H}</p> <p>assume exist b◦h1 = a◦h2, h1,h2∈H</p> <p>=&gt; b = a◦h2◦h1<sup>-1</sup> ,h2◦h1<sup>-1</sup> ∈ H, so b ∈ aH，跟前面的前提b ∉ H union aH矛盾，得证</p> <p>如果 H union aH union bH 都不能cover整个G，则continue</p> <p>所以Partition of G = { H, aH,bH, .........} 注意，如果确定了H，这个结果是唯一的</p> <p>如果H是finite group，H的order |H|=m, 即H有m个元素，那么所有的cosets都跟H有相同的order，因为all elements in aH are distinct</p> <h3 id="lagranges-theorem"><a href="#lagranges-theorem" class="header-anchor">#</a> Lagranges Theorem</h3> <p>G is finite group / has an order(number of elements in group)</p> <p>|G| = n|H| n ∈ N,</p> <p>OR  |H| must be divide by |G|</p> <p>n实际上就是前面的 Partition of G  = { H, aH,bH, .........}  partition的数量，因为前面知道aH，bH，nH都跟H的order一样</p> <p>用处--快速验证 是不是subgroup，首先看是否 obey lagranges theorem，看order是否被整除，如果否则不是，如果是进一步验证是否满足group的composition law</p> <p>example：</p> <p>|G| = Prime number=P = 2, 3, 5, 7............</p> <p>其 subgroup |H|=1 or |G|</p> <p>take some non-identity element x from G, x≠ e<sub>G</sub>，前面讲的Cyclic subgroup提到的，</p> <p>infinite Cyclic group: &lt;x&gt; = {e, x, x<sup>2</sup>,x<sup>3</sup>............. x<sup>-1</sup>, x<sup>-2</sup>......}</p> <p>finite cyclic group: &lt;x&gt; = {e, x, x<sup>2</sup>, x<sup>3</sup>, ......x<sup>m-1</sup> }  x<sup>m</sup> = e</p> <p>对于 order为prime number=P 的finite group G来说，从non-identity element x生成的finite Cyclic group &lt;x&gt; = {e, x, x<sup>2</sup>, x<sup>3</sup>, ......x<sup>m-1</sup> }  x<sup>m</sup> = e，m就是G的order = P，因为我们前面有结论其 subgroup |H|=1 or |G|，然后我们取出的是non-identity element x，所以 &lt;x&gt; 的 order就是等于|G|，所以m=P=|G|,x<sup>P</sup>=e (x<sup>P</sup>=e is a generalization of Fermat’s Little Theorem for all cyclic groups)，换句话说就是non-identity element x生成的finite Cyclic group &lt;x&gt; 就是整个 G，所以G is isomorphic to a finite cyclic group 即 C<sub>P</sub></p> <p>Note: 网络上很多说法不严谨，比如直接说素数阶群必为循环群 https://blog.csdn.net/qq_25847123/article/details/100572099</p> <p>例子：</p> <p>Z<sub>11</sub><sup>*</sup> ={x mod 11| x=1,2....10} ,</p> <p>Z<sub>11</sub><sup>*</sup> = {1,2,3,4,5,6,7,8,9,10}.</p> <p>| Z<sub>11</sub><sup>*</sup> | = 10</p> <p>x=1, &lt;x&gt; ={1} ord(1) =1</p> <p>x=2, &lt;x&gt; ={1,2,3,4,5,6,7,8,9,10} ord(2) =10</p> <p>x=3, &lt;x&gt; ={3,9,5,4,1} ord(3) =5</p> <p>x=4, &lt;x&gt; ={4,5,9,3,1} ord(4) =5</p> <p>x=5, &lt;x&gt; ={5,3,4,9,1} ord(5) =5</p> <p>x=6, &lt;x&gt; ={1,2,3,4,5,6,7,8,9,10} ord(6) =10</p> <p>x=7, &lt;x&gt; ={1,2,3,4,5,6,7,8,9,10} ord(7) =10</p> <p>x=8, &lt;x&gt; ={1,2,3,4,5,6,7,8,9,10} ord(8) =10</p> <p>x=9, &lt;x&gt; ={9,4,3,5,1} ord(9) =5</p> <p>x=10, &lt;x&gt; ={10,1} ord(10) =2</p> <h2 id="quotient-groups"><a href="#quotient-groups" class="header-anchor">#</a> Quotient Groups</h2> <p>N &lt; G (N is a subgroup of G and N is a normal subgroup 正规子群，conjunction stable：</p> <p>∀ n ∈ N	∀ g ∈ G	gng<sup>-1</sup> ∈ N),</p> <p>we call G/N: Quotient Group G over N or Group G module group N</p> <p><strong>现在开始构造Quotient Group</strong>，前面一节我们知道</p> <p>if H is a Normal subgroup of G: ∀ a ∈ G, left cosets equal to right cosets: aN=Na，意味着我们对large group G进行 Partition分区的话，就只有一种方式或一种结果，因为left cosets和right cosets相等，</p> <p>假设G被partition成：N, aN，bN。。。。</p> <p>G/N={	{N}, {aN}, {bN}, .....	}</p> <p>然后用符号来表示{N}, {aN}, {bN}，比如{N}包含identity，可以用e bar即e上面加一横，不好打出来，就这么写：e¯，这也叫做 equivalence class: forgot the load of elements in {N}, {aN}, {bN}，we are going to view them as one mathematical entity now, we're going to sort of contract them down and just denote them all basically to just be represented by a single symbol, kind of crushing them together into one blob rather than loads of elements, condensing it all down to think of it as one mathematical object.</p> <p>同理用a¯，b¯代表{aN}, {bN}</p> <p>G/N = {e¯, a¯, b¯...........}</p> <p><strong>然后在构造其 composition law</strong>，</p> <p>a¯ ◦ b¯ 相当于两个cosets进行组合计算，这里的◦定义为：</p> <p>第一步： take representative from each cosets and compose，自然的a¯  b¯ 各自的representative是a 和 b（或者说是ae和be，e ∈ N），所以</p> <p>a¯ ◦ b¯ = a ◦ b，变回了G这个group元素a b的composition</p> <p>第二步：取 (a ◦ b)¯ 即a ◦ b的cosets {abN}</p> <p>问题：how do we know whichever representative we take within these cosets doesn't matter？换言之：</p> <p>假设我们不取特殊的a/ae和b/be，而是从a¯=aN取普通的 a◦n （∀ n ∈ N），同样取得b¯ 的representative b◦n' （∀ n' ∈ N），</p> <p>a¯ ◦ b¯ =  a◦n ◦ b◦n' ，现在要证明a◦n ◦ b◦n' 一定是属于(a ◦ b)¯ 即a ◦ b的cosets {abN}，再转换一下就是说一定存在 n'' ∈ N，从而让</p> <p>a◦n ◦ b◦n'= a◦b◦n''</p> <p>证明：a◦n ◦ b◦n' = a◦b◦b<sup>-1</sup>◦n ◦ b◦n' = a◦b◦(b<sup>-1</sup>◦n ◦ b)◦n'，而 b<sup>-1</sup>◦n ◦ b 对于normal group N来说就等于another element in N,</p> <p>所以(b<sup>-1</sup>◦n ◦ b)◦n'自然也是N的元素比如用n''表示，得证</p> <p><strong>现在要证明构造的composition law满足group的规则：</strong></p> <ol><li><p>closure</p> <p>很显然，我们定义的composition就是说两个cosets运算得到另一个cosets，G是由所有cosets partition组合的，所以闭合</p></li> <li><p>associativity</p> <p>也挺显然的，因为根据定义，本来就是借助G的compose，写出来就是：</p> <p>(a¯ ◦ b¯)◦ c¯ = (a ◦ b)¯◦ c¯ = ((a ◦ b)◦ c)¯</p> <p>a¯ ◦( b¯◦ c¯) =a¯ ◦ (b ◦ c)¯ =  (a ◦ (b◦ c))¯</p> <p>((a ◦ b)◦ c = a ◦ (b◦ c) 所以对应的cosets当然也是一样的了，即((a ◦ b)◦ c)¯= (a ◦ (b◦ c))¯，所以</p> <p>(a¯ ◦ b¯)◦ c¯ = a¯ ◦( b¯◦ c¯)</p></li> <li><p>identity</p> <p>e¯ ◦ a¯ = a¯ ◦ e¯ = a¯</p> <p>同样是利用定义</p> <p>e¯ ◦ a¯ = (e ◦ a)¯ = a¯ 同理，得证</p></li> <li><p>inverses exists</p> <p>∀ a¯ ∈ G/N，∃ a¯<sup>-1</sup> s.t a¯ ◦ a¯<sup>-1</sup> = a¯<sup>-1</sup>◦ a¯ =e¯</p> <p>仍然是利用定义，对于a¯即aN来说，representative代表性的元素取 a◦e即a，因为</p> <p>a∈ G，所以a◦a<sup>-1</sup> = a<sup>-1</sup>◦a =e ，自然我们根据定义</p> <p>a¯ ◦ a<sup>-1</sup>¯  = (a◦a<sup>-1</sup>)¯ = e¯</p> <p>当然 a<sup>-1</sup> 可能跟a在同一个cosets中，即a¯ 自己是自己的inverse，为什么取representative  a◦e即a，a¯ 中其他元素呢，我们前面已经证明过了<strong>how do we know whichever representative we take within these cosets doesn't matter:</strong></p> <p>试着证明下吧</p> <p>a◦n1 ◦ b◦n2 = a◦b◦b<sup>-1</sup>◦n1 ◦ b◦n2 = a◦b◦(b<sup>-1</sup>◦n1 ◦ b)◦n2，而 b<sup>-1</sup>◦n ◦ b 对于normal group N来说就等于another element in N 比如n3,</p> <p>所以如果b是a的逆，则a◦b=e，从而a◦n1 ◦ b◦n2 =  a◦b◦(b<sup>-1</sup>◦n1 ◦ b)◦n2 = e◦n3◦n2 = n4，n4∈N即 n4∈ e¯  得证</p></li></ol> <h3 id="例子-z-3z"><a href="#例子-z-3z" class="header-anchor">#</a> 例子 Z/3Z</h3> <p>Integer Z= {0, 1, -1, 2, -2, ..........}</p> <p>3Z = {3z | z ∈ Z } = { 0, 3, -3, 6, -6, .......} = 0¯</p> <p>1+3Z ={1+x | x ∈ 3Z } = { 1, 4, -2, 7, -5, .......} = 1¯</p> <p>2+3Z ={2+x | x ∈ 3Z } = { 2, 5, -1, 8, -4, .......} = 2¯</p> <p>note: 画一个数轴比较容易理解</p> <p>Z/3Z = { 0¯,  1¯,  2¯}</p> <table><thead><tr><th>◦</th> <th>0¯</th> <th>1¯</th> <th>2¯</th></tr></thead> <tbody><tr><td>0¯</td> <td>0¯</td> <td>1¯</td> <td>2¯</td></tr> <tr><td>1¯</td> <td>1¯</td> <td>2¯</td> <td>0¯</td></tr> <tr><td>2¯</td> <td>2¯</td> <td>0¯</td> <td>1¯</td></tr></tbody></table> <p>Z/3Z isomorphic to C3，根据前面 Lagrange theorem知道，Z/3Z的order=3 prime，因此由non-identity元素生成的finite cyclic group，比如&lt;1¯&gt; 首先包含identity 0¯和1¯，然后1¯+1¯=2¯， 1¯+1¯+1¯=0¯终止，因此&lt;1¯&gt; = { 0¯,  1¯,  2¯}</p> <h3 id="_1st-isomorphism-theorem"><a href="#_1st-isomorphism-theorem" class="header-anchor">#</a> 1st isomorphism theorem</h3> <p>in previous section we know that there is no point in considering non-subjective homomorphisms, because you can always reduce it into thining in terms of a subjective homomorphims:</p> <p>φ: G-&gt;G'  (G' here must be subjective:for ∀ g' ∈ G' ∃ g ∈ G, s.t. φ(g)  = g', if G' is not subjective, we must turn it into Im(φ))</p> <p>for ∀ x,y ∈ G, φ(x ◦ y) = φ(x)  ◦ φ(y)</p> <p>G' is isomorphic to the quotient group of the domain group over/by the kernel of the homomorphism:</p> <p>G' is isomorphic to G/ker(φ)</p> <p>remind: Kernel(φ) = { g ∈ G | φ(g)=e<sub>G'</sub>} and all kernel group is normal subgroup</p> <p>G/ker(φ) means partition up G into cosets</p> <p><strong>结论：within the same cosets of the kernel of the homomorphism(cosets: ker(φ), a◦ker(φ) ,b◦ker(φ) ...) are going to be mapped on to the same elements in G'(the co-domain by this homomorphims φ)</strong></p> <p>Prove:  for all the elements in coset a¯=a◦ker(φ), will be mapped on the same elements in G'</p> <p>=&gt; for all the elements in coset a¯=a◦ker(φ) will be mapped on the same elements as element a</p> <p>=&gt; φ: G-&gt;G' , so a mapped on to φ(a), all the other elements in coset a¯=a◦ker(φ) will be mapped on to φ(a)</p> <p>for n∈ker(φ), a◦n is arbitrary element of a¯=a◦ker(φ), so</p> <p>according to the law of homomorphims, φ(a◦n) = φ(a)  ◦ φ(n) and because n∈ker(φ), based on the definition of kernel group, φ(n)=e<sub>G'</sub>, so that φ(a◦n) = φ(a)  ◦ e<sub>G'</sub> =  φ(a)</p> <p>隐含结论：insight: basically if we use the kernel of the homomorphism(ker(φ)) to partition up the domain group, then the elements in the same cosets of the kernel of the homomorphism(cosets: ker(φ), a◦ker(φ) ,b◦ker(φ) ...) are all mapped on to the same element in the co-domain group, it tells us the same number of elements in the domain group are being mapped on every element in the co-domain group, so if the homomorphism is not injective(not one to one), means that there are multiple elements in domain group being mapped on to one element in the co-domain group, then each element in the co-domain group must have the same number of elements in the domain group mapped on to them, can not have one element in the co-domain group that has two element in the domain group mapped on to it while another element in the co-domain group has three elements in the domain group mapped on to it</p> <p><strong>结论： if we elements in two different cosets of the kernel of the homomorphism(cosets: ker(φ), a◦ker(φ) ,b◦ker(φ) ...) , they have to be mapped on to differenet elements in the co-domain group G'</strong></p> <p>Prove: element in a¯=a◦ker(φ) and b¯=b◦ker(φ) must be mapped on to different elements in the co-domain group G',</p> <p>prove by contradiction: take representatives a and b from a¯and b¯, let's assume that φ(a)=φ(b),</p> <p>compose φ(a) ◦ φ(b<sup>-1</sup>)=φ(b) ◦ φ(b<sup>-1</sup>), =&gt; φ(a◦b<sup>-1</sup>) = φ(b◦b<sup>-1</sup>) = φ(e<sub>G</sub>) = e<sub>G'</sub> ,it means that a◦b<sup>-1</sup> is the element of ker(φ),</p> <p>a◦b<sup>-1</sup> = n, and n∈ker(φ) =&gt; a=n◦b means a is an element in the right cosets of  the kernel of the homomorphism by b , and for normal subgroup, left cosets equal to right cosets, so that a ∈ b¯=b◦ker(φ) , contradict to the partition of G</p> <p>现在开始证明</p> <p>G' is isomorphic to G/ker(φ)</p> <p>a¯∈ G/ker(φ)，因为前面证明了结论：</p> <p><em>within the same cosets of the kernel of the homomorphism(cosets: ker(φ), a◦ker(φ) ,b◦ker(φ) ...) are going to be mapped on to the same elements in G'(the co-domain by this homomorphims φ)</em></p> <p>因此从 a¯ 取一个representative即可，比如a，</p> <p>定义 F:  G/ker(φ) -&gt; G'，F(a¯) = φ(a) (巧妙的利用 φ: G-&gt;G')</p> <p>then Prove it's bijective:</p> <ol><li>surjective</li></ol> <p>利用 φ，前面定义的时候我们说了φ: G-&gt;G' 必须是surjective，所以对于G'中的元素φ(x)来说，必然有G中的x与之对应，自然x就属于某个cosets，即属于G/ker(φ)={e¯, a¯, b¯.......} 的某个元素</p> <ol start="2"><li>injective</li></ol> <p>同样根据前面的结论：</p> <p><em>if we elements in two different cosets of the kernel of the homomorphism(cosets: ker(φ), a◦ker(φ) ,b◦ker(φ) ...) , they have to be mapped on to differenet elements in the co-domain group G'</em></p> <p>所以对于G/ker(φ)={e¯, a¯, b¯.......} 来说，每个元素map到G'的都是唯一的，不会有两个元素map到同一个G'的元素上</p> <p>finally prove it obey the property of isomorphism:</p> <p>∀ a¯, b¯ ∈ G/ker(φ), prove F(a¯◦ b¯) =  F(a¯) ◦ F(b¯)</p> <p>F(a¯◦ b¯) = F((a◦ b)¯) = φ(a◦b) =  φ(a) ◦ φ(b)</p> <p>F(a¯) ◦ F(b¯)  = φ(a) ◦ φ(b)</p> <p>得证</p> <p>todo:</p> <p>Z<sup>*</sup><sub>p</sub> <strong>Multiplicative group of integers modulo n / 整数模n乘法群</strong></p> <p>在同余理论中，模 n 的互质同余类组成一个乘法群，称为整数模 n 乘法群，也称为模 n 既约剩余类。在环理论中，一个抽象代数的分支，也称这个群为整数模 n 的环的单位群（单位是指乘法可逆元）。</p> <p>这个群是数论的基石，在密码学、整数分解和素性测试均有运用。例如，关于这个群的阶（即群的“大小”），我们可以确定如果 n 是质数当且仅当阶数为 n-1。</p> <p>https://en.wikipedia.org/wiki/Multiplicative_group_of_integers_modulo_n</p> <p>https://baike.baidu.com/item/整数模n乘法群/22770365?fr=aladdin</p> <div id="disqus_thread"></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/docs/assets/js/app.2a7e14f6.js" defer></script><script src="/docs/assets/js/2.37e66b58.js" defer></script><script src="/docs/assets/js/42.dee66438.js" defer></script><script src="/docs/assets/js/11.f6e7f18e.js" defer></script>
  </body>
</html>
