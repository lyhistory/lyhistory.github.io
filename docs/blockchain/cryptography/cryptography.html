<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Shift Cipher (or Caesar Cipher) | 计算机基础教程</title>
    <meta name="generator" content="VuePress 1.9.7">
    <script async="true" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9742852210287449" crossorigin="anonymous"></script>
    <script async="true" src="https://www.googletagmanager.com/gtag/js?id=AW-748196294"></script>
    <script>
          window.dataLayer = window.dataLayer || [];
		  function gtag(){dataLayer.push(arguments);}
		  gtag('js', new Date());
		  
		  gtag('config', 'AW-748196294');
        </script>
    <script>
			(function() { // DON'T EDIT BELOW THIS LINE
			
			})();
		 </script>
    <meta name="description" content="软件开发教程，白帽黑客入门教程，区块链入门教程，物联网，大数据">
    
    <link rel="preload" href="/docs/assets/css/0.styles.d4eb5ad8.css" as="style"><link rel="preload" href="/docs/assets/js/app.650a987d.js" as="script"><link rel="preload" href="/docs/assets/js/2.d450803a.js" as="script"><link rel="preload" href="/docs/assets/js/100.78a1e34e.js" as="script"><link rel="preload" href="/docs/assets/js/7.be017326.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.6280ea0f.js"><link rel="prefetch" href="/docs/assets/js/101.d462fae9.js"><link rel="prefetch" href="/docs/assets/js/102.77970bea.js"><link rel="prefetch" href="/docs/assets/js/103.ef970172.js"><link rel="prefetch" href="/docs/assets/js/104.ce8eb710.js"><link rel="prefetch" href="/docs/assets/js/105.36a71e55.js"><link rel="prefetch" href="/docs/assets/js/106.b2d3b318.js"><link rel="prefetch" href="/docs/assets/js/107.bd236459.js"><link rel="prefetch" href="/docs/assets/js/108.62b2c756.js"><link rel="prefetch" href="/docs/assets/js/109.200d1c9e.js"><link rel="prefetch" href="/docs/assets/js/11.4f1296fa.js"><link rel="prefetch" href="/docs/assets/js/110.fb8c7fe0.js"><link rel="prefetch" href="/docs/assets/js/111.0f75c6ac.js"><link rel="prefetch" href="/docs/assets/js/112.0b136230.js"><link rel="prefetch" href="/docs/assets/js/113.1d671039.js"><link rel="prefetch" href="/docs/assets/js/114.7a842863.js"><link rel="prefetch" href="/docs/assets/js/115.7828b562.js"><link rel="prefetch" href="/docs/assets/js/116.51bf1151.js"><link rel="prefetch" href="/docs/assets/js/117.e459d63c.js"><link rel="prefetch" href="/docs/assets/js/118.7322910d.js"><link rel="prefetch" href="/docs/assets/js/119.0b0b9504.js"><link rel="prefetch" href="/docs/assets/js/12.25f970c0.js"><link rel="prefetch" href="/docs/assets/js/120.9376b1d8.js"><link rel="prefetch" href="/docs/assets/js/121.20883507.js"><link rel="prefetch" href="/docs/assets/js/122.63f4c7cf.js"><link rel="prefetch" href="/docs/assets/js/123.c7764c61.js"><link rel="prefetch" href="/docs/assets/js/124.62a5fce9.js"><link rel="prefetch" href="/docs/assets/js/125.0ffc653e.js"><link rel="prefetch" href="/docs/assets/js/126.54d37b72.js"><link rel="prefetch" href="/docs/assets/js/127.c2c22d99.js"><link rel="prefetch" href="/docs/assets/js/128.be15ff04.js"><link rel="prefetch" href="/docs/assets/js/129.289dba17.js"><link rel="prefetch" href="/docs/assets/js/13.0a356446.js"><link rel="prefetch" href="/docs/assets/js/130.53c551b0.js"><link rel="prefetch" href="/docs/assets/js/131.26f3119f.js"><link rel="prefetch" href="/docs/assets/js/132.2da5a809.js"><link rel="prefetch" href="/docs/assets/js/133.805f36ba.js"><link rel="prefetch" href="/docs/assets/js/134.ae98d9c6.js"><link rel="prefetch" href="/docs/assets/js/135.93655658.js"><link rel="prefetch" href="/docs/assets/js/136.c8db6196.js"><link rel="prefetch" href="/docs/assets/js/137.c1483793.js"><link rel="prefetch" href="/docs/assets/js/138.3b990d46.js"><link rel="prefetch" href="/docs/assets/js/139.ddc2131e.js"><link rel="prefetch" href="/docs/assets/js/14.f8cbf4a0.js"><link rel="prefetch" href="/docs/assets/js/140.edb31f2f.js"><link rel="prefetch" href="/docs/assets/js/141.93bde59f.js"><link rel="prefetch" href="/docs/assets/js/142.6da407a1.js"><link rel="prefetch" href="/docs/assets/js/143.6b73dadb.js"><link rel="prefetch" href="/docs/assets/js/144.0e5dec99.js"><link rel="prefetch" href="/docs/assets/js/145.cffa89ce.js"><link rel="prefetch" href="/docs/assets/js/146.eeef3cdb.js"><link rel="prefetch" href="/docs/assets/js/147.f4a64dc7.js"><link rel="prefetch" href="/docs/assets/js/148.eefd5839.js"><link rel="prefetch" href="/docs/assets/js/149.66c85b5d.js"><link rel="prefetch" href="/docs/assets/js/15.1149fa19.js"><link rel="prefetch" href="/docs/assets/js/150.c1620bfe.js"><link rel="prefetch" href="/docs/assets/js/151.e6811790.js"><link rel="prefetch" href="/docs/assets/js/152.ef71743e.js"><link rel="prefetch" href="/docs/assets/js/153.7f93b564.js"><link rel="prefetch" href="/docs/assets/js/154.fc8e099a.js"><link rel="prefetch" href="/docs/assets/js/155.4e6aca0d.js"><link rel="prefetch" href="/docs/assets/js/156.2dbf12a3.js"><link rel="prefetch" href="/docs/assets/js/157.844a0f9b.js"><link rel="prefetch" href="/docs/assets/js/158.5c17e555.js"><link rel="prefetch" href="/docs/assets/js/159.3e66963e.js"><link rel="prefetch" href="/docs/assets/js/16.47e36cc3.js"><link rel="prefetch" href="/docs/assets/js/160.16fb7822.js"><link rel="prefetch" href="/docs/assets/js/161.bbfe2865.js"><link rel="prefetch" href="/docs/assets/js/162.b113f3ae.js"><link rel="prefetch" href="/docs/assets/js/163.067b4227.js"><link rel="prefetch" href="/docs/assets/js/164.82ef6347.js"><link rel="prefetch" href="/docs/assets/js/165.8d08b6fc.js"><link rel="prefetch" href="/docs/assets/js/166.8b399bfe.js"><link rel="prefetch" href="/docs/assets/js/167.1bb5fa28.js"><link rel="prefetch" href="/docs/assets/js/168.fca08777.js"><link rel="prefetch" href="/docs/assets/js/169.8c26c529.js"><link rel="prefetch" href="/docs/assets/js/17.58360e9a.js"><link rel="prefetch" href="/docs/assets/js/170.c67e9069.js"><link rel="prefetch" href="/docs/assets/js/171.6dffe5c5.js"><link rel="prefetch" href="/docs/assets/js/172.c9b3db0f.js"><link rel="prefetch" href="/docs/assets/js/173.8f15d14d.js"><link rel="prefetch" href="/docs/assets/js/174.43af4d3c.js"><link rel="prefetch" href="/docs/assets/js/175.a6e5793f.js"><link rel="prefetch" href="/docs/assets/js/176.ebcef599.js"><link rel="prefetch" href="/docs/assets/js/177.2175c95d.js"><link rel="prefetch" href="/docs/assets/js/178.fc4f8b9d.js"><link rel="prefetch" href="/docs/assets/js/179.9468428c.js"><link rel="prefetch" href="/docs/assets/js/18.cdf43746.js"><link rel="prefetch" href="/docs/assets/js/180.c9386a8f.js"><link rel="prefetch" href="/docs/assets/js/181.f0decc92.js"><link rel="prefetch" href="/docs/assets/js/182.45e1f5d4.js"><link rel="prefetch" href="/docs/assets/js/183.c9544df2.js"><link rel="prefetch" href="/docs/assets/js/184.4288b66c.js"><link rel="prefetch" href="/docs/assets/js/185.a6871a28.js"><link rel="prefetch" href="/docs/assets/js/186.0cae6ad0.js"><link rel="prefetch" href="/docs/assets/js/187.eb0a2d4c.js"><link rel="prefetch" href="/docs/assets/js/188.5428bbcd.js"><link rel="prefetch" href="/docs/assets/js/189.c2023260.js"><link rel="prefetch" href="/docs/assets/js/19.9643a492.js"><link rel="prefetch" href="/docs/assets/js/190.1259fe0c.js"><link rel="prefetch" href="/docs/assets/js/191.8158a666.js"><link rel="prefetch" href="/docs/assets/js/192.a5ae8765.js"><link rel="prefetch" href="/docs/assets/js/193.04942d8f.js"><link rel="prefetch" href="/docs/assets/js/194.59a9f2cd.js"><link rel="prefetch" href="/docs/assets/js/195.73cb8b00.js"><link rel="prefetch" href="/docs/assets/js/196.99e13e37.js"><link rel="prefetch" href="/docs/assets/js/197.97b7cbd9.js"><link rel="prefetch" href="/docs/assets/js/198.b39b2e80.js"><link rel="prefetch" href="/docs/assets/js/199.5e6907d6.js"><link rel="prefetch" href="/docs/assets/js/20.6fa24146.js"><link rel="prefetch" href="/docs/assets/js/200.836db031.js"><link rel="prefetch" href="/docs/assets/js/201.f92c0826.js"><link rel="prefetch" href="/docs/assets/js/202.337a2a3a.js"><link rel="prefetch" href="/docs/assets/js/203.45fc8e34.js"><link rel="prefetch" href="/docs/assets/js/204.b7c5c51e.js"><link rel="prefetch" href="/docs/assets/js/205.5818cd77.js"><link rel="prefetch" href="/docs/assets/js/206.a8925824.js"><link rel="prefetch" href="/docs/assets/js/207.f5008095.js"><link rel="prefetch" href="/docs/assets/js/208.8a13c56b.js"><link rel="prefetch" href="/docs/assets/js/209.b21cd054.js"><link rel="prefetch" href="/docs/assets/js/21.0658abb8.js"><link rel="prefetch" href="/docs/assets/js/210.a731fcbd.js"><link rel="prefetch" href="/docs/assets/js/211.b3e2ca64.js"><link rel="prefetch" href="/docs/assets/js/212.4343b22b.js"><link rel="prefetch" href="/docs/assets/js/213.df508ee1.js"><link rel="prefetch" href="/docs/assets/js/214.8f13134f.js"><link rel="prefetch" href="/docs/assets/js/215.ac8a1df9.js"><link rel="prefetch" href="/docs/assets/js/216.3190392d.js"><link rel="prefetch" href="/docs/assets/js/217.9a53a331.js"><link rel="prefetch" href="/docs/assets/js/218.734ed28b.js"><link rel="prefetch" href="/docs/assets/js/219.29558ea8.js"><link rel="prefetch" href="/docs/assets/js/22.54790dac.js"><link rel="prefetch" href="/docs/assets/js/220.e3b54da8.js"><link rel="prefetch" href="/docs/assets/js/221.b859f1f1.js"><link rel="prefetch" href="/docs/assets/js/222.da05c4df.js"><link rel="prefetch" href="/docs/assets/js/223.6e975196.js"><link rel="prefetch" href="/docs/assets/js/224.f966e4f1.js"><link rel="prefetch" href="/docs/assets/js/225.e00384ee.js"><link rel="prefetch" href="/docs/assets/js/226.738f033d.js"><link rel="prefetch" href="/docs/assets/js/227.6457bb60.js"><link rel="prefetch" href="/docs/assets/js/228.98d89bf8.js"><link rel="prefetch" href="/docs/assets/js/229.50325b8a.js"><link rel="prefetch" href="/docs/assets/js/23.dc0c5722.js"><link rel="prefetch" href="/docs/assets/js/230.8305f79c.js"><link rel="prefetch" href="/docs/assets/js/231.235238c1.js"><link rel="prefetch" href="/docs/assets/js/232.e8e39046.js"><link rel="prefetch" href="/docs/assets/js/233.7b3a2c63.js"><link rel="prefetch" href="/docs/assets/js/234.b8719239.js"><link rel="prefetch" href="/docs/assets/js/235.dcacf71e.js"><link rel="prefetch" href="/docs/assets/js/236.09b0b33a.js"><link rel="prefetch" href="/docs/assets/js/237.9aa1fe35.js"><link rel="prefetch" href="/docs/assets/js/238.9aba37ee.js"><link rel="prefetch" href="/docs/assets/js/239.d7f19078.js"><link rel="prefetch" href="/docs/assets/js/24.f2287780.js"><link rel="prefetch" href="/docs/assets/js/240.23e02c5f.js"><link rel="prefetch" href="/docs/assets/js/241.06fd31ed.js"><link rel="prefetch" href="/docs/assets/js/242.d4975f70.js"><link rel="prefetch" href="/docs/assets/js/243.270532cf.js"><link rel="prefetch" href="/docs/assets/js/244.751b73ab.js"><link rel="prefetch" href="/docs/assets/js/245.a58ad64e.js"><link rel="prefetch" href="/docs/assets/js/246.a72ec5f0.js"><link rel="prefetch" href="/docs/assets/js/247.a0f63b0d.js"><link rel="prefetch" href="/docs/assets/js/248.757c56f0.js"><link rel="prefetch" href="/docs/assets/js/249.78cdcccc.js"><link rel="prefetch" href="/docs/assets/js/25.5fed7ab6.js"><link rel="prefetch" href="/docs/assets/js/250.6738035e.js"><link rel="prefetch" href="/docs/assets/js/251.a098be8f.js"><link rel="prefetch" href="/docs/assets/js/252.1f8d0803.js"><link rel="prefetch" href="/docs/assets/js/253.0e255e2d.js"><link rel="prefetch" href="/docs/assets/js/254.7cbcb887.js"><link rel="prefetch" href="/docs/assets/js/255.9e5e9947.js"><link rel="prefetch" href="/docs/assets/js/256.c28cd484.js"><link rel="prefetch" href="/docs/assets/js/257.f210130c.js"><link rel="prefetch" href="/docs/assets/js/258.cdb0f10b.js"><link rel="prefetch" href="/docs/assets/js/259.bc6c670f.js"><link rel="prefetch" href="/docs/assets/js/26.91e32847.js"><link rel="prefetch" href="/docs/assets/js/260.81c5b013.js"><link rel="prefetch" href="/docs/assets/js/261.cd95619f.js"><link rel="prefetch" href="/docs/assets/js/262.ea4dc4c4.js"><link rel="prefetch" href="/docs/assets/js/263.35997384.js"><link rel="prefetch" href="/docs/assets/js/264.8a4c62d0.js"><link rel="prefetch" href="/docs/assets/js/265.a255ac5e.js"><link rel="prefetch" href="/docs/assets/js/266.7aba2bb0.js"><link rel="prefetch" href="/docs/assets/js/267.e002959d.js"><link rel="prefetch" href="/docs/assets/js/268.a8aa8dea.js"><link rel="prefetch" href="/docs/assets/js/269.159e2971.js"><link rel="prefetch" href="/docs/assets/js/27.a5be7aee.js"><link rel="prefetch" href="/docs/assets/js/270.e4d93d87.js"><link rel="prefetch" href="/docs/assets/js/271.30cf523b.js"><link rel="prefetch" href="/docs/assets/js/272.8f7b9e87.js"><link rel="prefetch" href="/docs/assets/js/273.437af003.js"><link rel="prefetch" href="/docs/assets/js/274.2b76000f.js"><link rel="prefetch" href="/docs/assets/js/275.4f6e2ae7.js"><link rel="prefetch" href="/docs/assets/js/276.23a45ec1.js"><link rel="prefetch" href="/docs/assets/js/277.96495a2c.js"><link rel="prefetch" href="/docs/assets/js/278.7681e6b1.js"><link rel="prefetch" href="/docs/assets/js/279.1a1ff129.js"><link rel="prefetch" href="/docs/assets/js/28.72f87125.js"><link rel="prefetch" href="/docs/assets/js/280.5fde0f60.js"><link rel="prefetch" href="/docs/assets/js/281.979d212a.js"><link rel="prefetch" href="/docs/assets/js/282.d4b989d4.js"><link rel="prefetch" href="/docs/assets/js/283.c2c7d3a6.js"><link rel="prefetch" href="/docs/assets/js/284.c67aa032.js"><link rel="prefetch" href="/docs/assets/js/285.b93eafb1.js"><link rel="prefetch" href="/docs/assets/js/286.2972ab24.js"><link rel="prefetch" href="/docs/assets/js/287.40e455fd.js"><link rel="prefetch" href="/docs/assets/js/288.445eed75.js"><link rel="prefetch" href="/docs/assets/js/289.c680b1b5.js"><link rel="prefetch" href="/docs/assets/js/29.aaaf9769.js"><link rel="prefetch" href="/docs/assets/js/290.f4d29ac7.js"><link rel="prefetch" href="/docs/assets/js/291.9cf2bc7b.js"><link rel="prefetch" href="/docs/assets/js/292.af01b9f7.js"><link rel="prefetch" href="/docs/assets/js/293.64eefd6c.js"><link rel="prefetch" href="/docs/assets/js/294.a868ee96.js"><link rel="prefetch" href="/docs/assets/js/295.118b7890.js"><link rel="prefetch" href="/docs/assets/js/296.21a66eb0.js"><link rel="prefetch" href="/docs/assets/js/297.3c4faef1.js"><link rel="prefetch" href="/docs/assets/js/298.998358b2.js"><link rel="prefetch" href="/docs/assets/js/299.af2155a5.js"><link rel="prefetch" href="/docs/assets/js/3.2adef09c.js"><link rel="prefetch" href="/docs/assets/js/30.0ad9d011.js"><link rel="prefetch" href="/docs/assets/js/300.f6ad0a9b.js"><link rel="prefetch" href="/docs/assets/js/301.68e2959f.js"><link rel="prefetch" href="/docs/assets/js/302.2b7a4d95.js"><link rel="prefetch" href="/docs/assets/js/303.876d7a0c.js"><link rel="prefetch" href="/docs/assets/js/304.00098142.js"><link rel="prefetch" href="/docs/assets/js/305.8f5de789.js"><link rel="prefetch" href="/docs/assets/js/306.07bf597a.js"><link rel="prefetch" href="/docs/assets/js/307.c9855286.js"><link rel="prefetch" href="/docs/assets/js/308.f29dd64a.js"><link rel="prefetch" href="/docs/assets/js/309.9a150d03.js"><link rel="prefetch" href="/docs/assets/js/31.910795dd.js"><link rel="prefetch" href="/docs/assets/js/310.4888366e.js"><link rel="prefetch" href="/docs/assets/js/311.5b3c6aed.js"><link rel="prefetch" href="/docs/assets/js/312.7a150454.js"><link rel="prefetch" href="/docs/assets/js/313.1e6d4ee2.js"><link rel="prefetch" href="/docs/assets/js/314.f882be85.js"><link rel="prefetch" href="/docs/assets/js/315.a87b71b2.js"><link rel="prefetch" href="/docs/assets/js/316.24cdc507.js"><link rel="prefetch" href="/docs/assets/js/317.ed7c03fb.js"><link rel="prefetch" href="/docs/assets/js/318.0340a33a.js"><link rel="prefetch" href="/docs/assets/js/319.448ecc60.js"><link rel="prefetch" href="/docs/assets/js/32.2643b16c.js"><link rel="prefetch" href="/docs/assets/js/320.6dc34c63.js"><link rel="prefetch" href="/docs/assets/js/321.ebd6a5c5.js"><link rel="prefetch" href="/docs/assets/js/322.ea9ae054.js"><link rel="prefetch" href="/docs/assets/js/323.d4306d1c.js"><link rel="prefetch" href="/docs/assets/js/324.731fe0fb.js"><link rel="prefetch" href="/docs/assets/js/325.f26cdf8a.js"><link rel="prefetch" href="/docs/assets/js/326.f9a8f865.js"><link rel="prefetch" href="/docs/assets/js/327.c6e9ff14.js"><link rel="prefetch" href="/docs/assets/js/328.a07220ad.js"><link rel="prefetch" href="/docs/assets/js/329.5358218a.js"><link rel="prefetch" href="/docs/assets/js/33.934b3724.js"><link rel="prefetch" href="/docs/assets/js/330.1d3519cc.js"><link rel="prefetch" href="/docs/assets/js/331.58bbbf11.js"><link rel="prefetch" href="/docs/assets/js/332.9cc5fb5e.js"><link rel="prefetch" href="/docs/assets/js/333.90a684e5.js"><link rel="prefetch" href="/docs/assets/js/334.780de00d.js"><link rel="prefetch" href="/docs/assets/js/335.4586387c.js"><link rel="prefetch" href="/docs/assets/js/336.765bb178.js"><link rel="prefetch" href="/docs/assets/js/337.75aeaaca.js"><link rel="prefetch" href="/docs/assets/js/338.f601c8cc.js"><link rel="prefetch" href="/docs/assets/js/339.39b28555.js"><link rel="prefetch" href="/docs/assets/js/34.ce795261.js"><link rel="prefetch" href="/docs/assets/js/340.69cdf746.js"><link rel="prefetch" href="/docs/assets/js/341.4c7b362c.js"><link rel="prefetch" href="/docs/assets/js/342.9df8f39b.js"><link rel="prefetch" href="/docs/assets/js/343.9c3504d0.js"><link rel="prefetch" href="/docs/assets/js/344.450fa488.js"><link rel="prefetch" href="/docs/assets/js/345.d59da24b.js"><link rel="prefetch" href="/docs/assets/js/346.62d130bf.js"><link rel="prefetch" href="/docs/assets/js/347.367bdf4b.js"><link rel="prefetch" href="/docs/assets/js/348.8d611f76.js"><link rel="prefetch" href="/docs/assets/js/349.620f4d88.js"><link rel="prefetch" href="/docs/assets/js/35.b4ca4763.js"><link rel="prefetch" href="/docs/assets/js/350.6e8da176.js"><link rel="prefetch" href="/docs/assets/js/351.174f986a.js"><link rel="prefetch" href="/docs/assets/js/352.cd76f92c.js"><link rel="prefetch" href="/docs/assets/js/353.1f1ed4ea.js"><link rel="prefetch" href="/docs/assets/js/354.8b118a78.js"><link rel="prefetch" href="/docs/assets/js/355.760ab545.js"><link rel="prefetch" href="/docs/assets/js/356.f5701d95.js"><link rel="prefetch" href="/docs/assets/js/357.d68ea3a9.js"><link rel="prefetch" href="/docs/assets/js/358.349be35f.js"><link rel="prefetch" href="/docs/assets/js/359.1dda186b.js"><link rel="prefetch" href="/docs/assets/js/36.23d4fb3f.js"><link rel="prefetch" href="/docs/assets/js/360.ee25bf86.js"><link rel="prefetch" href="/docs/assets/js/361.0d16e528.js"><link rel="prefetch" href="/docs/assets/js/362.ad0dc600.js"><link rel="prefetch" href="/docs/assets/js/363.4622c41e.js"><link rel="prefetch" href="/docs/assets/js/364.6367f1d5.js"><link rel="prefetch" href="/docs/assets/js/365.a4c7f801.js"><link rel="prefetch" href="/docs/assets/js/366.85ce8578.js"><link rel="prefetch" href="/docs/assets/js/367.adb425e9.js"><link rel="prefetch" href="/docs/assets/js/368.788b0abc.js"><link rel="prefetch" href="/docs/assets/js/37.3bebbd80.js"><link rel="prefetch" href="/docs/assets/js/38.9fcd912f.js"><link rel="prefetch" href="/docs/assets/js/39.489dd677.js"><link rel="prefetch" href="/docs/assets/js/4.6d27a4d7.js"><link rel="prefetch" href="/docs/assets/js/40.f792fcd8.js"><link rel="prefetch" href="/docs/assets/js/41.202b7cb1.js"><link rel="prefetch" href="/docs/assets/js/42.831dc71f.js"><link rel="prefetch" href="/docs/assets/js/43.62bdce03.js"><link rel="prefetch" href="/docs/assets/js/44.97fe4437.js"><link rel="prefetch" href="/docs/assets/js/45.0dbebe9e.js"><link rel="prefetch" href="/docs/assets/js/46.6901fc3e.js"><link rel="prefetch" href="/docs/assets/js/47.48417af1.js"><link rel="prefetch" href="/docs/assets/js/48.bfd2d337.js"><link rel="prefetch" href="/docs/assets/js/49.7bffafdb.js"><link rel="prefetch" href="/docs/assets/js/5.3f8add54.js"><link rel="prefetch" href="/docs/assets/js/50.bcddfc42.js"><link rel="prefetch" href="/docs/assets/js/51.b05efe73.js"><link rel="prefetch" href="/docs/assets/js/52.9643828c.js"><link rel="prefetch" href="/docs/assets/js/53.9a1a842f.js"><link rel="prefetch" href="/docs/assets/js/54.6511bd39.js"><link rel="prefetch" href="/docs/assets/js/55.fe79e0ef.js"><link rel="prefetch" href="/docs/assets/js/56.011d602c.js"><link rel="prefetch" href="/docs/assets/js/57.88899fc7.js"><link rel="prefetch" href="/docs/assets/js/58.2d157dba.js"><link rel="prefetch" href="/docs/assets/js/59.73790e3e.js"><link rel="prefetch" href="/docs/assets/js/6.9965f195.js"><link rel="prefetch" href="/docs/assets/js/60.096cf39b.js"><link rel="prefetch" href="/docs/assets/js/61.de254afd.js"><link rel="prefetch" href="/docs/assets/js/62.d62298dd.js"><link rel="prefetch" href="/docs/assets/js/63.726f066a.js"><link rel="prefetch" href="/docs/assets/js/64.708515f3.js"><link rel="prefetch" href="/docs/assets/js/65.c002ad7b.js"><link rel="prefetch" href="/docs/assets/js/66.b601c078.js"><link rel="prefetch" href="/docs/assets/js/67.5ddcc27c.js"><link rel="prefetch" href="/docs/assets/js/68.c0a179f4.js"><link rel="prefetch" href="/docs/assets/js/69.85ec12b9.js"><link rel="prefetch" href="/docs/assets/js/70.340cd6f4.js"><link rel="prefetch" href="/docs/assets/js/71.71686ab3.js"><link rel="prefetch" href="/docs/assets/js/72.a0c091c1.js"><link rel="prefetch" href="/docs/assets/js/73.b9e2c861.js"><link rel="prefetch" href="/docs/assets/js/74.c161aa35.js"><link rel="prefetch" href="/docs/assets/js/75.dacec3db.js"><link rel="prefetch" href="/docs/assets/js/76.1a288b5c.js"><link rel="prefetch" href="/docs/assets/js/77.d259f14b.js"><link rel="prefetch" href="/docs/assets/js/78.a477dba5.js"><link rel="prefetch" href="/docs/assets/js/79.e35c7003.js"><link rel="prefetch" href="/docs/assets/js/8.1fe519c9.js"><link rel="prefetch" href="/docs/assets/js/80.963f1976.js"><link rel="prefetch" href="/docs/assets/js/81.ed2c492e.js"><link rel="prefetch" href="/docs/assets/js/82.92310094.js"><link rel="prefetch" href="/docs/assets/js/83.7192481a.js"><link rel="prefetch" href="/docs/assets/js/84.1b56ffca.js"><link rel="prefetch" href="/docs/assets/js/85.38a3cfc3.js"><link rel="prefetch" href="/docs/assets/js/86.12512fcb.js"><link rel="prefetch" href="/docs/assets/js/87.5cc76acc.js"><link rel="prefetch" href="/docs/assets/js/88.4236f40c.js"><link rel="prefetch" href="/docs/assets/js/89.947fa2b7.js"><link rel="prefetch" href="/docs/assets/js/9.0d3f257e.js"><link rel="prefetch" href="/docs/assets/js/90.95fcf7bb.js"><link rel="prefetch" href="/docs/assets/js/91.4e73014e.js"><link rel="prefetch" href="/docs/assets/js/92.27f33a47.js"><link rel="prefetch" href="/docs/assets/js/93.2e6077ce.js"><link rel="prefetch" href="/docs/assets/js/94.65eaa548.js"><link rel="prefetch" href="/docs/assets/js/95.3868c1ab.js"><link rel="prefetch" href="/docs/assets/js/96.d3644ba5.js"><link rel="prefetch" href="/docs/assets/js/97.663bcd82.js"><link rel="prefetch" href="/docs/assets/js/98.20f3dcd1.js"><link rel="prefetch" href="/docs/assets/js/99.af6df0c8.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.d4eb5ad8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><!----> <span class="site-name">计算机基础教程</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/docs/" class="nav-link">
  机器指令
</a></div><div class="nav-item"><a href="/docs/software/" class="nav-link">
  软件基础
</a></div><div class="nav-item"><a href="/docs/coder2hacker/" class="nav-link">
  白帽黑客
</a></div><div class="nav-item"><a href="/docs/blockchain/" class="nav-link router-link-active">
  区块链
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/docs/" class="nav-link">
  机器指令
</a></div><div class="nav-item"><a href="/docs/software/" class="nav-link">
  软件基础
</a></div><div class="nav-item"><a href="/docs/coder2hacker/" class="nav-link">
  白帽黑客
</a></div><div class="nav-item"><a href="/docs/blockchain/" class="nav-link router-link-active">
  区块链
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/docs/software/" class="sidebar-link">软件基础</a></li><li><a href="/docs/coder2hacker/" class="sidebar-link">黑客入门</a></li><li><a href="/docs/blockchain/" aria-current="page" class="sidebar-link">区块链入门</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="shift-cipher-or-caesar-cipher"><a href="#shift-cipher-or-caesar-cipher" class="header-anchor">#</a> Shift Cipher (or Caesar Cipher)</h2> <p>英文26个字母的位置从0到25构造成Z26</p> <p>Definition 1.4.3 Shift Cipher
Let x,y,k ∈ Z26.
Encryption: ek(x) ≡ x+k mod 26.
Decryption: dk(y) ≡ y−k mod 26.</p> <h2 id="affine-cipher"><a href="#affine-cipher" class="header-anchor">#</a> Affine Cipher</h2> <p>Now, we try to improve the shift cipher by generalizing the encryption function.
Recall that the actual encryption of the shift cipher was the addition of the key
yi = xi +k mod 26. The affine cipher encrypts by multiplying the plaintext by one
part of the key followed by addition of another part of the key.</p> <p>Definition 1.4.4 Affine Cipher
Let x,y,a,b ∈ Z26
Encryption: ek(x) = y ≡ a · x+b mod 26.
Decryption: dk(y) = x ≡ a−1 · (y−b) mod 26.
with the key: k = (a,b), which has the restriction: gcd(a,26) = 1.</p> <h2 id="stream-ciphers"><a href="#stream-ciphers" class="header-anchor">#</a> Stream Ciphers</h2> <p>Definition 2.1.1 Stream Cipher Encryption and Decryption
The plaintext, the ciphertext and the key stream consist of individual
bits,
i.e., xi,yi, si ∈ {0,1}.
Encryption: yi = esi (xi) ≡ xi+si mod 2.
Decryption: xi = dsi (yi) ≡ yi+si mod 2.</p> <p>Why Are Encryption and Decryption the Same Function?</p> <p>The reason for the similarity of the encryption and decryption function can easily
be shown. We must prove that the decryption function actually produces the plaintext
bit xi again. We know that ciphertext bit yi was computed using the encryption
function yi ≡ xi +si mod 2. We insert this encryption expression in the decryption
function:
dsi (yi) ≡ yi+si mod 2
≡ (xi+si)+si mod 2
≡ xi+si+si mod 2
≡ xi+2si mod 2
≡ xi+0 mod 2
≡ xi mod 2 Q.E.D.
The trick here is that the expression (2 si mod 2) has always the value zero since
2 ≡ 0 mod 2. Another way of understanding this is as follows: If si has either the
value 0, in which case 2si = 2 · 0 ≡ 0 mod 2. If si = 1, we have 2si = 2 · 1 = 2 ≡
0 mod 2.</p> <p>As we saw in the previous section, the actual encryption and decryption of stream
ciphers is extremely simple. The security of stream ciphers hinges entirely on a
“suitable” key stream s0, s1, s2, . . .. Since randomness plays a major role, we will first
learn about the three types of random number generators (RNG) that are important
for us.</p> <p>True Random Number Generators (TRNG)
True random number generators (TRNGs) are characterized by the fact that their
output cannot be reproduced. For instance, if we flip a coin 100 times and record the
resulting sequence of 100 bits, it will be virtually impossible for anyone on Earth
to generate the same 100 bit sequence. The chance of success is 1/2100, which is
an extremely small probability. TRNGs are based on physical processes. Examples
include coin flipping, rolling of dice, semiconductor noise, clock jitter in digital
circuits and radioactive decay. In cryptography, TRNGs are often needed for generating
session keys, which are then distributed between Alice and Bob, and for other
purposes.</p> <p>(General) Pseudorandom Number Generators (PRNG)
Pseudorandom number generators (PRNGs) generate sequences which are computed
from an initial seed value. Often they are computed recursively in the following
way:
s0 = seed
si+1 = f (si), i = 0,1, . . .
A generalization of this are generators of the form si+1 = f (si, si−1, . . . , si−t ), where
t is a fixed integer. A popular example is the linear congruential generator:
s0 = seed
si+1 ≡ asi+b mod m, i = 0,1, . . .
where a, b, m are integer constants. Note that PRNGs are not random in a true sense
because they can be computed and are thus completely deterministic. A widely used
example is the rand() function used in ANSI C. It has the parameters:
s0 = 12345
si+1 ≡ 1103515245si+12345 mod 231, i = 0,1, . . .
A common requirement of PRNGs is that they possess good statistical properties,
meaning their output approximates a sequence of true random numbers. There
are many mathematical tests, e.g., the chi-square test, which can verify the statistical
behavior of PRNG sequences. Note that there are many, many applications for pseudorandom
numbers outside cryptography. For instance, many types of simulations
or testing, e.g., of software or of VLSI chips, need random data as input. That is the
reason why a PRNG is included in the ANSI C specification.</p> <p>Cryptographically Secure Pseudorandom Number Generators (CSPRNG)
Cryptographically secure pseudorandom number generators (CSPRNGs) are a special
type of PRNG which possess the following additional property: A CSPRNG is
PRNG which is unpredictable. Informally, this means that given n output bits of the
key stream si, si+1, . . . , si+n−1, where n is some integer, it is computationally infeasible
to compute the subsequent bits si+n, si+n+1, . . .. A more exact definition is that
given n consecutive bits of the key stream, there is no polynomial time algorithm
that can predict the next bit sn+1 with better than 50% chance of success. Another
property of CSPRNG is that given the above sequence, it should be computationally
infeasible to compute any preceding bits si−1, si−2, . . ..
Note that the need for unpredictability of CSPRNGs is unique to cryptography.
In virtually all other situations where pseudorandom numbers are needed in computer
science or engineering, unpredictability is not needed. As a consequence, the
distinction between PRNG and CSPRN and their relevance for stream ciphers is often
not clear to non-cryptographers. Almost all PRNG that were designed without
the clear purpose of being stream ciphers are not CSPRNGs.</p> <h2 id="des-the-data-encryption-standard-des-and"><a href="#des-the-data-encryption-standard-des-and" class="header-anchor">#</a> DES The Data Encryption Standard (DES) and</h2> <p>Alternatives</p> <ol><li>Confusion is an encryption operation where the relationship between key and
ciphertext is obscured. Today, a common element for achieving confusion is substitution,
which is found in both DES and AES.</li> <li>Diffusion is an encryption operation where the influence of one plaintext symbol
is spread over many ciphertext symbols with the goal of hiding statistical properties
of the plaintext. A simple diffusion element is the bit permutation, which is
used frequently within DES. AES uses the more advanced Mixcolumn operation.</li></ol> <p>DES is a cipher which encrypts blocks of length of 64 bits with a key of size of 56
bits</p> <p>Alternatives：</p> <p>AES,</p> <p>Triple DES (3DES) and DESX,</p> <p>Lightweight Cipher PRESENT</p> <h2 id="the-advanced-encryption-standard-aes"><a href="#the-advanced-encryption-standard-aes" class="header-anchor">#</a> The Advanced Encryption Standard (AES)</h2> <p>The Advanced Encryption Standard (AES) is the most widely used symmetric cipher
today. Even though the term “Standard” in its name only refers to US government
applications, the AES block cipher is also mandatory in several industry standards
and is used in many commercial systems. Among the commercial standards that
include AES are the Internet security standard IPsec, TLS, the Wi-Fi encryption
standard IEEE 802.11i, the secure shell network protocol SSH (Secure Shell), the
Internet phone Skype and numerous security products around the world. To date,
there are no attacks better than brute-force known against AES.</p> <p>The AES cipher is almost identical to the block cipher Rijndael. The Rijndael block
and key size vary between 128, 192 and 256 bits. However, the AES standard only
calls for a block size of 128 bits. Hence, only Rijndael with a block length of 128
bits is known as the AES algorithm.</p> <p>In contrast to DES, AES does not have a Feistel structure. Feistel networks do
not encrypt an entire block per iteration, e.g., in DES, 64/2 = 32 bits are encrypted</p> <p>in one round. AES, on the other hand, encrypts all 128 bits in one iteration. This is
one reason why it has a comparably small number of rounds.</p> <p>AES consists of so-called layers. Each layer manipulates all 128 bits of the data
path. The data path is also referred to as the state of the algorithm. There are only
three different types of layers. Each round, with the exception of the first, consists
of all three layers, Moreover, the last round nr does not make
use of the MixColumn transformation, which makes the encryption and decryption
scheme symmetric.</p> <p>Key Addition layer A 128-bit round key, or subkey, which has been derived from
the main key in the key schedule, is XORed to the state.
Byte Substitution layer (S-Box) Each element of the state is nonlinearly transformed
using lookup tables with special mathematical properties. This introduces
confusion to the data, i.e., it assures that changes in individual state bits propagate
quickly across the data path.
Diffusion layer It provides diffusion over all state bits. It consists of two sublayers,
both of which perform linear operations:
 The ShiftRows layer permutes the data on a byte level.
 The MixColumn layer is a matrix operation which combines (mixes) blocks of
four bytes.</p> <p><strong>Galois field computations are needed for all operations within the AES layers.</strong></p> <h3 id="extension-fields-gf-2m"><a href="#extension-fields-gf-2m" class="header-anchor">#</a> Extension Fields GF(2<sup>m</sup>)</h3> <p>GF(2) addition, i.e., modulo 2 addition,
is equivalent to an XOR gate. What we learn from the example above is that GF(2)
multiplication is equivalent to the logical AND gate. The field GF(2) is important
for AES.</p> <p>In AES the finite field contains 256 elements and is denoted as GF(2<sup>8</sup>). This field
was chosen because each of the field elements can be represented by one byte. For
the S-Box and MixColumn transforms, AES treats every byte of the internal data</p> <p>path as an element of the field GF(2<sup>8</sup>) and manipulates the data by performing
arithmetic in this finite field.
However, if the order of a finite field is not prime, and 28 is clearly not a prime,
the addition and multiplication operation cannot be represented by addition and multiplication of integers modulo 2<sup>8</sup>(解释：从fields一章的结论 <strong>Characteristic of a Field Ch(F) can only be zero or prime, ch(F)= 0 or prime(2,3,5....)</strong>，所以order为256明显不是finite fields ). Such fields with m &gt; 1 are called extension fields.
In order to deal with extension fields we need (1) a different notation for field elements
and (2) different rules for performing arithmetic with the elements. We will
see in the following that elements of extension fields can be represented as polynomials,
and that computation in the extension field is achieved by performing a
certain type of polynomial arithmetic.
In extension fields GF(2<sup>m</sup>) elements are not represented as integers but as polynomials
with coefficients in GF(2). The polynomials have a maximum degree of
m−1, so that there are m coefficients in total for every element. In the field GF(2<sup>8</sup>),
which is used in AES, each element A ∈ GF(2<sup>8</sup>) is thus represented as:
A(x) = a7x<sup>7</sup>+· · ·+a1x+a0, ai ∈ GF(2) = {0,1}.
Note that there are exactly 256 = 28 such polynomials. The set of these 256 polynomials
is the finite field GF(28). It is also important to observe that every polynomial
can simply be stored in digital form as an 8-bit vector
A = (a7,a6,a5,a4,a3,a2,a1,a0).
In particular, we do not have to store the factors x<sup>7</sup>, x<sup>6</sup>, etc. It is clear from the bit
positions to which power xi each coefficient belongs.</p> <h4 id="addition-and-subtraction-in-gf-2m"><a href="#addition-and-subtraction-in-gf-2m" class="header-anchor">#</a> Addition and Subtraction in GF(2<sup>m</sup>):</h4> <p>Let’s now look at addition and subtraction in extension fields. The key addition layer
of AES uses addition. It turns out that these operations are straightforward. They are
simply achieved by performing standard polynomial addition and subtraction: We
merely add or subtract coefficients with equal powers of x. The coefficient additions
or subtractions are done in the underlying field GF(2).</p> <p>Definition 4.3.3 Extension field addition and subtraction
Let A(x),B(x) ∈ GF(2m). The sum of the two elements is then computed
according to:
C(x) = A(x)+B(x) =
$$
\sum_{i=0}^{m-1} c_ix^j \quad
$$</p> <p>, ci ≡ ai+bi mod 2
and the difference is computed according to:
C(x) = A(x)−B(x) =
$$
\sum_{i=0}^{m-1} c_ix^j \quad
$$</p> <p>, ci ≡ ai−bi ≡ ai+bi mod 2.</p> <p>Example 4.5. Here is how the sumC(x)=A(x)+B(x) of two elements from GF(28)
is computed:
A(x) =x7+ x6+ x4+ 1
B(x) = x4+ x2+ 1
C(x) = x7+ x6+ x2</p> <h4 id="multiplication-in-gf-2m"><a href="#multiplication-in-gf-2m" class="header-anchor">#</a> Multiplication in GF(2<sup>m</sup>)</h4> <p>Multiplication in GF(2<sup>8</sup>) is the core operation of the MixColumn transformation of
AES. In a first step, two elements (represented by their polynomials) of a finite field
GF(2<sup>m</sup>) are multiplied using the standard polynomial multiplication rule:
$$
A(x) ·B(x) = (a_{m−1}x^{m−1}+· · ·+a_0) · (b_{m−1}x^{m−1}+· · ·+b_0)
$$</p> <p>$$
C'(x) = c'_{2m−2}x^{2m−2}+· · ·+c'_0,
$$</p> <p>where:
c'<sub>0</sub> = a<sub>0</sub>b<sub>0</sub> mod 2
c'<sub>1</sub> = a<sub>0</sub>b<sub>1</sub>+a<sub>1</sub>b<sub>0</sub> mod 2
...
c'<sub>2m−2</sub> = a<sub>m−1</sub>b<sub>m−1</sub> mod 2.</p> <p>Note that all coefficients ai, bi and ci are elements of GF(2), and that coefficient
arithmetic is performed in GF(2). In general, the product polynomial C(x)
will have a degree higher than m−1 and has to be reduced. The basic idea is an approach
similar to the case of multiplication in prime fields: in GF(p), we multiply
the two integers, divide the result by a prime, and consider only the remainder. Here
is what we are doing in extension fields: The product of the multiplication is divided
by a certain polynomial, and we consider only the remainder after the polynomial
division.We need irreducible polynomials for the module reduction.</p> <p>Definition 4.3.4 Extension field multiplication
Let A(x),B(x) ∈ GF(2<sup>m</sup>) and let
P(x) ≡
$$
\sum_{i=0}^m p_ix^i \quad
$$</p> <p>, pi ∈ GF(2)
be an irreducible polynomial. Multiplication of the two elements A(x),B(x) is performed as C(x) ≡ A(x) ·B(x) mod P(x).</p> <p>Thus, every field GF(2<sup>m</sup>) requires an irreducible polynomial P(x) of degree m with coefficients from GF(2). Note that not all polynomials are irreducible. For example, the polynomial x<sup>4</sup>+x<sup>3</sup>+x+1 is reducible since
x<sup>4</sup>+x<sup>3</sup>+x+1 = (x<sup>2</sup>+x+1)(x<sup>2</sup>+1)</p> <p>and hence cannot be used to construct the extension field GF(2<sup>4</sup>). Since primitive
polynomials are a special type of irreducible polynomial. For AES, the irreducible polynomial
P(x) = x<sup>8</sup>+x<sup>4</sup>+x<sup>3</sup>+x+1
is used. It is part of the AES specification.</p> <p>Example 4.6. We want to multiply the two polynomials A(x) = x<sup>3</sup> + x<sup>2</sup> + 1 and
B(x) = x<sup>2</sup>+x in the field GF(24). The irreducible polynomial of this Galois field is
given as
P(x) = x<sup>4</sup>+x+1.
The plain polynomial product is computed as:
C(x) = A(x) ·B(x) = x<sup>5</sup>+x<sup>3</sup>+x<sup>2</sup>+x.
We can now reduce C(x) using the polynomial division method we learned in
school. However, sometimes it is easier to reduce each of the leading terms x<sup>4</sup> and</p> <p>x<sup>5</sup> individually:
x<sup>4</sup> = 1 ·P(x)+(x+1)
x<sup>4</sup> ≡ x+1 mod P(x)
x<sup>5</sup> ≡ x<sup>2</sup>+x mod P(x).
Now, we only have to insert the reduced expression for x<sup>5</sup> into the intermediate
result C(x):
C(x) ≡ x<sup>5</sup>+x<sup>3</sup>+x<sup>2</sup>+x mod P(x)
C(x) ≡ (x<sup>2</sup>+x)+(x<sup>3</sup>+x<sup>2</sup>+x) = x<sup>3</sup>
A(x) ·B(x) ≡ x<sup>3</sup>.</p> <p>It is important not to confuse multiplication in GF(2<sup>m</sup>) with integer multiplication,
especially if we are concerned with software implementations of Galois fields.
Recall that the polynomials, i.e., the field elements, are normally stored as bit vectors
in the computers. If we look at the multiplication from the previous example,
the following very atypical operation is being performed on the bit level:
A 				  · 		B 			= C
(x<sup>3</sup>+x<sup>2</sup>+1) 	· 		(x<sup>2</sup>+x) 	= x<sup>3</sup>
(1 1 0 1) 	  · 		(0 1 1 0) = (1 0 0 0).
This computation is not identical to integer arithmetic. If the polynomials are interpreted
as integers, i.e., (1101)<sub>2</sub> = 13<sub>10</sub> and (0110)<sub>2</sub> = 6<sub>10</sub>, the result would have
been (1001110)<sub>2</sub> = 78<sub>10</sub>, which is clearly not the same as the Galois field multiplication
product. Hence, even though we can represent field elements as integers data
types, we cannot make use of the integer arithmetic provided</p> <h4 id="inversion-in-gf-2m"><a href="#inversion-in-gf-2m" class="header-anchor">#</a> Inversion in GF(2<sup>m</sup>)</h4> <p>Inversion in GF(2<sup>8</sup>) is the core operation of the Byte Substitution transformation,
which contains the AES S-Boxes. For a given finite field GF(2<sup>m</sup>) and the corresponding
irreducible reduction polynomial P(x), the inverse A<sup>−1</sup> of a nonzero element
A ∈ GF(2<sup>m</sup>) is defined as:
A<sup>−1</sup>(x) ·A(x) =1 mod P(x).
For small fields — in practice this often means fields with 2<sup>16</sup> or fewer elements
— lookup tables which contain the precomputed inverses of all field elements are
often used.</p> <p>P(x) = x<sup>8</sup> +x<sup>4</sup> +x<sup>3</sup> +x+1</p> <p>(x<sup>7</sup>+x<sup>6</sup>+x) · (x<sup>5</sup>+x<sup>3</sup>+x<sup>2</sup>+x+1) ≡1 mod P(x).</p> <h2 id="public-key-cryptography-asymmetric-cryptography"><a href="#public-key-cryptography-asymmetric-cryptography" class="header-anchor">#</a> public-key cryptography==asymmetric cryptography</h2> <h3 id="intro"><a href="#intro" class="header-anchor">#</a> Intro</h3> <p>Modern symmetric algorithms such as AES or 3DES are very secure, fast and
are in widespread use. However, there are several shortcomings associated with
symmetric-key schemes, as discussed below:</p> <ul><li><p>Key Distribution Problem</p> <p>The key must be established between Alice and Bob
using a secure channel. Remember that the communication link for the message is
not secure, so sending the key over the channel directly—which would be the most
convenient way of transporting it— can’t be done.</p></li> <li><p>Number of Keys</p> <p>Even if we solve the key distribution problem, we must potentially
deal with a very large number of keys. If each pair of users needs a separate
pair of keys in a network with n users, there are n(n−1)/2 key pairs, and every user has to store n−1 keys securely. Even for mid-size networks,
say, a corporation with 2000 people, this requires more than 4 million key
pairs that must be generated and transported via secure channels.</p></li> <li><p>nonrepudiation/No Protection Against Cheating by Alice or Bob</p> <p>Alice and Bob have the same
capabilities, since they possess the same key. As a consequence, symmetric cryptography
cannot be used for applications where we would like to prevent cheating by
either Alice or Bob as opposed to cheating by an outsider like Oscar. For instance,
in e-commerce applications it is often important to prove that Alice actually sent a
certain message, say, an online order for a flat screen TV. If we only use symmetric
cryptography and Alice changes her mind later, she can always claim that Bob,
the vendor, has falsely generated the electronic purchase order. Preventing this is
called nonrepudiation and can be achieved with asymmetric cryptography</p></li></ul> <p>In order to overcome these drawbacks, Diffie, Hellman and Merkle had a revolutionary
proposal based on the following idea: It is not necessary that the key possessed
by the person who encrypts the message (that’s Alice in our example) is secret. The
crucial part is that Bob, the receiver, can only decrypt using a secret key. In order
to realize such a system, Bob publishes a public encryption key which is known to
everyone. Bob also has a matching secret key, which is used for decryption. Thus,
Bob’s key k consists of two parts, a public part, kpub, and a private one, kpr.</p> <p>Definition 6.1.1 One-way function
A function f () is a one-way function if:</p> <ol><li>y = f (x) is computationally easy, and</li> <li>x = f −1(y) is computationally infeasible.</li></ol> <p>Main Security Mechanisms of Public-Key Algorithms:</p> <ul><li><p>Key Establishment</p> <p>There are protocols for establishing secret keys over
an insecure channel. Examples for such protocols include the Diffie–
Hellman key exchange (DHKE) or RSA key transport protocols.</p></li> <li><p>Nonrepudiation</p> <p>Providing nonrepudiation and message integrity can be
realized with digital signature algorithms, e.g., RSA, DSA or ECDSA.</p></li> <li><p>Identification</p> <p>We can identify entities using challenge-and-response protocols
together with digital signatures, e.g., in applications such as smart
cards for banking or for mobile phones.</p></li> <li><p>Encryption</p> <p>We can encrypt messages using algorithms such as RSA or
Elgamal.</p></li></ul> <p>We note that identification and encryption can also be achieved with symmetric
ciphers, but they typically require much more effort with key management. It looks
as though public-key schemes can provide all functions required by modern security
protocols. Even though this is true, the major drawback in practice is that encryption
of data is very computationally intensive—or more colloquially: extremely slow—
with public-key algorithms. Many block and stream ciphers can encrypt about one
hundred to one thousand times faster than public-key algorithms. Thus, somewhat
ironically, public-key cryptography is rarely used for the actual encryption of data.
On the other hand, symmetric algorithms are poor at providing nonrepudiation and
key establishment functionality. In order to use the best of both worlds, most practical
protocols are hybrid protocols which incorporate both symmetric and public-key
algorithms. Examples include the SSL/TLS potocol that is commonly used for secure
Web connections, or IPsec, the security part of the Internet communication
protocol.</p> <p>Public-Key Algorithm Families of Practical Relevance</p> <ul><li><p>Integer-Factorization Schemes</p> <p>Several public-key schemes are based on
the fact that it is difficult to factor large integers. The most prominent representative
of this algorithm family is RSA.</p></li> <li><p>Discrete Logarithm Schemes</p> <p>There are several algorithms which are
based on what is known as the discrete logarithm problem in finite fields.
The most prominent examples include the Diffie–Hellman key exchange,
Elgamal encryption or the Digital Signature Algorithm (DSA).</p></li> <li><p>Elliptic Curve (EC) Schemes</p> <p>A generalization of the discrete logarithm
algorithm are elliptic curve public-key schemes. The most popular examples
include Elliptic Curve Diffie–Hellman key exchange (ECDH) and the
Elliptic Curve Digital Signature Algorithm (ECDSA).</p></li></ul> <p>important mathematics theorem for asymmetric algorithms, especially for understanding the RSA crypto scheme:</p> <p>the Euclidean algorithm, Euler’s phi function as well as Fermat’s Little Theorem and Euler’s theorem.</p> <h3 id="euclidean-algorithm"><a href="#euclidean-algorithm" class="header-anchor">#</a> Euclidean algorithm</h3> <p>refer to <a href="/docs/blockchain/cryptography/algebra_0_modular_arithmetic">algebra_0_modular_arithmetic.md</a></p> <h3 id="euler-s-phi-function"><a href="#euler-s-phi-function" class="header-anchor">#</a> Euler’s Phi Function</h3> <p>We now look at another tool that is useful for public-key cryptosystems, especially for RSA. We consider the ring Zm, i.e., the set of integers {0,1, . . . ,m−1}. We are interested in the (at the moment seemingly odd) problem of knowing how many numbers in this set are relatively prime to m. This quantity is given by Euler’s phi function, which is defined as follows:</p> <p>Definition 6.3.1 Euler’s Phi Function
The number of integers in Zm relatively prime to m is denoted by Φ(m).</p> <p>Example 6.8. Let m = 6. The associated set is Z6 = {0,1,2,3,4,5}.
gcd(0,6) = 6
gcd(1,6) = 1 *
gcd(2,6) = 2
gcd(3,6) = 3
gcd(4,6) = 2
gcd(5,6) = 1 *
Since there are two numbers in the set which are relatively prime to 6, namely 1 and
5, the phi function takes the value 2, i.e., Φ(6) = 2.</p> <p>Here is another example:
Example 6.9. Let m = 5. The associated set is Z5 = {0,1,2,3,4}.
gcd(0,5) = 5
gcd(1,5) = 1 *
gcd(2,5) = 1 *
gcd(3,5) = 1 *
gcd(4,5) = 1 *
This time we have four numbers which are relatively prime to 5, hence, Φ(5) = 4.</p> <p>From the examples above we can guess that calculating Euler’s phi function by
running through all elements and computing the gcd is extremely slow if the numbers
are large. In fact, computing Euler’s phi function in this na¨ıve way is completely
out of reach for the large numbers occurring in public-key cryptography.
Fortunately, there exists a relation to calculate it much more easily if we know the
factorization of m, which is given in following theorem</p> <p>Theorem 6.3.1 Let m have the following canonical factorization</p> <p>m = p<sub>1</sub><sup>e1</sup>·  p<sub>2</sub><sup>e2</sup>· . . . ·  p<sub>n</sub><sup>en</sup> ,
where the pi are distinct prime numbers and ei are positive integers, then</p> <p>$$
Φ(m) =\prod_{i=1}^n {(p_i^{e_i}-p_i^{e_i-1})}
$$</p> <p>Since the value of n, i.e., the number of distinct prime factors, is always quite small
even for large numbers m, evaluating the product symbol Π is computationally easy.
Let’s look at an example where we calculate Euler’s phi function using the relation:</p> <p>Example 6.10. Let m = 240. The factorization of 240 in the canonical factorization form is
m = 240 = 16 · 15 = 2<sup>4</sup> · 3 · 5 = p<sub>1</sub><sup>e1</sup>· p<sub>2</sub><sup>e2</sup>· p<sub>3</sub><sup>e3</sup>
There are three distinct prime factors, i.e., n = 3. The value for Euler’s phi functions follows then as:
Φ(m) = (2<sup>4</sup>−2<sup>3</sup>)(3<sup>1</sup>−3<sup>0</sup>)(5<sup>1</sup>−5<sup>0</sup>) = 8 · 2 · 4 = 64.
That means that 64 integers in the range {0,1, . . . ,239} are coprime to m = 240.
The alternative method, which would have required to evaluate the gcd 240 times,
would have been much slower even for this small number.</p> <p>It is important to stress that we need to know the factorization of m in order to
calculate Euler’s phi function quickly in this manner. As we will see in the next
chapter, this property is at the heart of the RSA public-key scheme: Conversely, if
we know the factorization of a certain number, we can compute Euler’s phi function
and decrypt the ciphertext. If we do not know the factorization, we cannot compute
the phi function and, hence, cannot decrypt.</p> <h3 id="fermat-s-little-theorem-and-euler-s-theorem"><a href="#fermat-s-little-theorem-and-euler-s-theorem" class="header-anchor">#</a> Fermat’s Little Theorem and Euler’s Theorem</h3> <p>Fermat’s Little Theorem is helpful for primality testing and in many other aspects of public-key cryptography. The theorem gives a seemingly surprising result if we do exponentiations modulo an integer.</p> <h5 id="theorem-6-3-2-fermat-s-little-theorem"><a href="#theorem-6-3-2-fermat-s-little-theorem" class="header-anchor">#</a> Theorem 6.3.2 Fermat’s Little Theorem</h5> <p>Let a be an integer and p be a prime, then:
a<sup>p</sup> ≡ a (mod p).</p> <p>We note that arithmetic in finite fields GF(p) is done modulo p, and hence, the theorem holds for all integers a which are elements of a finite field GF(p). The theorem can be stated in the form:
a<sup>p-1</sup> ≡ 1 (mod p)</p> <p>which is often useful in cryptography. One application is the computation of the inverse in a finite field. We can rewrite the equation as a · a<sup>p−2</sup> ≡ 1 (mod p). This is exactly the definition of the multiplicative inverse. Thus, we immediately have a
way for inverting an integer a modulo a prime:
a<sup>−1</sup> ≡ a<sup>p−2</sup> (mod p)</p> <p>We note that this inversion method holds only if p is a prime. Let’s look at an example:
Example 6.11. Let p = 7 and a = 2. We can compute the inverse of a as:
a<sup>p−2</sup> = 2<sup>5</sup> = 32 ≡4 mod7.
This is easy to verify: 2 · 4 ≡ 1 mod 7.</p> <p><strong>Fermat’s Little Theorem vs EEA - extended Euclidean algorithm:</strong></p> <p>r0=p, ,r1=a ,gcd(r0,r1)=1</p> <p>sr0+tr1=1</p> <p>=&gt; sp+ta = 1 =&gt; 两边mod p，s0+ta ≡ 1 (mod p) =&gt; ta ≡ 1 (mod p) 根据EEA的算法得出的t肯定是a<sup>p−2</sup></p> <p>Performing the exponentiation is usually slower than using the <strong>extended Euclidean algorithm</strong>. However, there are situations where it is advantageous to use Fermat’s Little Theorem, e.g., on smart cards or other devices which have a hardware accelerator for fast exponentiation anyway. This is not uncommon because many public-key algorithms require exponentiation, as we will see in subsequent chapters.
A generalization of Fermat’s Little Theorem to any integer moduli, i.e., moduli that are not necessarily primes, is Euler’s theorem.</p> <h5 id="theorem-6-3-3-euler-s-theorem"><a href="#theorem-6-3-3-euler-s-theorem" class="header-anchor">#</a> Theorem 6.3.3 Euler’s Theorem</h5> <p>Let a and m be integers with gcd(a,m) = 1, then:
a<sup>Φ(m)</sup> ≡ 1 (mod m).</p> <p>Since it works modulo m, it is applicable to integer rings Zm. We show now an example for Euler’s theorem with small values.
Example 6.12. Let m = 12 and a = 5. First, we compute Euler’s phi function of m:</p> <p>Φ(12) =Φ(2<sup>2</sup> · 3) = (2<sup>2</sup>−2<sup>1</sup>)(3<sup>1</sup>−3<sup>0</sup>) = (4−2)(3−1) = 4.
Now we can verify Euler’s theorem:
5<sup>Φ(12)</sup> = 5<sup>4</sup> = 25<sup>2</sup> = 625 ≡ 1 mod 12.</p> <p>It is easy to show that Fermat’s Little Theorem is a special case of Euler’s theorem:
If p is a prime, it holds that Φ(p) = (p<sup>1</sup> − p<sup>0</sup>) = p−1. If we use this value for Euler’s theorem, we obtain:</p> <p>a<sup>Φ(p)</sup> = a<sup>p−1</sup> ≡ 1 (mod p), which is exactly Fermat’s Little Theorem.</p> <p><strong>Euler’s Theorem vs EEA - extended Euclidean algorithm:</strong></p> <p>r0=m, ,r1=a ,gcd(r0,r1)=1</p> <p>sr0+tr1=1</p> <p>=&gt; sm+ta = 1 =&gt; 两边mod m，s0+ta ≡ 1 (mod m) =&gt; ta ≡ 1 (mod m) 根据EEA的算法得出的t肯定是a<sup>Φ(m)-1</sup></p> <h3 id="rsa"><a href="#rsa" class="header-anchor">#</a> RSA</h3> <p>RSA专题——模数分解 https://mp.weixin.qq.com/s/sNEyaJ6qioIMdsJxZ3Hccw</p> <p>RSA专题——参数误用 https://mp.weixin.qq.com/s/oicoXceIeqOWEvcJECbkWg</p> <p>refer to draw.io &lt;<cryptography-encryption>&gt; https://app.diagrams.net/#G1l7hGpTWy3dLPROAwXYOAuClDMiugzqNL</cryptography-encryption></p> <p>Mathematical Attacks
The best mathematical cryptanalytical method we know is factoring the modulus. An attacker, Oscar, knows the modulus n, the public key e and the ciphertext y. His goal is to compute the private key d which has the property that e · d ≡ modΦ(n).
<strong>It seems that he could simply apply the extended Euclidean algorithm and compute d. However, he does not know the value of Φ(n). At this point factoring comes in: the best way to obtain this value is to decompose n into its primes p and q.</strong> If Oscar can do this, the attack succeeds in three steps:
Φ(n) = (p−1)(q−1)
d<sup>−1</sup> ≡ e mod Φ(n)
x ≡ y<sup>d</sup> mod n.
In order to prevent this attack, the modulus must be sufficiently large. This is the sole reason why moduli of 1024 or more bit are needed for a RSA.</p> <h3 id="public-key-cryptosystems-based-on-the-discrete-logarithm-problem"><a href="#public-key-cryptosystems-based-on-the-discrete-logarithm-problem" class="header-anchor">#</a> Public-Key Cryptosystems Based on the Discrete Logarithm Problem</h3> <p>In the previous chapter we learned about the RSA public-key scheme. As we have seen, RSA is based on the hardness of factoring large integers. The integer factorization problem is said to be the one-way function of RSA. As we saw earlier, roughly speaking a function is one-way if it is computationally easy to compute the function f (x) = y, but computationally infeasible to invert the function: f <sup>−1</sup>(y) = x. The question is whether we can find other one-way functions for building asymmetric crypto schemes. It turns out that most non-RSA public-key algorithms with practical relevance are based on another one-way function, the discrete logarithm problem.</p> <p>The discrete logarithm problem is defined in what are called <strong>cyclic groups</strong>.</p> <h4 id="diffie-hellman-key-exchange"><a href="#diffie-hellman-key-exchange" class="header-anchor">#</a> Diffie–Hellman Key Exchange</h4> <p>This fundamental key agreement technique is implemented in many open and commercial cryptographic protocols like
Secure Shell (SSH), Transport Layer Security (TLS), and Internet Protocol Security (IPSec).The basic idea behind the DHKE is that exponentiation in Z<sup>∗</sup><sub>p</sub>, p prime, is aone-way function and that exponentiation is commutative, i.e.,
k = (α<sup>x</sup>)<sup>y</sup> ≡ (α<sup>y</sup>)<sup>x</sup> mod p
The value k ≡ (α<sup>x</sup>)<sup>y</sup> ≡ (α<sup>y</sup>)<sup>x</sup> mod p is the joint secret which can be used as the session key between the two parties.</p> <p>classic Diffie–Hellman key exchange protocol is in the group Z<sup>∗</sup><sub>p</sub>, where p is a prime. The protocol can be generalized, in particular to groups of elliptic curves. This gives rise to elliptic curve cryptography, which has become a very popular asymmetric scheme in practice. In order to better understand elliptic curves and schemes such as Elgamal encryption, which are also closely related
to the DHKE, we introduce the discrete logarithm problem in the following sections.</p> <h4 id="the-discrete-logarithm-problem-in-prime-fields"><a href="#the-discrete-logarithm-problem-in-prime-fields" class="header-anchor">#</a> The Discrete Logarithm Problem in Prime Fields</h4> <p>Definition 8.3.1 Discrete Logarithm Problem (DLP) in Z<sub>p</sub><sup>*</sup></p> <p>Given is the finite cyclic group  Z<sub>p</sub><sup>*</sup> of order p−1 and a primitive element</p> <p>α ∈  Z<sub>p</sub><sup>*</sup></p> <p>and another element β ∈  Z<sub>p</sub><sup>*</sup>.</p> <p>The DLP is the problem of determining the integer 1 ≤ x ≤ p−1 such that: α<sup>x</sup> ≡β mod p</p> <p>such an integer x must exist since α is a primitive element and each group element can be expressed as a power of any primitive
element. This integer x is called the discrete logarithm of β to the base α, and we can formally write:
x = log<sub>α</sub><sup>β</sup> mod p.
Computing discrete logarithms modulo a prime is a very hard problem if the parameters are sufficiently large. Since exponentiation α<sup>x</sup> ≡β mod p is computationally easy, this forms a one-way function.</p> <p>Example 8.11. We consider a discrete logarithm in the group Z<sub>47</sub><sup>*</sup>, in which α = 5 is a primitive element. For β = 41 the discrete logarithm problem is: Find the positive integer x such that 5<sup>x</sup> ≡ 41 mod 47
Even for such small numbers, determining x is not entirely straightforward. By using a brute-force attack, i.e., systematically trying all possible values for x, we obtain the solution x = 15.</p> <p>In practice, it is often desirable to have a DLP in groups with prime cardinality in order to prevent the Pohlig–Hellman attack Since groups  Z<sub>p</sub><sup>*</sup> have cardinality p−1, which is obviously not prime,</p> <p>one often uses DLPs in subgroups of  Z<sub>p</sub><sup>*</sup> with prime order,</p> <p>rather than using the group  Z<sub>p</sub><sup>*</sup> itself. We illustrate this with an example.</p> <p>Example 8.12. We consider the group Z<sub>47</sub><sup>*</sup>  which has order 46. The subgroups in</p> <p>Z<sub>47</sub><sup>*</sup> have thus a cardinality of 23, 2 and 1. α = 2 is an element in the subgroup with 23 elements, and since 23 is a prime, α is a primitive element in the subgroup. A possible discrete logarithm problem is given for β = 36 (which is also in the subgroup): Find the positive integer x, 1 ≤ x ≤ 23, such that 2<sup>x</sup> ≡ 36 mod 47 By using a brute-force attack, we obtain a solution for x = 17.</p> <h4 id="the-generalized-discrete-logarithm-problem"><a href="#the-generalized-discrete-logarithm-problem" class="header-anchor">#</a> The Generalized Discrete Logarithm Problem</h4> <p>The feature that makes the DLP particularly useful in cryptography is that it is not restricted to the multiplicative group Z<sub>p</sub><sup>*</sup>, p prime, but can be defined over any cyclic groups. This is called the generalized discrete logarithm problem (GDLP) and can be stated as follows.</p> <p>Definition 8.3.2 Generalized Discrete Logarithm Problem</p> <p>Given is a finite cyclic group G with the group operation ◦ and cardinality n. We consider a primitive element α ∈ G and another
element β ∈ G. The discrete logarithm problem is finding the integer x, where 1 ≤ x ≤ n, such that:
β =α◦α ◦. . . ◦α (x times)=α<sup>x</sup></p> <p>As in the case of the DLP in Z<sub>p</sub><sup>*</sup>, such an integer x must exist since α is a primitive element, and thus each element of the group G can be generated by repeated application of the group operation on α.
It is important to realize that there are cyclic groups in which the DLP is not difficult. Such groups cannot be used for a public-key cryptosystem since the DLP is not a one-way function. Consider the following example.
Example 8.13. This time we consider the additive group of integers modulo a prime. For instance, if we choose the prime p = 11, G = (Z11,+) is a finite cyclic group with the primitive element α = 2. Here is how α generates the group:</p> <table><thead><tr><th>i</th> <th>1</th> <th>2</th> <th>3</th> <th>4</th> <th>5</th> <th>6</th> <th>7</th> <th>8</th> <th>9</th> <th>10</th> <th>11</th></tr></thead> <tbody><tr><td>iα</td> <td>2</td> <td>4</td> <td>6</td> <td>8</td> <td>10</td> <td>1</td> <td>3</td> <td>5</td> <td>7</td> <td>9</td> <td>0</td></tr></tbody></table> <p>We try now to solve the DLP for the element β = 3, i.e., we have to compute the integer 1 ≤ x ≤ 11 such that</p> <p>x · 2 = 2+2+. . .+2 x times ≡ 3 mod 11</p> <p>Here is how an “attack” against this DLP works. Even though the group operation is addition, we can express the relationship between α, β and the discrete logarithm x in terms of multiplication:
x · 2 ≡ 3 mod 11.
In order to solve for x, we simply have to invert the primitive element α:
x ≡ 2<sup>−1</sup> · 3 mod 11</p> <p>Using, e.g., the extended Euclidean algorithm, we can compute 2<sup>−1</sup> ≡ 6 mod 11 from which the discrete logarithm follows as:
x ≡ 2<sup>−1</sup> · 3 ≡ 7 mod 11</p> <p>The discrete logarithm can be verified by looking at the small table provided above.
We can generalize the above trick to any group (Zn,+) for arbitrary n and elements α,β ∈ Zn. Hence, we conclude that the generalized DLP is computationally easy over Zn. The reason why the DLP can be solved here easily is that we have mathematical operations which are not in the additive group, namely multiplication and inversion</p> <p>After this counterexample we now list discrete logarithm problems that have been proposed for use in cryptography:</p> <ol><li>The multiplicative group of the prime field Zp or a subgroup of it. For instance, the classical DHKE uses this group, but also Elgamal encryption or the Digital Signature Algorithm (DSA). These are the oldest and most widely used types of discrete logarithm systems.</li> <li>The cyclic group formed by an elliptic curve. They have become popular in practice over the last decade.</li> <li>The multiplicative group of a Galois field GF(2<sup>m</sup>) or a subgroup of it. These groups can be used completely analogous to multiplicative groups of prime fields, and schemes such as the DHKE can be realized with them. They are not as popular
in practice because the attacks against them are somewhat more powerful than those against the DLP in Zp. Hence DLPs over GF(2<sup>m</sup>) require somewhat higher bit lengths for providing the same level of security than those over Zp.</li> <li>Hyperelliptic curves or algebraic varieties, which can be viewed as generalization as elliptic curves. They are currently rarely used in practice, but in particular hyperelliptic curves have some advantages such as short operand lengths</li></ol> <h4 id="security-of-the-diffie-hellman-key-exchange"><a href="#security-of-the-diffie-hellman-key-exchange" class="header-anchor">#</a> Security of the Diffie–Hellman Key Exchange</h4> <p>Let’s now consider the possibilities of a passive adversary, i.e., Oscar can only listen but not alter messages. His goal is to compute the session key kAB shared by Alice and Bob. Which information does Oscar get from observing the protocol?
Certainly, Oscar knows α and p because these are public parameters chosen during the set-up protocol. In addition, Oscar can obtain the values A = kpub,A and B=kpub,B by eavesdropping on the channel during an execution of the key-exchange protocol. Thus, the question is whether he is capable of computing k = α<sup>ab</sup> from α, p,A ≡α<sup>a</sup> mod p and B ≡α<sup>b</sup> mod p. This problem is called the Diffie–Hellman problem (DHP). Like the discrete logarithm problem it can be generalized to arbitrary finite cyclic groups. Here is a more formal statement of the DHP:</p> <p>Definition 8.4.1 Generalized Diffie–Hellman Problem (DHP)
Given is a finite cyclic group G of order n, a primitive element α ∈ G and two elements A = α<sup>a</sup> and B = α<sup>b</sup> in G. The Diffie–Hellman problem is to find the group element α<sup>ab</sup>.</p> <h4 id="the-elgamal-encryption-scheme"><a href="#the-elgamal-encryption-scheme" class="header-anchor">#</a> The Elgamal Encryption Scheme</h4> <p>密码学｜6.4.2 椭圆Elgamal公钥密码系统 https://mp.weixin.qq.com/s/EjhPlck9-7MzIZvstriaOg</p> <p>The protocol consists of two phases, the classical DHKE which is followed by the message encryption and decryption.
Bob computes his private key d and public key β . This key pair does not change, i.e., it can be used for encrypting many messages. Alice, however, has to generate a new public–private key pair for the encryption of every message. Her private key
is denoted by i and her public key by kE. The latter is an ephemeral (existing only temporarily) key, hence the index “E”. The joint key is denoted by kM because it is used for masking the plaintext. For the actual encryption, Alice simply multiplies the plaintext message x by the masking key kM in Z<sub>p</sub><sup>*</sup>. On the receiving side, Bob reverses the encryption by multipliying with the inverse mask. Note that one property of cyclic groups is that,</p> <p>given any key kM ∈ Z<sub>p</sub><sup>*</sup>, every messages x maps to another ciphertext if the two values are multiplied.</p> <p>Moreover, if the key kM is randomly drawn from Z<sub>p</sub><sup>*</sup>, every ciphertext y ∈ {1,2, . . . , p−1} is equally likely.</p> <h5 id="computational-aspects"><a href="#computational-aspects" class="header-anchor">#</a> Computational Aspects</h5> <ul><li><p>Key Generation</p></li> <li><p>During the key generation by the receiver (Bob in our example), a prime p must be generated, and the public and private have to be computed. Since the security of Elgamal also depends on the discrete logarithm problem, p should have a
length of at least 1024 bits. To generate such a prime, the prime-finding algorithms can be used. The private key should be generated by a true random number generater. The public key requires one exponentiation for which the square-and-multiply algorithm is used.</p></li> <li><p>Encryption</p> <p>Within the encryption procedure, two modular exponentiations and one modular multiplication are required for computing the ephemeral and the masking key, as well as for the message encryption. All operands involved have a bit length of log<sub>2</sub><sup>p</sup>. For efficient exponentiation, one should apply the square-and-multiply algorithm, It is important to note that the two exponentiations, which constitute almost all computations necessary, are independent of the plaintext. Hence, in some applications they can be precomputed at times of low computational load, stored and used when the actual encryption is needed. This can be a major advantage in practice.</p></li> <li><p>Decryption The main steps of the decryption are first an exponentiation k<sub>M</sub> = k<sup>d</sup> mod p, using the square-and-multiply algorithm, followed by an inversion of k<sub>M</sub>,that is performed with the extended Euclidean algorithm. However, there is a shortcut based on Fermat’s Little Theorem that combines these two steps in a single one. from Fermat’s Little Theorem :</p> <p>k<sub>E</sub><sup>p-1</sup>≡1 mod p</p> <p>for all kE ∈ Z<sub>p</sub><sup>*</sup>. We can now merge Step 1 and 2 of the decryption as follows:</p> <p>k<sub>M</sub><sup>-1</sup>≡ (k<sub>E</sub><sup>d</sup>)<sup>−1</sup> mod p
≡ (k<sub>E</sub><sup>d</sup>)<sup>−1</sup>k<sub>E</sub><sup>p−1</sup> mod p
≡ k<sub>E</sub><sup>p−d−1</sup> mod p</p> <p>The equivalence relation allows us to compute the inverse of the masking key using a single exponentiation with the exponent (p−d −1). After that, one modular multiplication is required to recover x ≡ y · k<sub>M</sub><sup>-1</sup> mod p. As a consequence, decryption essentially requires one execution of the square-and-multiply algorithm followed by a single modular multiplication for recovering the plaintext.</p></li></ul> <h3 id="elliptic-curve-cryptosystems"><a href="#elliptic-curve-cryptosystems" class="header-anchor">#</a> Elliptic Curve Cryptosystems</h3> <p>ECC is based on the generalized discrete logarithm problem, and thus DL-protocols such as the Diffie–Hellman key exchange can also be realized using elliptic curves.</p> <p>We start by giving a short introduction to the mathematical concept of elliptic curves, independent of their cryptographic applications. ECC is based on the generalized discrete logarithm problem. Hence, what we try to do first is to find a cyclic group on which we can build our cryptosystem. Of course, the mere existence of a cyclic group is not sufficient. The DL problem in this group must also be computationally hard, which means that it must have good one-way properties.
We start by considering certain polynomials (e.g., functions with sums of exponents of x and y), and we plot them over the real numbers.
Example 9.1. Let’s look at the polynomial equation x<sup>2</sup>+y<sup>2</sup> = r<sup>2</sup> over the real numbers R. If we plot all the pairs (x,y) which fulfill this equation in a coordinate system, we obtain a circle.
Example 9.2. A slight generalization of the circle equation is to introduce coefficients to the two terms x<sup>2</sup> and y<sup>2</sup>, i.e., we look at the set of solutions to the equation a · x<sup>2</sup> +b · y<sup>2</sup> = c over the real numbers. It turns out that we obtain an ellipse.</p> <h4 id="definition-of-elliptic-curves"><a href="#definition-of-elliptic-curves" class="header-anchor">#</a> Definition of Elliptic Curves</h4> <p>https://www.cs.uaf.edu/2015/spring/cs463/lecture/02_20_ECC.html</p> <p>From the two examples above, we conclude that we can form certain types of curves from polynomial equations. By “curves”, we mean the set of points (x,y) which are solutions of the equations. For example, the point (x = r,y = 0) fulfills the equation of a circle and is, thus, in the set. The point (x = r/2,y = r/2) is not a solution to the polynomial x<sup>2</sup>+y<sup>2</sup> = r<sup>2</sup> and is, thus, not a set member. An elliptic curve is a special type of polynomial equation. For cryptographic use, we need to consider the curve not over the real numbers but over a finite field. The most popular choice is prime fields GF(p) , where all arithmetic is performed modulo a prime p.</p> <p>Definition 9.1.1 Elliptic Curve
The elliptic curve over Zp, p &gt; 3, is the set of all pairs (x,y) ∈ Zp which fulfill y<sup>2</sup> ≡ x<sup>3</sup>+a · x+b mod p
together with an imaginary point of infinity O, where a,b ∈ Zp
and the condition 4 · a<sup>3</sup>+27 · b<sup>2</sup> &lt;&gt; 0 mod p.</p> <p>The definition of elliptic curve requires that the curve is nonsingular非奇异. Geometrically speaking, this means that the plot has no self-intersections or vertices, which is achieved if the discriminant of the curve −16(4a<sup>3</sup>+27b<sup>2</sup>) is nonzero.</p> <p>证明: https://people.reed.edu/~jerry/131/ec.pdf</p> <p>For cryptographic use we are interested in studying the curve over a prime field as in the definition. However, if we plot such an elliptic curve over Zp, we do not get anything remotely resembling a curve. However, nothing prevents us from taking an elliptic curve equation and plotting it over the set of real numbers.</p> <p>Example: y2 = x3 −3x+3 over R</p> <p>https://www.desmos.com/calculator/ialhd71we3</p> <p>https://graui.de/code/elliptic2/</p> <p>We notice several things from this elliptic curve plot.First, the elliptic curve
is symmetric with respect to the x-axis. This follows directly from the fact that for
all values xi which are on the elliptic curve, both yi =根号下的(x<sub>i</sub><sup>3</sup> +a · x<sub>i</sub>+b) and yi =负根号下的(x<sub>i</sub><sup>3</sup> +a · x<sub>i</sub>+b) are solutions.</p> <p>Second, there is one intersection with the x-axis. This follows from the fact that it is a cubic equation if we solve for y = 0 which has one real solution (the intersection with the x-axis) and two complex solutions (which do not show up in the plot). There are also elliptic curves with three intersections with the x-axis(e.g, b=3,a=-5).</p> <p>We now return to our original goal of finding a curve with a large cyclic group, which is needed for constructing a discrete logarithm problem. The first task for finding a group is done, namely identifying a set of elements. In the elliptic curve case, the group elements are the points that fulfill y<sup>2</sup> ≡ x<sup>3</sup>+a · x+b mod p . The next question at hand is: How do we define a group operation with those points? Of course, we have to make sure that the group laws hold for the operation. 简言之，如何定义满足 y<sup>2</sup> ≡ x<sup>3</sup>+a · x+b mod p 的points的composition law，从而让其构成group</p> <h4 id="group-operations-on-elliptic-curves"><a href="#group-operations-on-elliptic-curves" class="header-anchor">#</a> Group Operations on Elliptic Curves</h4> <p>Let’s denote the group operation with the addition symbol “+”. “Addition” means that given two points and their coordinates, say P = (x1,y1) and Q = (x2,y2), we have to compute the coordinates of a third point R such that:
P+Q = R
(x1,y1)+(x2,y2) = (x3,y3)</p> <p>As we will see below, it turns out that this addition operation looks quite arbitrary. Luckily, there is a nice geometric interpretation of the addition operation if we consider a curve defined over the real numbers. For this geometric interpretation, we have to distinguish two cases: the addition of two distinct points (named point addition) and the addition of one point to itself (named point doubling).</p> <ul><li><p>Point Addition P+Q</p> <p>This is the case where we compute R = P+Q and P &lt;&gt; Q. The construction works as follows: Draw a line through P and Q and obtain a third point of intersection between the elliptic curve and the line. Mirror this third intersection point along the x-axis. This mirrored point is, by definition, the point R.</p></li> <li><p>Point Doubling</p> <p>P+P This is the case where we compute P+Q but P=Q. Hence, we can write R = P+P = 2P. We need a slightly different construction here. We draw the tangent line through P and obtain a second point of intersection between this line and the elliptic curve. We mirror the point of the second intersection along the x-axis. This mirrored point is the result R of the doubling.</p></li></ul> <p>You might wonder why the group operations have such an arbitrary looking form. Historically, this tangent-and-chord method was used to construct a third point if two points were already known, while only using the four standard algebraic operations
add, subtract, multiply and divide. It turns out that if points on the elliptic curve are added in this very way, the set of points also fulfill most conditions necessary for a group, that is, closure, associativity, existence of an identity element and existence of an inverse. 简言之，这种看起来“随意”的构造方式可以让这种composition law满足group定义</p> <p>Of course, in a cryptosystem we cannot perform geometric constructions. However, by applying simple coordinate geometry, we can express both of the geometric constructions from above through analytic expressions, i.e., formulae. As stated above, these formulae only involve the four basic algebraic operations. These operations can be performed in any field, not only over the field of the real numbers. In particular, we can take the curve equation from above, but we now consider it over prime fields GF(p) rather than over the real numbers. This yields the following analytical expressions for the group operation.</p> <p>Elliptic Curve Point Addition and Point Doubling
x<sub>3</sub> = s<sup>2</sup>−x<sub>1</sub>−x<sub>2</sub> mod p
y<sub>3</sub> = s(x<sub>1</sub>−x<sub>3</sub>)−y<sub>1</sub> mod p
where</p> <p>if P &lt;&gt; Q (point addition):	s =(y<sub>2</sub>−y<sub>1</sub>)/(x<sub>2</sub>−x<sub>1</sub>) mod p ; 两点求斜率很简单</p> <p>if P = Q (point doubling):	 s=(3x<sub>1</sub><sup>2</sup>+a)/2y<sub>1</sub> mod p ; 	y<sup>2</sup> ≡ x<sup>3</sup>+a · x+b两边对x求导，2yy'=3x<sup>2</sup>+a</p> <p>推导：</p> <p>y = sx+c. s = (-y<sub>3</sub>-y<sub>1</sub>)/(x<sub>3</sub>-x<sub>1</sub>)	Note:这里是-y<sub>3</sub>，因为根据前面知道我们是取两点连线和椭圆曲线的交点的对称点</p> <p>代入</p> <p>y<sup>2</sup> ≡ x<sup>3</sup>+a · x+b mod p</p> <p>=》 (sx+c)<sup>2</sup>≡ x<sup>3</sup>+a · x+b mod p</p> <p>=》s<sup>2</sup>x<sup>2</sup> + 2scx+ c<sup>2</sup> = x<sup>3</sup>+a · x+b</p> <p>=》 x<sup>3</sup>- s<sup>2</sup>x<sup>2</sup>  +(a-2sc) · x+b-c<sup>2</sup> = 0</p> <p>根据韦达定理(https://zh.wikipedia.org/wiki/%E9%9F%A6%E8%BE%BE%E5%AE%9A%E7%90%86)</p> <p>x<sub>1</sub>+x<sub>2</sub>+x<sub>3</sub>=s<sup>2</sup></p> <p>=&gt; x<sub>3</sub> = s<sup>2</sup>−x<sub>1</sub>−x<sub>2</sub> mod p</p> <p>s = (-y<sub>3</sub>-y<sub>1</sub>)/(x<sub>3</sub>-x<sub>1</sub>)</p> <p>=&gt; y<sub>3</sub>+y<sub>1</sub> =  s(x<sub>1</sub>-x<sub>3</sub>)</p> <p>=&gt; y<sub>3</sub>=  s(x<sub>1</sub>-x<sub>3</sub>)- y<sub>1</sub></p> <p>Note that the parameter s is the slope of the line through P and Q in the case of point addition, or the slope of the tangent through P in the case of point doubling.</p> <p>Even though we made major headway towards the establishment of a finite group, we are not there yet. One thing that is still missing is an identity (or neutral) element O such that: P+O = P</p> <p>for all points P on the elliptic curve. It turns out that there isn’t any point (x,y) that fulfills the condition. Instead we define an abstract point at infinity as the neutral element O. This point at infinity can be visualized as a point that is located towards
“plus” infinity along the y-axis or towards “minus” infinity along the y-axis.</p> <p>According the group definition, we can now also define the inverse −P of any group element P as:</p> <p>P+(−P) = O.</p> <p>The question is how do we find −P? If we apply the tangent-and-chord method from above, it turns out that the inverse of the point P = (x<sub>p</sub>,y<sub>p</sub>) is the point −P = (x<sub>p</sub>,−y<sub>p</sub>), i.e., the point that is reflected along the x-axis.</p> <p>Note that finding the inverse of a point P = (x<sub>p</sub>,y<sub>p</sub>) is now trivial. We simply take the negative of its y coordinate. In the case of elliptic curves over a prime field GF(p) (the most interesting case in cryptography), this is easily achieved since −y<sub>p</sub> ≡ p−y<sub>p</sub> mod p, hence−P = (x<sub>p</sub>, p−y<sub>p</sub>).</p> <p>Example. We consider a curve over the small field Z<sub>17</sub>:</p> <p>E : y<sup>2</sup> ≡ x<sup>3</sup>+2x+2 mod 17.</p> <p>We want to double the point P = (5,1).
2P= P+P = (5,1)+(5,1) = (x<sub>3</sub>,y<sub>3</sub>)</p> <p>s =(3x<sub>1</sub><sup>2</sup>+a)/2y<sub>1</sub> = (2 · 1)<sup>−1</sup>(3 · 5<sup>2</sup>+2) = 2<sup>−1</sup> · 9 ≡ 9 · 9 ≡ 13 mod 17</p> <p>x<sub>3</sub> = s<sup>2</sup>−x<sub>1</sub>−x<sub>2</sub> = 13<sup>2</sup>−5−5 = 159 ≡ 6 mod 17</p> <p>y<sub>3</sub> = s(x<sub>1</sub>−x<sub>3</sub>)−y<sub>1</sub> = 13(5−6)−1 = −14 ≡ 3 mod 17</p> <p>​		mod(a, n) = a - n * floor(a / n)</p> <p>​		−14 mod 17 = -14 - 17<em>floor(-14/17) =-14 - 17</em>floor(-0.8) 不同程序结果不同，比如向下取整 -1 ，结果为3，向上取整或向零取整结果为?</p> <p>2P = (5,1)+(5,1) = (6,3)</p> <p>For illustrative purposes we check whether the result 2P = (6,3) is actually a point
on the curve by inserting the coordinates into the curve equation:</p> <p>y<sup>2</sup> ≡ x<sup>3</sup>+2 · x+2 mod 17</p> <p>3<sup>2</sup> ≡ 6<sup>3</sup>+2 · 6+2 mod 17
9 = 230 ≡ 9 mod 17</p> <h4 id="building-a-discrete-logarithm-problem-with-elliptic-curves"><a href="#building-a-discrete-logarithm-problem-with-elliptic-curves" class="header-anchor">#</a> Building a Discrete Logarithm Problem with Elliptic Curves</h4> <p>Theorem 9.2.1 The points on an elliptic curve together with O have cyclic subgroups. Under certain conditions all points on an
elliptic curve form a cyclic group.</p> <p>Please note that we have not proved the theorem. This theorem is extremely useful because we have a good understanding of the properties of cyclic groups. In particular, we know that by definition a primitive element must exist such that its powers generate the entire group. Moreover, we know quite well how to build cryptosystems from cyclic groups. Here is an example for the cyclic group of an elliptic curve.</p> <p>Example. We want to find all points on the curve:
E : y<sup>2</sup> ≡ x<sup>3</sup>+2 · x+2 mod 17.</p> <p>It happens that all points on the curve form a cyclic group and that the order is #E = 19. For this specific curve the group order is a prime, so every element is primitive.
As in the previous example we start with the primitive element P = (5,1). We compute now all “powers” of P. More precisely, since the group operation is addition, we compute P,2P, . . . , (#E)P. Here is a list of the elements that we obtain:</p> <p>1P = (5,1)</p> <p>2P = (5,1)+(5,1) = (6,3) 			11P = (13,10)
3P = 2P+P = (10,6) 					12P = (0,11)
4P = (3,1) 									13P = (16,4)
5P = (9,16) 									14P = (9,1)
6P = (16,13) 								15P = (3,16)
7P = (0,6) 									16P = (10,11)
8P = (13,7) 									17P = (6,14)
9P = (7,6) 										18P = (5,16)
10P = (7,11) 										19P = O</p> <p>It is also instructive to look at the last computation above, which yielded:</p> <p>19P = P + 18P  = (5,1)+(5,16) = O</p> <p>This means that P = (5,1) is the inverse of 18P = (5,16), and vice versa. This is easy to verify. We have to check whether the two x coordinates are identical and that the two y coordinates are each other’s additive inverse modulo 17. The first condition obviously hold and the second one too, since −1 ≡ 16 mod 17.
另一种理解方式：</p> <p>s =(y<sub>2</sub>−y<sub>1</sub>)/(x<sub>2</sub>−x<sub>1</sub>) mod p = (16-1)/(5-5)= ∞</p> <p>x<sub>3</sub> = s<sup>2</sup>−x<sub>1</sub>−x<sub>2</sub> = ∞−5−5 = ∞≡ ∞ mod 17</p> <p>y<sub>3</sub> = s(x<sub>1</sub>−x<sub>3</sub>)−y<sub>1</sub> = ∞(5−∞)−1 ≡ ∞ mod 17</p> <p>=&gt; 19P = (∞, ∞)</p> <p>From now on, the cyclic structure becomes visible since:
20P = 19P+P = O +P = P
21P = 2P</p> <p>To set up DL cryptosystems it is important to know the order of the group. Even though knowing the exact number of points on a curve is an elaborate task, we know the approximate number due to Hasse’s theorem.</p> <p>Theorem 9.2.2 Hasse’s theorem
Given an elliptic curve E modulo p, the number of points on the curve is denoted by #E and is bounded by:
p+1−2√p ≤ #E ≤ p+1+2√p.</p> <p>Hasse’s theorem, which is also known as Hasse’s bound, states that the number of points is roughly in the range of the prime p. This has major practical implications.
For instance, if we need an elliptic curve with 2<sup>160</sup> elements, we have to use a prime of length of about 160 bit.
Let’s now turn our attention to the details of setting up the discrete logarithm problem.</p> <p>Definition 9.2.1 Elliptic Curved Discrete Logarithm Problem (ECDLP)
Given is an elliptic curve E. We consider a primitive element P and another element T. The DL problem is finding the integer d,
where 1 ≤ d ≤ #E, such that:</p> <p>P+P+· · · +P (d times) = dP = T.  this operation is called point multiplication, since we can formally write T = dP. This terminology can be misleading, however, since we cannot directly multiply the integer d with a curve point P. Instead, dP is merely a convenient notation for the repeated application of the group operation (point addiction).</p> <p>In cryptosystems, d is the private key which is an integer, while the public key T is a point on the curve with coordinates T = (xT ,yT ). In contrast, in the case of the DL problem in Z<sub>p</sub><sup>*</sup>, both keys were integers.</p> <p>Example 9.6. We perform a point multiplication on the curve y2 ≡ x3+2x+2 mod
17 that was also used in the previous example. We want to compute</p> <p>13P = P+P+. . .+P</p> <p>where P=(5,1). In this case, we can simply use the table that was compiled earlier:</p> <p>13P = (16,4).</p> <p>Point multiplication is analog to exponentiation in multiplicative groups. In order to do it efficiently, we can directly adopt the square-and-multiply algorithm. The only difference is that squaring becomes doubling and multiplication becomes addition of P. Here is the algorithm:</p> <p>Double-and-Add Algorithm for Point Multiplication
Input: elliptic curve E together with an elliptic curve point P</p> <p>a scalar d = Σ<sub>i=0</sub><sup>t</sup> d<sub>i</sub>2<sup>i</sup> with d<sub>i</sub> ∈ 0,1 and d<sub>t</sub> = 1
Output: T = dP
Initialization:
T = P
Algorithm:
1 	FOR i = t −1 DOWNTO 0
1.1  	T = T +T mod n
IF d<sub>i</sub> = 1
1.2 		T = T +P mod n
2 	RETURN (T)</p> <p>For a random scalar of length of t +1 bit, the algorithm requires on average 1.5t point doubles and additions. Verbally expressed, the algorithm scans the bit representation of the scalar d from left to right. It performs a doubling in every iteration, and only if the current bit has the value 1 does it perform an addition of P. Let’s look at an example.
Example 9.7. We consider the scalar multiplication 26P, which has the following binary representation:
26P = (11010<sub>2</sub>)P = (d<sub>4</sub>d<sub>3</sub>d<sub>2</sub>d<sub>1</sub>d<sub>0</sub>)<sub>2</sub> P.</p> <p>The algorithm scans the scalar bits starting on the left with d<sub>4</sub> and ending with the rightmost bit d<sub>0</sub>.</p> <p>Step:
#0 P = 1<sub>2</sub> P inital setting, bit processed: d<sub>4</sub> = 1
#1a P+P = 2P = 10<sub>2</sub> P DOUBLE, bit processed: d<sub>3</sub>
#1b 2P+P = 3P = 10<sub>2</sub> P+1<sub>2</sub> P = 11<sub>2</sub> P ADD, since d<sub>3</sub> = 1
#2a 3P+3P = 6P = 2(11<sub>2</sub> P) = 110<sub>2</sub> P DOUBLE, bit processed: d<sub>2</sub>
#2b no ADD, since d<sub>2</sub> = 0
#3a 6P+6P = 12P = 2(110<sub>2</sub> P) = 1100<sub>2</sub> P DOUBLE, bit processed: d<sub>1</sub>
#3b 12P+P = 13P = 1100<sub>2</sub> P+1<sub>2</sub> P = 1101<sub>2</sub> P ADD, since d1 = 1
#4a 13P+13P = 26P = 2(1101<sub>2</sub> P) = 11010<sub>2</sub> P DOUBLE, bit processed: d0
#4b no ADD, since d0 = 0</p> <p>It is instructive to observe how the binary representation of the exponent evolves. We see that doubling results in a left shift of the scalar, with a 0 put in the rightmost position. By performing addition with P, a 1 is inserted into the rightmost position of the scalar. Compare how the highlighted exponents change from iteration to iteration.</p> <p>If we go back to elliptic curves over the real numbers, there is a nice geometric interpretation for the ECDLP: given a starting point P, we compute 2P, 3P, . . ., dP = T, effectively hopping back and forth on the elliptic curve. We then publish the starting point P (a public parameter) and the final point T (the public key). In order to break the cryptosystem, an attacker has to figure out how often we “jumped” on the elliptic curve. The number of hops is the secret d, the private key.</p> <h4 id="diffie-hellman-key-exchange-with-elliptic-curves"><a href="#diffie-hellman-key-exchange-with-elliptic-curves" class="header-anchor">#</a> Diffie–Hellman Key Exchange with Elliptic Curves</h4> <p>In complete analogy to the conventional Diffie–Hellman key exchange (DHKE) introduced, we can now realize a key exchange using elliptic curves. This is referred to as elliptic curve Diffie–Hellman key exchange, or ECDH. First we have to agree on domain parameters, that is, a suitable elliptic curve over which we can work and a primitive element on this curve.</p> <p>In practice, often the x-coordinate is hashed and then used as a symmetric key. Typically,not all bits are needed. For instance, in a 160-bit ECC scheme, hashing the x-coordinate with SHA-1 results in a 160-bit output of which only 128 would be used as an AES key.</p> <p>Please note that elliptic curves are not restricted to the DHKE. In fact, almost all other discrete logarithm protocols, in particular digital signatures and encryption, e.g., variants of Elgamal, can also be realized and The widely used elliptic curve digital signature algorithms (ECDSA)</p> <h4 id="security"><a href="#security" class="header-anchor">#</a> Security</h4> <p>Note that in practice finding a suitable elliptic curve is a relatively difficult task. The curves have to show certain properties in order to be secure.</p> <p>The reason we use elliptic curves is that the ECDLP has very good one-way characteristics. If an attacker Oscar wants to break the ECDH, he has the following information: E, p, P, A, and B. He wants to compute the joint secret between Alice and Bob T<sub>AB</sub> = a · b · P. This is called the elliptic curve Diffie–Hellman problem (ECDHP). There appears to be only one way to compute the ECDHP, namely to solve either of the discrete logarithm problems: a = log<sub>P</sub>A or b = log<sub>P</sub>B</p> <p>If the elliptic curve is chosen with care, the best known attacks against the ECDLP are considerably weaker than the best algorithms for solving the DL problem modulo p, and the best factoring algorithms which are used for RSA attacks. In particular, the index-calculus algorithms, which are powerful attacks against the DLP modulo p, are not applicable against elliptic curves. For carefully selected elliptic curves, the only remaining attacks are generic DL algorithms, that is Shanks’ baby-step giant-step method and Pollard’s rho method. Since the number of steps required for such an attack is roughly equal to the square root of the group cardinality, a group order of at least 2160 should be used. According to Hasse’s theorem, this requires that the prime p used for the elliptic curve must be roughly 160-bit long. If we attack such a group with generic algorithms, we need around √2160 = 280 steps. A security level of 80 bit provides medium-term security. In practice, elliptic curve bit lengths up to 256 bit are commonly used, which provide security levels of up to 128 bit. It should be stressed that this security is only achieved if cryptographically strong elliptic curves are used. There are several families of curves that possess cryptographic weaknesses, e.g., supersingular curves. They are relatively easy to spot, however. In practice, often standardized curves such as ones proposed by the National Institute of Standards and Technology (NIST) are being used.</p> <p>Before using ECC, a curve with good cryptographic properties needs to be identified. In practice, a core requirement is that the cyclic group (or subgroup) formed by the curve points has prime order(猜测原因应该是，根据之前group的基础知识知道，prime order的group isomorphic to Cyclic group，即group中任意非identity的元素都可以生成整个group，如果选择的不是prime order则没有这个性质，非identity元素可能生成的是sub group，这样就有安全问题了，比如某个元素只能生成order=2的subgroup就很危险了，换句话说，在ECC中，相当于某个点无论选择什么私钥d都只能生成两个元素/公钥，换句话说，知道了公钥，任意选择一个私钥都有很大概率50%？猜中). Moreover, certain mathematical properties that lead to cryptographic weaknesses must be ruled out. Since assuring all these properties is a nontrivial and computationally demanding task, often standardized curves are used in practice.</p> <p>When implementing elliptic curves it is useful to view an ECC scheme as a structure with four layers. On the <strong>bottom layer modular arithmetic</strong>, i.e., arithmetic in the prime field GF(p), is performed. We need all four field operations: addition, subtraction, multiplication and inversion. On the next layer, the two group operations, point doubling and point addition, are realized. They make use of the arithmetic provided in the bottom layer. On the third layer, scalar multiplication is realized, which uses the group operations of the previous layer. The top layer implements the actual protocol, e.g., ECDH or ECDSA. <strong>It is important to note that two entirely different finite algebraic structures are involved in an elliptic curve cryptosystem. There is a finite field GF(p) over which the curve is defined, and there is the cyclic group which is formed by the points on the curve.</strong></p> <p>In software, a highly optimized 256-bit ECC implementation on a 3-GHz, 64-bit CPU can take approximately 2 ms for one point multiplication. Slower throughputs due to smaller microprocessors or less optimized algorithms are common with performances in the range of 10 ms. For high-performance applications, e.g., for Internet servers that have to perform a large number of elliptic curve signatures per second, hardware implementations are desirable. The fastest implementations can compute a point multiplication in the range of 40 μs, while speeds of several 100 μs are more common.</p> <p>On the other side of the performance spectrum, ECC is the most attractive publickey algorithm for lightweight applications such as RFID tags. Highly compact ECC engines are possible which need as little as 10,000 gate equivalences and run at a speed of several tens of milliseconds. Even though ECC engines are much larger than implementations of symmetric ciphers such as 3DES, they are considerably smaller than RSA implementations.
**The computational complexity of ECC is cubic in the bit length of the prime used. This is due to the fact that modular multiplication, which is the main operation on the bottom layer, is quadratic in the bit length, and scalar multiplication (i.e.,with the Double-and-Add algorithm) contributes another linear dimension, so that we have, in total, a cubic complexity. This implies that doubling the bit length of an ECC implementation results in performance degradation by a factor of roughly 2<sup>3</sup> = 8. **RSA and DL systems show the same cubic runtime behavior. The advantage of ECC over the other two popular public-key families is that the parameters have to be increased much more slowly to enhance the security level. For instance, doubling the effort of an attacker for a given ECC system requires an increase in the length of the parameter by 2 bits, whereas RSA or DL schemes require an increase of 20–30 bits. This behavior is due to the fact that only generic attacks are known ECC cryptosystems, whereas more powerful algorithms are available for attacking RSA and DL schemes.</p> <h4 id="further-reading"><a href="#further-reading" class="header-anchor">#</a> Further Reading</h4> <h5 id="history-and-general-remarks"><a href="#history-and-general-remarks" class="header-anchor">#</a> History and General Remarks</h5> <p>ECC was independently invented in 1987 by Neal Koblitz and in 1986 by Victor Miller. During the 1990s there was much speculation about the security and practicality of ECC, especially if compared to RSA. After a period of intensive research, they appear nowadays very secure, just like RSA and DL schemes. An important step for building confidence in ECC was the issuing of two ANSI banking standards for elliptic curve digital signature and key establishment in 1999 and 2001, respectively [6, 7]. Interestingly, in Suite B—a collection of crypto algorithms selected by the NSA for use in US government systems—only ECC schemes are allowed as asymmetric algorithms [130]. Elliptic curves are also widely used in commercial standards such as IPsec or Transport Layer Security (TLS).
At the time of writing, there still exist far more fielded RSA and DL applications than elliptic curve ones. This is mainly due to historical reasons and due to the quite complex patent situation of some ECC variants. Nevertheless, in many new applications
with security needs, especially in embedded systems such as mobile devices, ECC is often the preferred public-key scheme. For instance, ECC is used in the most popular business handheld devices. Most likely, ECC will become more widespread in the years to come. Reference [100] describes the historical development of ECC with respect to scientific and commercial aspects, and makes excellent reading.</p> <p>For readers interested in a deeper understanding of ECC, the books [25, 24, 90, 44] are recommended. The overview article [103], even though a bit dated now, provides a good state-of-the-art summary as of the year 2000. For more recent developments, the annual Workshop on Elliptic Curve Cryptography (ECC) is recommended as an excellent resource [166]. The workshop includes both theoretical and applied topics related to ECC and related crypto schemes. There is also a rich literature that deals with the mathematics of elliptic curves [154, 101, 155], regardless of their use in cryptography.</p> <h5 id="implementation-and-variants"><a href="#implementation-and-variants" class="header-anchor">#</a> Implementation and Variants</h5> <p>In the first few years after the invention of ECC, these algorithms were believed to be computationally more complex than existing public-key schemes, especially RSA. This assumption is somewhat ironic in hindsight, given that ECC tends to be often faster than most other public-key schemes.
During the 1990s, fast implementation techniques for ECC was intensively researched, which resulted in considerable performance improvements.</p> <p>In this chapter, elliptic curves over prime fields GF(p) were introduced. These are currently in practice somewhat more widely used than over other finite fields, but curves over binary Galois fields GF(2<sup>m</sup>) are also popular. For efficient implementations,
improvements are possible at the finite field arithmetic layer, at the group operation layer and at the point multiplication layer. There is a wealth of techniques and in the following is a summary of the most common acceleration techniques in practice. For curves over GF(p), generalized Mersenne primes are often used at the arithmetic level. These are primes such as p=2<sup>192</sup>−2<sup>64</sup>−1. Their major advantage is that modulo reduction is extremely simple. If general primes are used, methods similar to those described in Sect. 7.10 are applicable. With respect to ECC over fields GF(2<sup>m</sup>), efficient arithmetic algorithms are described in [90]. On the group operation layer, several optimizations are possible. A popular one is to switch from the affine coordinates that were introduced here to projective coordinates, in which each point is represented as a triple (x,y, z). Their advantage is that no inversion is required within the group operation. The number of multiplications increases, however. On the next layer, fast scalar multiplication techniques are applicable. Improved versions of the Double-and-Add algorithm which make use of the fact that
adding or subtracting a point come at almost identical costs are commonly being applied. An excellent compilation of efficient computation techniques for ECC is the book [90].</p> <p>A special type of elliptic curve that allows for particularly fast point multiplication is the Koblitz curve [158]. These are curves over GF(2<sup>m</sup>) where the coefficients have the values 0 or 1. There have also been numerous other suggestions for elliptic curves with good implementation properties. One such proposal involves elliptic curves over optimum extension fields, i.e., fields of the form GF(p<sup>m</sup>), p &gt; 2 [10].
As mentioned in Sect. 9.5, standardized curves are often being used in practice. A widely used set of curves is provided in the FIPS Standard [126, Appendix D].
Alternatives are curves specified by the ECC Brainpool consortium or the Standards for Efficient Cryptography Group (SECG) [34, 9] .
Elliptic curves also allow for many variants and generalization. They are a special case of hyperelliptic curves, which can also be used to build discrete logarithm cryptosystems [44]. A summary of implementation techniques for hyperelliptic curves is given in [175]. A completely different type of public-key scheme which also makes use of elliptic curves is identity-based cryptosystems [30], which have drawn much attention over the last few years.</p> <h4 id="test"><a href="#test" class="header-anchor">#</a> Test</h4> <ol><li><p>Show that the condition 4a<sup>3</sup>+27b<sup>2</sup> &lt;&gt; 0 mod p is fulfilled for the curve y<sup>2</sup> ≡ x<sup>3</sup>+2x+2 mod 17</p> <p>y<sup>2</sup> ≡ x<sup>3</sup>+a · x+b mod p</p> <p>a=2, b=2</p> <p>4a<sup>3</sup>+27b<sup>2</sup>  = 4*2<sup>3</sup>+27*2<sup>2</sup> =140 mod 17 =4</p></li> <li><p>Perform the additions</p> <p>(2,7)+(5,2)</p> <p>(3,6)+(3,6)</p> <p>in the group of the curve y<sup>2</sup> ≡ x<sup>3</sup>+2x+2 mod 17. Use only a pocket calculator.</p> <ol><li>(2,7)+(5,2)</li></ol> <p>s =(y2−y1)/(x2−x1) mod p</p> <p>x3 = s2−x1−x2 mod p</p> <p>y3=  s(x1-x3)- y1 mod p</p> <p>s=(2-7)/(5-2) mod 17 =-5/3 mod 17 = 12*6 mod 17 = 4</p> <p>​		1/3 mod 17 = 6 mod 17 (3*6=18 mod 17 =1 mod 17)</p> <p>​		−5 mod 17 = -5 - 17*floor(-5/17) =-5 - 17*floor(-0.29) 不同程序结果不同，比如向下取整 -1 ，结果为12</p> <p>x<sub>3</sub> = s<sup>2</sup>−x<sub>1</sub>−x<sub>2</sub> mod p = 4<sup>2</sup>−2−5 mod 17 = 6</p> <p>y<sub>3</sub>=  s(x<sub>1</sub>-x<sub>3</sub>)- y<sub>1</sub> mod p  = 4(2-6) - 7 = -23 mod 17 = -23 - 17*floor(-23/17) = -23 - 17*floor(-1.35) = -23-17*-2=11</p> <ol start="2"><li>(3,6)+(3,6)</li></ol> <p>s=(3x<sub>1</sub><sup>2</sup>+a)/2y<sub>1</sub> mod p</p> <p>x3 = s2−x1−x2 mod p</p> <p>y3=  s(x1-x3)- y1 mod p</p></li> <li><p>In this chapter the elliptic curve y<sup>2</sup> ≡x<sup>3</sup>+2x+2 mod 17 is given with #E =19.
Verify Hasse’s theorem for this curve.</p> <p>Given an elliptic curve E modulo p, the number of points on the curve is denoted by #E and is bounded by:
p+1−2√p ≤ #E ≤ p+1+2√p.</p> <p>p=17, 17+1-2√17 ≤ #E ≤ 17+1+2√17 =&gt; 18-2*4.12 ≤ #E ≤ 18+2*4.12 =&gt; 9.75  ≤ #E ≤ 26.2</p></li> <li><p>Let us again consider the elliptic curve y<sup>2</sup> ≡x<sup>3</sup>+2x+2 mod 17. Why are all points primitive elements?
Note: In general it is not true that all elements of an elliptic curve are primitive.</p> <p>order is prime, refer &lt;Group. Lagranges Theorem&gt;</p></li> <li><p>Let E be an elliptic curve defined over Z<sub>7</sub>:
E : y<sup>2</sup> =x<sup>3</sup>+3x+2.</p> <ol><li><p>Compute all points on E over Z<sub>7</sub>.</p></li> <li><p>What is the order of the group? (Hint: Do not miss the neutral element O.)</p></li> <li><p>Given the element α =(0,3), determine the order of α. Is α a primitive element?</p></li></ol></li> <li><p>In practice, a and k are both in the range p≈2<sup>150</sup> · · ·2<sup>250</sup>, and computing T =a·P and y<sub>0</sub> = k ·P is done using the Double-and-Add algorithm.</p> <ol><li><p>Illustrate how the algorithm works for a = 19 and for a = 160. Do not perform
elliptic curve operations, but keep P a variable.</p></li> <li><p>How many (i) point additions and (ii) point doublings are required on average for one “multiplication”? Assume that all integers have n = log<sub>2</sub>p bit.</p></li> <li><p>Assume that all integers have n = 160 bit, i.e., p is a 160-bit prime. Assume one group operation (addition or doubling) requires 20 μ sec. What is the time for one double-and-add operation?</p></li></ol></li> <li><p>Given an elliptic curve E over Z<sub>29</sub> and the base point P = (8,10):
E :  y<sup>2</sup> =x<sup>3</sup>+4x+20 mod 29.
Calculate the following point multiplication k · P using the Double-and-Add algorithm. Provide the intermediate results after each step.</p> <p>k = 9</p> <p>k = 20</p></li> <li><p>Given is the same curve as in 7. The order of this curve is known to be #E = 37. Furthermore, an additional point Q = 15 · P = (14,23) on this curve is given. Determine the result of the following point multiplications by using as few group operations as possible, i.e., make smart use of the known point Q. Specify how you simplified the calculation each time.
Hint: In addition to using Q, use the fact that it is easy to compute −P.</p> <p>16 ·P</p> <p>38 ·P</p> <p>53 ·P</p> <p>14 ·P+4 ·Q</p> <p>23 ·P+11 ·Q</p> <p>You should be able to perform the scalar multiplications with considerably fewer steps than a straightforward application of the double-and-add algorithm would allow.</p></li> <li><p>Your task is to compute a session key in a DHKE protocol based on elliptic curves. Your private key is a = 6. You receive Bob’s public key B = (5,9). The elliptic curve being used is defined by
y<sup>2</sup> ≡x<sup>3</sup>+x+6 mod 11.</p></li> <li><p>An example for an elliptic curve DHKE is given in previous section. Verify the two scalar multiplications that Alice performs. Show the intermediate results within the group operation.</p></li> <li><p>After the DHKE, Alice and Bob possess a mutual secret point R = (x,y). The modulus of the used elliptic curve is a 64-bit prime. Now, we want to derive a session key for a 128-bit block cipher. The session key is calculated as follows:</p> <p>K<sub>AB</sub> = h(x||y)</p> <p>Describe an efficient brute-force attack against the symmetric cipher. How many of the key bits are truly random in this case? (Hint: You do not need to describe the mathematical details. Provide a list of the necessary steps. Assume you have a function that computes square roots modulo p.)</p></li> <li><p>Derive the formula for addition on elliptic curves. That is, given the coordinates for P and Q, find the coordinates for R = (x3,y3).</p> <p>Hint: First, find the equation of a line through the two points. Insert this equation in the elliptic curve equation. At some point you have to find the roots of a cubic polynomial x<sup>3</sup>+a<sub>2</sub>x<sup>2</sup>+a<sub>1</sub>x+a<sub>0</sub>. If the three roots are denoted by x0,x1,x2, you can
use the fact that x0+x1+x2 = −a2.</p></li></ol> <p>https://www.certicom.com/content/certicom/en/21-elliptic-curve-addition-a-geometric-approach.html</p> <p>https://www.certicom.com/content/certicom/en/212-adding-the-points-P-and-P.html</p> <p>https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication</p> <p>https://juejin.cn/post/6844903900961570823</p> <p>https://www.desmos.com/calculator/ialhd71we3</p> <p>https://www.unboundsecurity.com/docs/UKC/UKC_Developers_Guide/HTML/Content/Products/UKC-EKM/UKC_Developers_Guide/DevelopingInJava/Developing_in_Java.htm</p> <div id="disqus_thread"></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/docs/assets/js/app.650a987d.js" defer></script><script src="/docs/assets/js/2.d450803a.js" defer></script><script src="/docs/assets/js/100.78a1e34e.js" defer></script><script src="/docs/assets/js/7.be017326.js" defer></script>
  </body>
</html>
