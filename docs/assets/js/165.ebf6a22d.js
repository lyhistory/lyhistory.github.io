(window.webpackJsonp=window.webpackJsonp||[]).push([[165],{591:function(e,t,n){"use strict";n.r(t);var a=n(65),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("nio basics refer to 《nio_epoll》")]),e._v(" "),n("p",[e._v("https://blog.csdn.net/twypx/article/details/84543518")]),e._v(" "),n("p",[e._v("SimpleChannelInboundHandler https://blog.csdn.net/linuu/article/details/51307060")]),e._v(" "),n("h2",{attrs:{id:"concepts"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#concepts"}},[e._v("#")]),e._v(" concepts")]),e._v(" "),n("h3",{attrs:{id:"channel"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#channel"}},[e._v("#")]),e._v(" Channel：")]),e._v(" "),n("p",[e._v("这并不是Netty专有的概念，Java NIO里也有。可以看作是入站或者出战数据的载体，有各种基本的read、write、connect、bind等方法，相当于传统IO的Socket，需要关注一下ServerChannel，ServerChannel负责创建子Channel，子Channel具体去执行一些具体accept之后的读写操作。项目中用的NioSocketChannel和NioServerSocketChannel。")]),e._v(" "),n("h3",{attrs:{id:"eventloop和eventloopgroup"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#eventloop和eventloopgroup"}},[e._v("#")]),e._v(" EventLoop和EventLoopGroup：")]),e._v(" "),n("p",[e._v("Netty的核心抽象，channel的整个生命周期都是通过EventLoop去处理。EventLoop相当于对Thread的封装，一个EventLoop里面拥有一个永远都不会改变的Thread，同时任务的提交只需要通过EventLoop就可执行；而EventLoopGroup负责为每个Channel分配一个EventLoop/")]),e._v(" "),n("h3",{attrs:{id:"channelfuture"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#channelfuture"}},[e._v("#")]),e._v(" ChannelFuture：")]),e._v(" "),n("p",[e._v("Netty是非阻塞式IO non-blocking io。")]),e._v(" "),n("h3",{attrs:{id:"channelhandler和channelpipeline"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#channelhandler和channelpipeline"}},[e._v("#")]),e._v(" ChannelHandler和ChannelPipeline：")]),e._v(" "),n("p",[e._v("开发人员主要关注的也可能是唯一需要关注的两个组件，用来管理数据流以及执行应用程序处理逻辑。")]),e._v(" "),n("p",[n("strong",[e._v("ChannelInboundHandler和ChannelOutboundHandler:")]),e._v("\n两个常见的ChannelHandler适配器，前者管理入站的数据和操作，后者管理出站的数据和操作，谨记：入站顺序执行，出站逆序执行。")]),e._v(" "),n("p",[n("strong",[e._v("ChannelPipeline：")]),e._v("\n一个拦截流经某个channel的入站和出站时间的ChannelHandle实例链，每一个Channel刚被创建就会被分配一个ChannelPipeline，永久不可更改。")]),e._v(" "),n("p",[n("strong",[e._v("ChannelHandlerContext：")]),e._v("\nChannelHandle和ChannelPipeline中间管理的纽带，每一个ChannelHandler分配一个ChannelHandlerContext用来跟其他Handler作交互。")]),e._v(" "),n("h3",{attrs:{id:"bytebuf"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bytebuf"}},[e._v("#")]),e._v(" ByteBuf：")]),e._v(" "),n("p",[e._v("网络数据的基本单位是字节，Java NIO使用的ByteBuffer作为字节容器，而Netty使用ByteBuf替代ByteBuffer作为数据容器进行读写。")]),e._v(" "),n("h3",{attrs:{id:"bootstrap"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bootstrap"}},[e._v("#")]),e._v(" BootStrap：")]),e._v(" "),n("p",[e._v("将各种组件拼图进行组装，ServerBootstrap用来引导服务端，Bootstrap用来引导客户端。ServerBootstrap的Group一般会放入两个EventLoopGroup，需要结合Channel去理解，ServerChannel会有子Channel，那为了处理这个Channel，你需要为每一个子Channel分配一个EventLoop，第二个EventLoopGroup是为了让子Channel去共享一个EventLoop，避免额外的线程创建以及上下文切换。")]),e._v(" "),n("h3",{attrs:{id:"bytetomessagedecoder和messagetobyteencoder"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bytetomessagedecoder和messagetobyteencoder"}},[e._v("#")]),e._v(" ByteToMessageDecoder和MessageToByteEncoder：")]),e._v(" "),n("p",[e._v("编解码器的解码器和编码器，MessageToByteEncoder继承了ChannelOutboundHandlerAdapter接口，ByteToMessageDecoder继承了ChannelInboundHandlerAdapter接口。解码器是将字节解码为消息；编码器是将消息编码成字节。")]),e._v(" "),n("h1",{attrs:{id:""}},[n("a",{staticClass:"header-anchor",attrs:{href:"#"}},[e._v("#")])]),e._v(" "),n("p",[e._v("1.序列化和编码都是把 Java 对象封装成二进制数据的过程，这两者有什么区别和联系？\n序列化是把内容变成计算机可传输的资源，而编码则是让程序认识这份资源。")]),e._v(" "),n("p",[e._v("2.与服务端启动相比，客户端启动的引导类少了哪些方法，为什么不需要这些方法？\n服务端：需要两个线程组，NioServerSocketChannel线程模型，可以设置childHandle\n客户端：一个线程组，NioSocketChannel线程模型，只可以设置handler")]),e._v(" "),n("p",[e._v("3.ChannelPipeline执行顺序？\n（1）InboundHandler顺序执行，OutboundHandler逆序执行\n（2）InboundHandler之间传递数据，通过ctx.fireChannelRead(msg)\n（3）InboundHandler通过ctx.write(msg)，则会传递到outboundHandler\n（4) 使用ctx.write(msg)传递消息，Inbound需要放在结尾，在Outbound之后，不然outboundhandler会不执行；但是使用channel.write(msg)、pipline.write(msg)情况会不一致，都会执行，那是因为channel和pipline会贯穿整个流。\n（5) outBound和Inbound谁先执行，针对客户端和服务端而言，客户端是发起请求再接受数据，先outbound(写)再inbound（读），服务端则相反。")]),e._v(" "),n("p",[e._v("4.三种最常见的ChannelHandle的子类型\na. 基于 ByteToMessageDecoder，我们可以实现自定义解码，而不用关心 ByteBuf 的强转和 解码结果的传递。\nb. 基于 SimpleChannelInboundHandler，这主要针对的最常见的一种情况，你去接收一种(泛型)解码信息，然后对数据应用业务逻辑然后继续传下去。我们可以实现每一种指令的处理，通过泛型不再需要强转，不再有冗长乏味的 if else 逻辑，不需要手动传递对象。\nc. 基于 MessageToByteEncoder，我们可以实现自定义编码，而不用关心 ByteBuf 的创建，不用每次向对端写 Java 对象都进行一次编码。")]),e._v(" "),n("p",[e._v("5.Netty关于拆包粘包理论与解决方案？本次使用的是LengthFieldBasedFrameDecoder。\na.固定长度的拆包器 FixedLengthFrameDecoder\n如果你的应用层协议非常简单，每个数据包的长度都是固定的，比如 100，那么只需要把这个拆包器加到 pipeline 中，Netty 会把一个个长度为 100 的数据包 (ByteBuf) 传递到下一个 channelHandler。\nb.行拆包器 LineBasedFrameDecoder\n从字面意思来看，发送端发送数据包的时候，每个数据包之间以换行符作为分隔，接收端通过 LineBasedFrameDecoder 将粘过的 ByteBuf 拆分成一个个完整的应用层数据包。\nc.分隔符拆包器 DelimiterBasedFrameDecoder\nDelimiterBasedFrameDecoder 是行拆包器的通用版本，只不过我们可以自定义分隔符。\nd.基于长度域拆包器 LengthFieldBasedFrameDecoder\n最后一种拆包器是最通用的一种拆包器，只要你的自定义协议中包含长度域字段，均可以使用这个拆包器来实现应用层拆包。由于上面三种拆包器比较简单，读者可以自行写出 demo，接下来，我们就结合我们小册的自定义协议，来学习一下如何使用基于长度域的拆包器来拆解我们的数据包。")]),e._v(" "),n("p",[e._v("from https://www.unclewang.info/learn/java/822/")]),e._v(" "),n("p",[e._v("https://juejin.im/post/5c6d7640f265da2de80f5e9c#heading-4")]),e._v(" "),n("h2",{attrs:{id:"案例"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#案例"}},[e._v("#")]),e._v(" 案例")]),e._v(" "),n("h3",{attrs:{id:"基于http的websocket"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#基于http的websocket"}},[e._v("#")]),e._v(" 基于http的websocket")]),e._v(" "),n("p",[e._v("使用SimpleChannelInboundHandler，因为是netty封装了基于http的一系列方法，所以直接用封装的HttpServerCodec处理拆包粘包问题，并使用netty提供的FullHttpRequest直接handle http")]),e._v(" "),n("blockquote",[n("p",[e._v("官方文档：")])]),e._v(" "),n("blockquote",[n("p",[n("em",[e._v("如果对于单条HTTP消息你不想处理多个消息对象")]),e._v("，"),n("em",[e._v("你可以传入**HttpObjectAggregator 到pipline中")]),e._v("。"),n("em",[e._v("HttpObjectAggregator 会将多个消息对象转变**为单个FullHttpRequest 或者")]),e._v("FullHttpResponse")])]),e._v(" "),n("p",[e._v("https://www.cnblogs.com/xuwujing/p/7782704.html")]),e._v(" "),n("p",[e._v("websocket是基于http1.1的，自然此时netty需要handle http request")]),e._v(" "),n("p",[e._v("https://www.huaweicloud.com/articles/bb663e7adeb28738a452e98025e0b6f2.html")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('public void init() throws InterruptedException {\n    ChannelFuture channelFuture;\n    NioEventLoopGroup nioEventLoopGroup1 = new NioEventLoopGroup(this.config.getBossLoopGroupThreads());\n    NioEventLoopGroup nioEventLoopGroup2 = new NioEventLoopGroup(this.config.getWorkerLoopGroupThreads());\n    ServerBootstrap bootstrap = new ServerBootstrap();\n    ((ServerBootstrap)((ServerBootstrap)((ServerBootstrap)((ServerBootstrap)bootstrap.group(nioEventLoopGroup1, nioEventLoopGroup2)\n      .channel(io.netty.channel.socket.nio.NioServerSocketChannel.class))\n      .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, Integer.valueOf(this.config.getConnectTimeoutMillis())))\n      .option(ChannelOption.SO_BACKLOG, Integer.valueOf(this.config.getSoBacklog())))\n      .childOption(ChannelOption.WRITE_SPIN_COUNT, Integer.valueOf(this.config.getWriteSpinCount()))\n      .childOption(ChannelOption.WRITE_BUFFER_WATER_MARK, new WriteBufferWaterMark(this.config.getWriteBufferLowWaterMark(), this.config.getWriteBufferHighWaterMark()))\n      .childOption(ChannelOption.TCP_NODELAY, Boolean.valueOf(this.config.isTcpNoDelay()))\n\n      \n      .childOption(ChannelOption.SO_KEEPALIVE, Boolean.valueOf(this.config.isSoKeepAlive()))\n      .childOption(ChannelOption.SO_LINGER, Integer.valueOf(this.config.getSoLinger()))\n      .childOption(ChannelOption.ALLOW_HALF_CLOSURE, Boolean.valueOf(this.config.isAllowHalfClosure()))\n      .handler(new LoggingHandler(LogLevel.DEBUG)))\n      .childHandler(new ChannelInitializer<NioSocketChannel>()\n        {\n          protected void initChannel(NioSocketChannel ch) throws Exception {\n            ChannelPipeline pipeline = ch.pipeline();\n            \n            pipeline.addLast("http-codec", new HttpServerCodec());\n            \n            pipeline.addLast("aggregator", new HttpObjectAggregator(65536));\n            \n            pipeline.addLast("http-chunked", new ChunkedWriteHandler());\n            \n            pipeline.addLast("http-server-handler", new HttpServerHandler(WebsocketServer.this.pojoEndpointServer, WebsocketServer.this.config));\n          }\n        });\n.....................        \nclass HttpServerHandler extends SimpleChannelInboundHandler<FullHttpRequest> {\n  private final PojoEndpointServer pojoEndpointServer;\n  private static ByteBuf faviconByteBuf = null; private final ServerEndpointConfig config;\n  private static ByteBuf notFoundByteBuf = null;\n  private static ByteBuf badRequestByteBuf = null;\n  private static ByteBuf forbiddenByteBuf = null;\n  private static ByteBuf internalServerErrorByteBuf = null;\n')])])]),n("h3",{attrs:{id:"基于tcp的rpc"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#基于tcp的rpc"}},[e._v("#")]),e._v(" 基于TCP的rpc")]),e._v(" "),n("p",[e._v("当然rpc也可以基于http实现，我们这里是说基于tcp的rpc：")]),e._v(" "),n("p",[e._v("同样是使用SimpleChannelInboundHandler，但不再使用netty提供的基于http的方法，而是自己处理接收到的TCP消息，所以需要处理拆包粘包：自定义继承了ByteToMessageDecoder的RpcDecoder，并且需要handle 自定义的rpc request：自定义继承了SimpleChannelInboundHandler的RpcServerHandler")]),e._v(" "),n("p",[e._v("使用netty实现高性能rpc https://www.cnblogs.com/jietang/p/5615681.html")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public void start() throws Exception {\n\t\tif(leaderGroup == null && workerGroup == null) {\n\t\t\tleaderGroup = new NioEventLoopGroup();\n\t\t\tleaderGroup = new NioEventLoopGroup();\n\t\t\tServerBootstrap bootstrap = new ServerBootstrap();\n\t\t\tbootstrap.group(leaderGroup, leaderGroup).channel(NioServerSocketChannel.class)\n\t\t\t\t.childHandler(new ChannelInitializer<SocketChannel>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void initChannel(SocketChannel ch) throws Exception {\n\t\t\t\t\t\tch.pipeline()\n\t\t\t\t\t\t\t.addLast(new LengthFieldBasedFrameDecoder(65536, 0, 4, 0, 0))\n\t\t\t\t\t\t\t.addLast(new RpcDecoder(RpcRequest.class))\n\t\t\t\t\t\t\t.addLast(new RpcEncoder(RpcResponse.class))\n\t\t\t\t\t\t\t.addLast(new RpcServerHandler(handlerMap));\n\t\t\t\t\t}\n\t\t\t\t}).option(ChannelOption.SO_BACKLOG, 128)\n\t\t\t\t.childOption(ChannelOption.SO_KEEPALIVE, true);\n.....................\npublic class RpcDecoder extends ByteToMessageDecoder {\n\n.....................\npublic class RpcRequest {\n\tprivate String requestId;\n\tprivate String className;\n\tprivate String methodName;\n\tprivate Class<?>[] parameterTypes;\n\tprivate Object[] parameters;\n}\npublic class RpcServerHandler extends SimpleChannelInboundHandler<RpcRequest>{ //由于是过滤了RpcRequest类型的inbound，所以其他类型的inbound会忽略，比如heartBeat\n\t\n\tprivate static final Logger logger = LoggerFactory.getLogger(RpcServerHandler.class);\n\t\n\tprivate final Map<String, Object> handlerMap;\n\t\n\tpublic RpcServerHandler(Map<String, Object> handlerMap) {\n\t\tthis.handlerMap = handlerMap;\n\t}\n\tprivate Object handle(RpcRequest request) throws Throwable{\n\t\n")])])]),n("h3",{attrs:{id:"同时支持http和tcp"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#同时支持http和tcp"}},[e._v("#")]),e._v(" 同时支持HTTP和TCP")]),e._v(" "),n("p",[e._v("自定义扩展 ChannelInboundHandlerAdapter")]),e._v(" "),n("p",[e._v("https://my.oschina.net/succy/blog/4724766")]),e._v(" "),n("disqus")],1)}),[],!1,null,null,null);t.default=r.exports}}]);