(window.webpackJsonp=window.webpackJsonp||[]).push([[163],{591:function(t,v,e){"use strict";e.r(v);var _=e(56),s=Object(_.a)({},(function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("https://www.tutorialspoint.com/assembly_programming/index.htm")]),t._v(" "),e("h2",{attrs:{id:"架构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#架构"}},[t._v("#")]),t._v(" 架构")]),t._v(" "),e("p",[t._v("Linux下查询命令")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("~$ arch\nx86_64\n")])])]),e("p",[t._v("x86架构 x64(x86_64) 高功耗计算机和服务器\nARM架构： 低功耗处理器 嵌入式系统")]),t._v(" "),e("p",[t._v("ARM既是指令集或架构又可指ARM处理器。")]),t._v(" "),e("p",[t._v("X86表示的是baiCPU指令集类型du。")]),t._v(" "),e("p",[t._v("x64全称”x86-64”也是CPU的指zhi令集类型。")]),t._v(" "),e("p",[t._v("ARM处理器是Acorn计算机有限公dao司面向低预算市场设计的第一款RISC微处理器。更早称作Acorn RISC Machine。ARM处理器本身是32位设计，但也配备16位指令集，一般来讲比等价32位代码节省达35%，却能保留32位系统的所有优势。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('X86是由Intel推出的一种复杂指令集，用于控制芯片的运行的程序，现在X86已经广泛运用到了家用PC领域。\n\n“x86-64”，有时会简称为“x64”，是64位微处理器架构及其相应指令集的一种，也是Intel x86架构的延伸产品。“x86-64”1999由AMD设计，AMD首次公开64位集以扩充给IA-32，称为x86-64（后来改名为AMD64）。其后也为英特尔所采用，现时英特尔称之为“Intel 64”，在之前曾使用过Clackamas Technology (CT)、IA-32e及EM64T。外界多使用"x86-64"或"x64"去称呼此64位架构，从而保持中立，不偏袒任何厂商。\n')])])]),e("p",[t._v("Amd64 i386 区别")]),t._v(" "),e("p",[e("strong",[t._v("i386")]),t._v(" 简单理解就是32位的版本，"),e("strong",[t._v("amd64")]),t._v(" 是64位的版本。 下载utunbu系统时，出现两个选项：ADM64和"),e("strong",[t._v("i386")]),t._v("，那么这两者的"),e("strong",[t._v("区别")]),t._v("是什么？ "),e("strong",[t._v("i386")]),t._v("=Intel 80386。 其实"),e("strong",[t._v("i386")]),t._v("通常被用来作为对Intel（英特尔）32位微处理器的统称")]),t._v(" "),e("h2",{attrs:{id:"寄存器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#寄存器"}},[t._v("#")]),t._v(" 寄存器")]),t._v(" "),e("p",[t._v("段地址 偏移地址")]),t._v(" "),e("p",[t._v("https://zhuanlan.zhihu.com/p/72016353")]),t._v(" "),e("p",[t._v("不同的CPU，寄存器的个数、结构是不相同的，8086CPU有14个寄存器，每个寄存器有一个名称，我们对它进行分类：")]),t._v(" "),e("p",[t._v("1． 通用寄存器：AX、BX、CX、DX")]),t._v(" "),e("p",[t._v("2． 段寄存器：CS、SS、DS、ES")]),t._v(" "),e("p",[t._v("3． 指针寄存器：SP、BP")]),t._v(" "),e("p",[t._v("4． 变址寄存器：SI、DI")]),t._v(" "),e("p",[t._v("5． 指令指针寄存器：IP")]),t._v(" "),e("p",[t._v("6． 标志寄存器：FR")]),t._v(" "),e("p",[t._v("以上寄存器都是16位的，更古老的CPU的寄存器是8位的，这个就不讲了。现在的CPU的寄存器是32位的")]),t._v(" "),e("p",[t._v('EAX 是"累加器"(accumulator), 它是很多加法乘法指令的缺省寄存器。')]),t._v(" "),e("p",[t._v('EBX 是"基地址"(base)寄存器, 在内存寻址时存放基地址。')]),t._v(" "),e("p",[t._v("ECX 是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。")]),t._v(" "),e("p",[t._v("EDX 则总是被用来放整数除法产生的余数。")]),t._v(" "),e("p",[t._v('ESI/EDI分别叫做"源/目标索引寄存器"(source/destination index),因为在很多字符串操作指令中, DS:ESI指向源串,而ES:EDI指向目标串.')]),t._v(" "),e("p",[t._v('EBP是"基址指针"(BASE POINTER), 它最经常被用作高级语言函数调用的"框架指针"(frame pointer). 在破解的时候,经常可以看见一个标准的函数起始代码:')]),t._v(" "),e("p",[t._v("https://blog.csdn.net/chenlycly/article/details/37912755")]),t._v(" "),e("p",[t._v("栈一次入栈数据 16位的倍数？ 一个栈地址不是对应一个字节数据吗？")]),t._v(" "),e("p",[t._v("出栈入栈都是以字节为单位的")]),t._v(" "),e("p",[t._v("https://bbs.csdn.net/topics/370193730")]),t._v(" "),e("p",[t._v("AT&T汇编语法：")]),t._v(" "),e("p",[t._v("mov  %esp,%ebp  是指esp寄存器的内容存入ebp")]),t._v(" "),e("p",[t._v("Intel汇编语法：")]),t._v(" "),e("p",[t._v("mov opd ops\t是将ops传送至opd")]),t._v(" "),e("p",[t._v("AX VS EAX 2字节 4字节")]),t._v(" "),e("p",[t._v("[] 代表寄存器的值所代表的内存地址对应的内容")]),t._v(" "),e("p",[t._v("堆栈地址")]),t._v(" "),e("p",[t._v("简单以windows为例")]),t._v(" "),e("p",[t._v("假设内存从0x00000000 0xFFFFFFFF，堆从0x00000000 往上增长，栈从0xFFFFFFFF往下增长，也是比较合理的设计；")]),t._v(" "),e("p",[t._v("https://blog.csdn.net/changyourmind/article/details/51839395")]),t._v(" "),e("p",[t._v("栈空间 增长方向 大端 小端")]),t._v(" "),e("p",[t._v("小端是第一个字节在高位，从高到低，跟栈的增长方向一致")]),t._v(" "),e("p",[t._v("虽然栈空间增长方向是从高（栈底）到低（栈顶），")]),t._v(" "),e("p",[t._v("但是")]),t._v(" "),e("p",[t._v("假设整个栈空间是 0xFFFFFFFF 到 0x00000000")]),t._v(" "),e("p",[t._v("父函数占用了空间 0x40000000 到 0x30000000")]),t._v(" "),e("p",[t._v("父函数分配给子函数栈空间，0012FFFC  到 00104000")]),t._v(" "),e("p",[t._v("从ollydbg cpu页面右下角的栈空间可以看到，返回到父函数地址是 30F0B5FB，该函数的")]),t._v(" "),e("p",[t._v("00123DA0   30F0B5FB  RETURN to mso.30F0B5FB\n00123DA4   012E07AC\t//参数一 源地址\n00123DA8   00123DC0 //参数二 目的地址\n00123DAC   00000000 //参数三")]),t._v(" "),e("p",[t._v("子函数内 使用 栈的方式肯定也是从高地址到低地址，")]),t._v(" "),e("p",[t._v("不过当从源地址复制到目的地址的时候，假设目的地址分配了8个字节，所以范围是[00123DC0, 00123DC7]")]),t._v(" "),e("p",[t._v("函数执行的时候写入还是从00123DC0开始写到00123DC7，这并不违背分配空间的时候还是从高地址到低地址；")]),t._v(" "),e("p",[t._v("更复杂的情况，比如子函数内调用其他函数都是类似的")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://bboyjing.github.io/2019/03/19/%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A4%A7%E3%80%81%E5%B0%8F%E7%AB%AF/",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://bboyjing.github.io/2019/03/19/%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A4%A7%E3%80%81%E5%B0%8F%E7%AB%AF/"),e("OutboundLink")],1)]),t._v(" "),e("div",{staticClass:"language-assembly extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("https://stackoverflow.com/questions/12234817/what-does-this-instruction-do-mov-gs0x14-eax\n\nmov    %gs:0x14,%eax\nit means reading 4 bytes into eax from memory at address gs:0x14. gs is a segment register. Most likely thread-local storage (AKA TLS) is referenced through this register. \n\nhttps://stackoverflow.com/questions/4228261/understanding-the-purpose-of-some-assembly-statements\nlea    -0x4(%ecx),%esp             ; esp := [ecx-4]\n\nxor    %eax,%eax  \nExplaining this requires some history of the X86 architecture\n\n\nhttps://stackoverflow.com/questions/19692418/x86-assembly-compare-with-null-terminated-array\ntest  cl, cl                ; will be zero when NUL\n\nEB 06 之后，跳转到6字节之后\n\n")])])])])}),[],!1,null,null,null);v.default=s.exports}}]);