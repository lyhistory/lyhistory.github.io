(window.webpackJsonp=window.webpackJsonp||[]).push([[309],{736:function(e,t,a){"use strict";a.r(t);var n=a(65),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("前端必读：浏览器内部工作原理 https://kb.cnblogs.com/page/129756/")]),e._v(" "),a("p",[e._v("尼尔森十大原则")]),e._v(" "),a("p",[e._v("尼尔森十大原则由毕业于哥本哈根的人机交互学博士Jakob Nielsen发表，Jakob Nielsen对人机交互有很多研究，他提出十大可用性原则，用来评价用户体验的好坏，每个产品设计者都可以根据这十大原则进行自查。\n（1）系统可见性原则（Visibility of system status）\n保持界面的状态可见，变化可见，内容可见。让用户知道发生了什么，在适当的时间内做出适当的反馈。 比如用户在网页上的任何操作，不论是单击、滚动还是按下键盘，页面应即时给出反馈。\n（2）贴近场景原则（Match between system and the real world）\n用用户的语言，用词，短语和用户熟悉的概念，而不是系统术语。功能操作符合用户的使用场景。\n（3）可控性原则（User control and freedom）\n用户经常错误地选择系统功能而且需要明确标识离开这个的“出口”。比如支持撤销和重做的功能。\n（4）一致性和标准化原则（Consistency and standards）\n遵循平台的惯例。也就是，同一用语、功能、操作保持一致。\n（5）防错原则（Error prevention）\n更用心的设计防止这类问题发生，在用户可能犯错时进行提醒，比如删除可能造成的后果。\n（6）协助记忆原则（Recognition rather than recall）\n尽量减少用户对操作目标的记忆负荷，动作和选项都应该是可见的。用户不必记住一个页面到另一个页面的信息。系统的使用说明应该是可见的或者是容易获取的。\n（7）灵活高效原则（Flexibility and efficiency of use）\n允许用户进行频繁的操作。 更加便捷灵活的代码和反馈.\n（8）审美和简约设计原则（Aesthetic and minimalist design）\n不应该包含无关紧要的信息。\n（9）容错原则（Help users recognize, diagnose, and recover from errors ）\n错误信息应该用语言表达（不要用代码），较准确地反应问题所在，并且提出一个建设性的解决方案。比如404。\n（10）人性化帮助原则（Help and documentation）\n有必要提供帮助和文档。任何信息应容易去搜索，专注于用户的任务，列出具体的步骤来进行。帮助性提示最好的方式是：1、无需提示；2、一次性提示；3、常驻提示；4；帮助文档。")]),e._v(" "),a("h2",{attrs:{id:"背景探测"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#背景探测"}},[e._v("#")]),e._v(" 背景探测")]),e._v(" "),a("p",[e._v("线框 Wireframe ，低保真（草稿） 到 高保真（原型图）")]),e._v(" "),a("h3",{attrs:{id:"css"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css"}},[e._v("#")]),e._v(" CSS")]),e._v(" "),a("p",[e._v("css position")]),e._v(" "),a("ol",[a("li",[e._v("Center 居中问题")])]),e._v(" "),a("p",[e._v("a.div里面的内容居中，如果里面是inline，需要display block，然后margin left right auto")]),e._v(" "),a("p",[e._v("b.图片与文字并排居中")]),e._v(" "),a("p",[e._v("1、单独文字垂直居中我们只需要设置CSS样式line-height属性即可。")]),e._v(" "),a("p",[e._v("2、文字与图片同排，在设置div高度同时再对此css样式的图片“img”样式设置vertical-align:middle垂直居中属性")]),e._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[e._v("Render")])]),e._v(" "),a("p",[e._v("a.float要设置width，如果float元素是无法撑开parent高度的，所以parent需要设置height")]),e._v(" "),a("p",[e._v("b.relative里面的absolute，float的元素只能撑开float类型的parent")]),e._v(" "),a("p",[e._v("c.a这样的inline elements如果加上background img，如果内部没有内容text，给宽度都是没用的，不会显示出来，应该加上padding，内容才会出来")]),e._v(" "),a("p",[e._v("3.Font")]),e._v(" "),a("p",[e._v("why? 我们经常会在比如bootstrap中用到伪元素::before :: after{content:'\\ff01';}，伪元素不会改变document，只是通过更换样式改变最终的呈现效果，这种理念很好，也减轻了页面load的负担")]),e._v(" "),a("p",[e._v("4.Events Receiver")]),e._v(" "),a("p",[e._v("CSS pointer-Events To Allow Clicks On Underlying Elements")]),e._v(" "),a("p",[e._v("https://robertnyman.com/2010/03/22/css-pointer-events-to-allow-clicks-on-underlying-elements/")]),e._v(" "),a("h3",{attrs:{id:"js"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js"}},[e._v("#")]),e._v(" js")]),e._v(" "),a("h4",{attrs:{id:"闭包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[e._v("#")]),e._v(" 闭包：")]),e._v(" "),a("p",[e._v("In computer science, a closure is a function that has an environment of its own and at least one variable within that environment.")]),e._v(" "),a("p",[e._v("A function exists in and has access to the global scope. Anything declared within that function also has access to the global scope, even though it exists inside its own "),a("em",[e._v("function scope")]),e._v(".")]),e._v(" "),a("p",[e._v("Within a written program, the scope of each variable is linked together through what is referred to as the "),a("em",[e._v("scope chain")]),e._v(", with global scope always sitting at the top of the chain.")]),e._v(" "),a("p",[e._v("The JavaScript compiler traverses this chain. However, the compiler is like a car that only runs in reverse, never forward.")]),e._v(" "),a("p",[e._v("When a variable is used, the compiler travels back up the scope chain until it finds an entry for that variable.")]),e._v(" "),a("p",[e._v("Closure only provides access from inner to outer scope, not from outer to inner scope.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function encourage() {\n const positivity = 'You got this!';\n}\n// positivity has function scope\n{\n const negativity = 'I don't got this.';\n}\n// negativity has block scope\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function a(){\n    var i=0;\n    function b(){\n    \talert(++i);\n\t}\n\treturn b;\n}\nvar c=a();\nc();\n\n这段代码有两个特点：\n1、函数b嵌套在函数a内部；\n2、函数a返回函数b。\n这样在执行完var c=a( )后，变量c实际上是指向了函数b，再执行c( )后就会弹出一个窗口显示i的值（第一次为1）。这段代码其实就创建了一个闭包，这是因为函数a外的变量c引用了函数a内的函数b。也就是说，当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包。\n简而言之，闭包的作用就是在a执行完并返回后，闭包使得Javascript的垃圾回收机制不会收回a所占用的资源，因为a的内部函数b的执行需要依赖a中的变量。\n在上面的例子中，由于闭包的存在使得函数a返回后，a中的i始终存在，这样每次执行c()，i都是自加1后alert出i的值。\n那 么我们来想象另一种情况，如果a返回的不是函数b，情况就完全不同了。因为a执行完后，b没有被返回给a的外界，只是被a所引用，而此时a也只会被b引 用，因此函数a和b互相引用但又不被外界打扰（被外界引用），函数a和b就会被回收。\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('var a = 1;\n\nfunction test(){\n\tvar a = 2;\n\tconsole.log("test a="+a);\n}\n\ntest();\n\nconsole.log("global a="+a);\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('for (var i = 0; i < 5; ++i) {\n  setTimeout(function() {\n    console.log(i + " ");\n  }, 100);\n}\n输出结果为 5 5 5 5 5\n\nfor (var i = 0; i < 5; ++i) {\n  (function(i) {\n    setTimeout(function() {\n      console.log(i + " ");\n    }, 100);\n  })(i);\n}\n输出结果为： 0 1 2 3 4\n')])])]),a("h4",{attrs:{id:"元素事件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#元素事件"}},[e._v("#")]),e._v(" 元素事件")]),e._v(" "),a("p",[e._v("table right click")]),e._v(" "),a("h3",{attrs:{id:"jquery"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jquery"}},[e._v("#")]),e._v(" jquery")]),e._v(" "),a("p",[e._v("ready vs onload")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("ready")]),e._v(" event occurs after the HTML document has been loaded, while the "),a("code",[e._v("onload")]),e._v(" event occurs later, when all content (e.g. images) also has been loaded.")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("onload")]),e._v(" event is a standard event in the DOM, while the "),a("code",[e._v("ready")]),e._v(" event is specific to jQuery. The purpose of the "),a("code",[e._v("ready")]),e._v(" event is that it should occur as early as possible after the document has loaded, so that code that adds functionality to the elements in the page doesn't have to wait for all content to load.")]),e._v(" "),a("h3",{attrs:{id:"framework"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#framework"}},[e._v("#")]),e._v(" Framework:")]),e._v(" "),a("p",[e._v("jquery template")]),e._v(" "),a("p",[e._v("Bootstrap")]),e._v(" "),a("p",[e._v("antd")]),e._v(" "),a("h2",{attrs:{id:"reactjs-mobx"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reactjs-mobx"}},[e._v("#")]),e._v(" reactjs+mobx")]),e._v(" "),a("p",[e._v("virtual dom：https://zhenyong.github.io/react/docs/glossary.html")]),e._v(" "),a("p",[e._v("如何操作比如 （各种reactdom api）")]),e._v(" "),a("p",[e._v("创建element")]),e._v(" "),a("p",[e._v("获取element，getElementById？")]),e._v(" "),a("p",[e._v("法一：")]),e._v(" "),a("p",[a("code",[e._v("<input refs value={this.state.input} onchange={setState}/>")])]),e._v(" "),a("p",[e._v("法二：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<input type="submit" className="nameInput" id="name" value="cp-dev1" onClick={this.writeData} ref = "cpDev1"/>\n\n  componentDidMount: function(){\n    var name = React.findDOMNode(this.refs.cpDev1).value;\n    this.someOtherFunction(name);\n  }\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" <button className=\"square\" onClick={() => alert('click')}>\n       {this.props.value}\n     </button>\n VS:  \n  <button className=\"square\" onClick={alert('click')}>\n       {this.props.value}\n     </button>\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("普通模式：\nexport defalt <classname>;\n单例模式\nconst store = new BirdStore();\nexport default store;\n")])])]),a("p",[e._v("mobx作用")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("+ Use the @observable decorator or observable(object or array) functions to make objects trackable for MobX.\n+ The @computed decorator can be used to create functions that can automatically derive their value from the state.\n+ Use autorun to automatically run functions that depend on some observable state. This is useful for logging, making network requests, etc.\n+ reactions\n  will not fire initially, only on change\n+ transactions\n+ actions\n  strict mode: only allow data modified in actions\n")])])]),a("h2",{attrs:{id:"前端性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端性能优化"}},[e._v("#")]),e._v(" 前端性能优化")]),e._v(" "),a("p",[e._v("页面重绘；")]),e._v(" "),a("p",[e._v("静态页面 cache；")]),e._v(" "),a("p",[e._v("压缩css js")]),e._v(" "),a("p",[e._v("图片：icon：image sprite，大图 压缩+lazy load")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("20 种提升网页速度的技巧 https://www.ibm.com/developerworks/cn/web/wa-speedweb/\n\nAMP，来自 Google 的移动页面优化方案 https://imququ.com/post/amp-project.html\n\nweb 页面加载速度优化实战-100% 的飞跃提升 http://blog.csdn.net/hj7jay/article/details/52770285\n\n\n虽然是静态页面，也需要好好打磨一下，你用谷歌浏览器或者其他测速的工具，观察每个resource下载的速度\n\ncss js 图片 整个页面\n\n首先几点基本要求：\n\n1.css放到顶部，js放到底部，减少页面重绘，因为页面先加载css 浏览器就知道根据css去绘制html而不是先绘制 然后发现css后重绘\n\n2.html页面标签启用cache(加metatag）http://www.i18nguy.com/markup/metatags.html\n\n尤其静态页面 明确让浏览器使用cache\n\n3.压缩css和js，很多工具，自己查下，设置很多在线工具可以用\n\n4.图片问题，这里强调的是大图背景的使用策略\n\na.首先是优化，用这个在线工具做优化 https://kraken.io/web-interface\n\n\nb.在避免不了的情况下，我们这个是pc版的还好，如果需要支持手机版，就不能再加载大图了，可以这样玩\n\nbody {\n\nbackground: #ABCDEF url(largeBackground.jpg);\n\n}\n\n@media screen and (max-width: 640px){\n\nbody {\n\n/* option 1: remove background altogether */\n\nbackground: #fff;\n\n/* option 2: serve a much smaller background */\n\nbackground: #ABCDEF url(muchSmallerBackground.jpg);\n\n}\n\n\nc.理想的情况下，所有的大图应该使用lazy load，很多插件可以考虑\n\nd.对于琐碎的小图（工具图，比如关闭叉，提示icon等），应该做成一张大图，然后再页面上采用位移的方式显示\n\nimage sprite https://li-xinyang.gitbooks.io/frontend-notebook/content/chapter1/01_05_image_optimisation.html\n\n上面说的是一些基本考虑，你根据需要相应采用，目的就是提高加载速度，减少资源请求次数（请求两次css就要建立两个http链接，不如两个css文件压缩到一个文件，压缩可以去掉空行，空格，降低文件的大小）\n")])])]),a("p",[e._v("chart example:\nhttps://github.com/jonchurch/tradingview-js-api-tutorial/tree/master")]),e._v(" "),a("disqus")],1)}),[],!1,null,null,null);t.default=s.exports}}]);