(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{291:function(t,n,e){"use strict";e.r(n);var a=e(0),o=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[e("a",{attrs:{href:"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-documentation",target:"_blank",rel:"noopener noreferrer"}},[t._v("official documents"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("自动配置、起步依赖、Actuator、命令行界面(CLI) 是Spring Boot最重要的4大核心特性")]),t._v(" "),e("h2",{attrs:{id:"_1-知识点overview"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-知识点overview"}},[t._v("#")]),t._v(" 1.知识点Overview")]),t._v(" "),e("h3",{attrs:{id:"_1-1-spring-ioc容器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-spring-ioc容器"}},[t._v("#")]),t._v(" 1.1 Spring IoC容器")]),t._v(" "),e("p",[t._v("IoC容器是大管家，你只需要告诉它需要某个bean，它就把对应的实例（instance）扔给你，至于这个bean是否依赖其他组件，怎样完成它的初始化，根本就不需要你关心。")]),t._v(" "),e("p",[t._v("bean是什么？")]),t._v(" "),e("blockquote",[e("p",[t._v("The objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container.\nhttps://www.tutorialspoint.com/spring/spring_bean_definition.htm")])]),t._v(" "),e("p",[t._v("IoC容器想要管理各个业务对象以及它们之间的依赖关系，需要通过某种途径来记录和管理这些信息。\nBeanDefinition对象就承担了这个责任：容器中的每一个bean都会有一个对应的BeanDefinition实例，该实例负责保存bean对象的所有必要信息，包括bean对象的class类型、是否是抽象类、构造方法和参数、其它属性等等。\n当客户端向容器请求相应对象时，容器就会通过这些信息为客户端返回一个完整可用的bean实例；\n默认是单例模式；")]),t._v(" "),e("p",[t._v("事先这些bean需要向大管家注册，BeanDefinitionRegistry抽象出bean的注册逻辑，BeanFactory则抽象出了bean的管理逻辑，而各个BeanFactory的实现类就具体承担了bean的注册以及管理工作\n然后大管家生成bean也是通过这个工厂模式；\nDefaultListableBeanFactory作为一个比较通用的BeanFactory实现，它同时也实现了BeanDefinitionRegistry接口，因此它就承担了Bean的注册管理工作，\n具体的beanFactory实现类就是实现了DefaultListableBeanFactory这个接口；")]),t._v(" "),e("p",[e("img",{attrs:{src:"/docs/docs_image/software/java/spring/java_spring_bean01.png",alt:"spring揭秘"}})]),t._v(" "),e("p",[t._v("Spring提供了两种容器类型：BeanFactory和ApplicationContext：")]),t._v(" "),e("p",[e("img",{attrs:{src:"/docs/docs_image/software/java/spring/java_spring_bean02.png",alt:"spring揭秘"}})]),t._v(" "),e("p",[e("strong",[t._v("Spring IoC容器的整个工作流程大致可以分为两个阶段：")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("容器启动阶段")]),t._v(" "),e("p",[t._v("容器启动时，会通过某种途径加载 ConfigurationMetaData，\nConfigurationMetaData可能定义在代码中，比如注解方式，也可能在在外部配置文件(XML/Properties)中，\n，容器需要依赖某些工具类如BeanDefinitionReader，BeanDefinitionReader会对加载的 ConfigurationMetaData进行解析和分析，并将分析后的信息组装为相应的BeanDefinition，\n最后把这些保存了bean定义的BeanDefinition，注册到相应的BeanDefinitionRegistry，\n这样容器的启动工作就完成了。")])]),t._v(" "),e("li",[e("p",[t._v("Bean的实例化阶段")]),t._v(" "),e("p",[t._v("这个阶段触发是:当某个请求通过容器的getBean方法请求某个对象，或者因为依赖关系容器需要隐式的调用getBean时（如bean的注解@DependsOn 或者Autowired）;\n容器会首先检查所请求的对象之前是否已经实例化完成。如果没有，则会根据注册的BeanDefinition所提供的信息实例化被请求对象，并为其注入依赖。当该对象装配完毕后，容器会立即将其返回给请求方法使用。")]),t._v(" "),e("p",[e("em",[t._v("Notes:Autowire vs getbean")])]),t._v(" "),e("blockquote",[e("p",[t._v("Injecting a Prototype Bean into a Singleton Bean Problem https://www.logicbig.com/tutorials/spring-framework/spring-core/injecting-singleton-with-prototype-bean.html")])]),t._v(" "),e("blockquote",[e("p",[t._v("You can then use getBean to retrieve instances of your beans. The ApplicationContext interface has a few other methods for retrieving beans, but, ideally, your application code should never use them. Indeed, your application code should have no calls to the getBean() method at all and thus have no dependency on Spring APIs at all.\nhttps://docs.spring.io/spring/docs/current/spring-framework-reference/core.html")])]),t._v(" "),e("p",[t._v("BeanFactory只是Spring IoC容器的一种实现，如果没有特殊指定，它采用采用延迟初始化策略：只有当访问容器中的某个对象时，才对该对象进行初始化和依赖注入操作。\n对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的IoC容器选择。")]),t._v(" "),e("p",[t._v("而在实际场景下，我们更多的使用另外一种类型的容器： ApplicationContext，它构建在BeanFactory之上，属于更高级的容器，除了具有BeanFactory的所有能力之外，还提供对事件监听机制以及国际化的支持等。它管理的bean，在容器启动时全部完成初始化和依赖注入操作。\nApplicationContext所管理的对象，在该类型容器启动之后，默认全部初始化并绑定完成。所以，相对于BeanFactory来说，ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容器启动时间较之BeanFactory也会长一些。\n在那些系统资源充足，并且要求更多功能的场景中，ApplicationContext类型的容器是比较合适的选择。")])])]),t._v(" "),e("p",[e("strong",[t._v("bean生命周期接口")])]),t._v(" "),e("p",[t._v("IoC容器负责管理容器中所有bean的生命周期，而在bean生命周期的不同阶段，Spring提供了不同的扩展点来改变bean的命运，例如EnvironmentPostProcessor、BeanFactoryPostProcessor等（具体参照：第2节 SpringApplication启动流程）:")]),t._v(" "),e("p",[e("strong",[t._v("单例模式")])]),t._v(" "),e("p",[t._v("spring boot默认bean是单例的，spring mvc默认的servlet也是单例的，当然bean @Controller也是单例的，多线程体现在httpservletrequest本身是线程间互相隔离的，\n一般都是通过ThreadLocal实现，\n之所以默认单例是因为，springboot本身就是ioc容器，启动过程很长，启动时会实例化加载bean（当然也有lazy模式），bean的实例化通常需要读取配置文件或者有很多其他bean的依赖，\n所以每次都重建销毁性能很差，而且浪费内存；\nhttps://stackoverflow.com/questions/10096483/is-threadlocal-preferable-to-httpservletrequest-setattributekey-value")]),t._v(" "),e("p",[t._v("单例就是为了共享从而减少内存开销，多线程就是为了区别每个线程的上下文或者working thread context，所以线程上下文一定不能被共享，\n比如ThreadLocal不能跟ExecutorService共用，就是因为ExecutorService破坏了线程间的隔离\nDo Not Use ThreadLocal With ExecutorService\nhttps://www.baeldung.com/java-threadlocal\nhttps://www.cnblogs.com/MrSaver/p/11191028.html")]),t._v(" "),e("p",[t._v("单例模式 工厂模式 建造者模式")]),t._v(" "),e("blockquote",[e("p",[t._v("Spring单例Bean与单例模式的区别在于它们关联的环境不一样，单例模式是指在一个JVM进程中仅有一个实例，而Spring单例是指一个Spring Bean容器(ApplicationContext)中仅有一个实例。\n首先看单例模式，在一个JVM进程中（理论上，一个运行的JAVA程序就必定有自己一个独立的JVM）仅有一个实例，于是无论在程序中的何处获取实例，始终都返回同一个对象，以Java内置的Runtime为例（现在枚举是单例模式的最佳实践），无论何时何处获取，下面的判断始终为真：\nRuntime.getRuntime() == Runtime.getRuntime()\n与此相比，Spring的单例Bean是与其容器（ApplicationContext）密切相关的，所以在一个JVM进程中，如果有多个Spring容器，即使是单例bean，也一定会创建多个实例，代码示例如下：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('//  第一个Spring Bean容器\nApplicationContext context_1 = new FileSystemXmlApplicationContext("classpath:/ApplicationContext.xml");\nPerson yiifaa_1 = context_1.getBean("yiifaa", Person.class);\n//  第二个Spring Bean容器\nApplicationContext context_2 = new FileSystemXmlApplicationContext("classpath:/ApplicationContext.xml");\nPerson yiifaa_2 = context_2.getBean("yiifaa", Person.class);\n//  这里绝对不会相等，因为创建了多个实例\nSystem.out.println(yiifaa_1 == yiifaa_2);\n\n\x3c!-- 即使声明了为单例，只要有多个容器，也一定会创建多个实例 --\x3e\n<bean id="yiifaa" class="com.stixu.anno.Person" scope="singleton">\n    <constructor-arg name="username">\n        <value>yiifaa</value>\n    </constructor-arg>\n</bean>\n')])])]),e("blockquote",[e("p",[t._v("https://blog.csdn.net/yiifaa/java/article/details/74852425")])]),t._v(" "),e("h3",{attrs:{id:"_1-2-javaconfig与常见annotation"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-javaconfig与常见annotation"}},[t._v("#")]),t._v(" 1.2. JavaConfig与常见Annotation")]),t._v(" "),e("p",[e("strong",[t._v("1.2.1. JavaConfig")])]),t._v(" "),e("p",[t._v("@SpringBootApplication 等同于 @EnableAutoConfiguration + @ComponentScan + @Configuration, 后面启动原理部分有详解")]),t._v(" "),e("p",[t._v("All of your application components (@Component, @Service, @Repository, @Controller etc.) are automatically registered as Spring Beans.")]),t._v(" "),e("p",[t._v("Components(@Component @Service @Controller @Repository) VS Beans (@Beans):\nall component types are treated in the same way. The subtypes are mere markers, think code readability rather than features.\nhttps://www.tomaszezula.com/2014/02/09/spring-series-part-5-component-vs-bean/")]),t._v(" "),e("p",[e("strong",[t._v("1.2.2. @ComponentScan")])]),t._v(" "),e("p",[e("strong",[t._v("1.2.3. @Import")])]),t._v(" "),e("p",[t._v("在4.2之前， @Import注解只支持导入配置类，但是在4.2之后，它支持导入普通类")]),t._v(" "),e("p",[e("strong",[t._v("1.2.4. @Conditional @ConditionalOn*")])]),t._v(" "),e("p",[t._v("表示在满足某种条件后才初始化一个bean或者启用某些配置。它一般用在由 @Component、 @Service、 @Configuration等注解标识的类上面，或者由 @Bean标记的方法上。如果一个 @Configuration类标记了 @Conditional，则该类中所有标识了 @Bean的方法和 @Import注解导入的相关类将遵从这些条件。")]),t._v(" "),e("p",[e("strong",[t._v("1.2.5. @ConfigurationProperties与@EnableConfigurationProperties")])]),t._v(" "),e("p",[t._v("当某些属性的值需要配置的时候，我们一般会在 application.properties文件中新建配置项，然后在bean中使用 @Value注解来获取配置的值;")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('@Configuration\npublic class MyBatisConfiguration { \n\t@Value("${spring.datasource.driverClassName}")\n    private String jdbcDriverClassName;\n\t@Value("${spring.datasource.url}")\n    private String jdbcUrl;\n    @Value("${spring.datasource.username}")\n    private String jdbcUsername;\n    @Value("${spring.datasource.password}")\n    private String jdbcPassword;\n    \n\t@Bean(name = "dataSource",destroyMethod = "close")\n    public DataSource dataSource() {\n    \tDruidDataSource datasource = new DruidDataSource();\n    \tdatasource.setDriverClassName(jdbcDriverClassName);\n    \tdatasource.setUrl(jdbcUrl);\n    \tdatasource.setUsername(jdbcUsername);\n    \tdatasource.setPassword(jdbcPassword);\n        return datasource;\n    }\n\t\n\t@Bean(name = {"sqlSessionFactory"})\n\t@ConditionalOnMissingBean(name = {"sqlSessionFactory"})\n\tpublic SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {\n\t....\n')])])]),e("p",[t._v("但是如果同一个配置在多个地方使用，也存在不方便维护的问题，对于更为复杂的配置，Spring Boot提供了更优雅的实现方式，那就是 @ConfigurationProperties注解\n而@EnableConfigurationProperties的作用是将其注册为bean，否则项目不会将其scan为bean，具体：")]),t._v(" "),e("blockquote",[e("p",[t._v("In order to use a configuration class in our project, we need to register it as a regular Spring bean.")])]),t._v(" "),e("blockquote",[e("p",[t._v("First of all, we can annotate such a class with @Component. Alternatively, we can use a @Bean factory method.")])]),t._v(" "),e("blockquote",[e("p",[t._v("However, "),e("strong",[t._v("in certain situations, we may prefer to keep a @ConfigurationProperties class as a simple POJO")]),t._v(". This is when @EnableConfigurationProperties comes in handy. We can specify all configuration beans directly on this annotation.")])]),t._v(" "),e("blockquote",[e("p",[t._v("This is a convenient way to quickly register @ConfigurationProperties annotated beans.")])]),t._v(" "),e("p",[t._v("通过上面等表述，我们大概知道，如果用@component就会将其变成增强类，而不是plain old java object了，而是多了很多冗余的功能；")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('@ConfigurationProperties(prefix = "additional")\npublic class AdditionalProperties {\n \n    private String unit;\n    private int max;\n \n    // standard getters and setters\n}\n@Configuration\n@EnableConfigurationProperties(AdditionalProperties.class)\npublic class AdditionalConfiguration {\n     \n    @Autowired\n    private AdditionalProperties additionalProperties;\n     \n    // make use of the bound properties\n}\n')])])]),e("p",[e("strong",[t._v("1.2.6 配置属性加载顺序")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('1、开发者工具 `Devtools` 全局配置参数；\n\n2、单元测试上的 `@TestPropertySource` 注解指定的参数；\n\n3、单元测试上的 `@SpringBootTest` 注解指定的参数；\n\n4、命令行指定的参数，如 `java -jar springboot.jar --name="Java技术栈"`；\n\n5、命令行中的 `SPRING_APPLICATION_JSONJSON` 指定参数, 如 `java -Dspring.application.json=\'{"name":"Java技术栈"}\' -jar springboot.jar`\n\n6、`ServletConfig` 初始化参数；\n\n7、`ServletContext` 初始化参数；\n\n8、JNDI参数（如 `java:comp/env/spring.application.json`）；\n\n9、Java系统参数（来源：`System.getProperties()`）；\n\n10、操作系统环境变量参数；\n\n11、`RandomValuePropertySource` 随机数，仅匹配：`ramdom.*`；\n\n12、JAR包外面的配置文件参数（`application-{profile}.properties（YAML）`）\n\n13、JAR包里面的配置文件参数（`application-{profile}.properties（YAML）`）\n\n14、JAR包外面的配置文件参数（`application.properties（YAML）`）\n\n15、JAR包里面的配置文件参数（`application.properties（YAML）`）\n\n16、`@Configuration`配置文件上 `@PropertySource` 注解加载的参数；\n\n17、默认参数（通过 `SpringApplication.setDefaultProperties` 指定）；\n')])])]),e("h3",{attrs:{id:"_1-3-启动加载器-springfactoriesloader"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-启动加载器-springfactoriesloader"}},[t._v("#")]),t._v(" 1.3. 启动加载器 SpringFactoriesLoader")]),t._v(" "),e("p",[t._v("JVM提供了3种类加载器： BootstrapClassLoader、 ExtClassLoader、 AppClassLoader分别加载Java核心类库、扩展类库以及应用的类路径( CLASSPATH)下的类库。JVM通过双亲委派模型进行类的加载，我们也可以通过继承 java.lang.classloader实现自己的类加载器。")]),t._v(" "),e("p",[t._v("何为双亲委派模型？当一个类加载器收到类加载任务时，会先交给自己的父加载器去完成，因此最终加载任务都会传递到最顶层的BootstrapClassLoader，只有当父加载器无法完成加载任务时，才会尝试自己来加载。")]),t._v(" "),e("p",[t._v("采用双亲委派模型的一个好处是保证使用不同类加载器最终得到的都是同一个对象，这样就可以保证Java 核心库的类型安全，比如，加载位于rt.jar包中的 java.lang.Object类，不管是哪个加载器加载这个类，最终都是委托给顶层的BootstrapClassLoader来加载的，这样就可以保证任何的类加载器最终得到的都是同样一个Object对象。")]),t._v(" "),e("p",[t._v("SpringFactoriesLoader，它本质上属于Spring框架私有的一种扩展方案，类似于SPI，Spring Boot在Spring基础上的很多核心功能都是基于此")]),t._v(" "),e("h3",{attrs:{id:"_1-4-spring容器的事件监听机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-spring容器的事件监听机制"}},[t._v("#")]),t._v(" 1.4. Spring容器的事件监听机制")]),t._v(" "),e("p",[t._v("Java提供了实现事件监听机制的两个基础类：自定义事件类型扩展自 java.util.EventObject、事件的监听器扩展自 java.util.EventListener")]),t._v(" "),e("p",[t._v("Spring的ApplicationContext容器内部中的所有事件类型均继承自 org.springframework.context.AppliationEvent，容器中的所有监听器都实现 org.springframework.context.ApplicationListener接口，并且以bean的形式注册在容器中。一旦在容器内发布ApplicationEvent及其子类型的事件，注册到容器的ApplicationListener就会对这些事件进行处理。")]),t._v(" "),e("p",[t._v("ApplicationEvent继承自EventObject，Spring提供了一些默认的实现，比如： ContextClosedEvent表示容器在即将关闭时发布的事件类型， ContextRefreshedEvent表示容器在初始化或者刷新的时候发布的事件类型......")]),t._v(" "),e("p",[t._v("容器内部使用ApplicationListener作为事件监听器接口定义，它继承自EventListener。ApplicationContext容器在启动时，会自动识别并加载EventListener类型的bean，一旦容器内有事件发布，将通知这些注册到容器的EventListener。")]),t._v(" "),e("p",[t._v("ApplicationContext接口继承了ApplicationEventPublisher接口，该接口提供了 voidpublishEvent(ApplicationEventevent)方法定义，不难看出，ApplicationContext容器担当的就是事件发布者的角色。如果有兴趣可以查看 AbstractApplicationContext.publishEvent(ApplicationEventevent)方法的源码：ApplicationContext将事件的发布以及监听器的管理工作委托给 ApplicationEventMulticaster接口的实现类。在容器启动时，会检查容器内是否存在名为applicationEventMulticaster的ApplicationEventMulticaster对象实例。如果有就使用其提供的实现，没有就默认初始化一个SimpleApplicationEventMulticaster作为实现。")]),t._v(" "),e("p",[t._v("最后，如果我们业务需要在容器内部发布事件，只需要为其注入ApplicationEventPublisher依赖即可：实现ApplicationEventPublisherAware接口或者ApplicationContextAware接口")]),t._v(" "),e("h3",{attrs:{id:"_1-5-自动配置原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-自动配置原理"}},[t._v("#")]),t._v(" 1.5. 自动配置原理")]),t._v(" "),e("p",[t._v("@SpringBootApplication开启"),e("strong",[t._v("组件扫描和自动配置")]),t._v("，\n而 SpringApplication.run则负责"),e("strong",[t._v("启动引导应用程序")]),t._v("。 @SpringBootApplication是一个复合 Annotation，它将三个注解组合在一起：")]),t._v(" "),e("ul",[e("li",[e("p",[e("strong",[t._v("@SpringBootConfiguration")]),t._v("就是 @Configuration，它是Spring框架的注解，标明该类是一个 JavaConfig配置类; allow to register extra beans in the context or import additional configuration classes;")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("@ComponentScan")]),t._v("启用组件扫描;enable @Component scan on the package where the application is located;")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("@EnableAutoConfiguration")]),t._v("注解：\n表示开启Spring Boot自动配置功能，Spring Boot会根据应用的依赖、自定义的bean、classpath下有没有某个类 等等因素来猜测你需要的bean，然后注册到IOC容器中;\nenable "),e("a",{attrs:{href:"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-auto-configuration",target:"_blank",rel:"noopener noreferrer"}},[t._v("Spring Boot’s auto-configuration mechanism"),e("OutboundLink")],1)])])]),t._v(" "),e("p",[e("em",[t._v("Notes:")])]),t._v(" "),e("blockquote",[e("p",[t._v("You should only ever add one @SpringBootApplication or @EnableAutoConfiguration annotation. We generally recommend that you add one or the other to your primary @Configuration class only.\nhttps://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-auto-configuration")])]),t._v(" "),e("p",[t._v("开始讲解原理，先看EnableAutoConfiguration：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("@Target(value=TYPE)\n @Retention(value=RUNTIME)\n @Documented\n @Inherited\n @AutoConfigurationPackage\n @Import(value=AutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration\n")])])]),e("p",[t._v("重点是@Import(EnableAutoConfigurationImportSelector.class)，这里它将把 EnableAutoConfigurationImportSelector作为bean注入到容器中，")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("@Override\n\tpublic String[] selectImports(AnnotationMetadata metadata) {\n\t\ttry {\n\t\t\tAnnotationAttributes attributes = getAttributes(metadata);\n\t\t\tList<String> configurations = getCandidateConfigurations(metadata,\n\t\t\t\t\tattributes);\n\t\t\tconfigurations = removeDuplicates(configurations);\n\t\t\tSet<String> exclusions = getExclusions(metadata, attributes);\n\t\t\tconfigurations.removeAll(exclusions);\n\t\t\tconfigurations = sort(configurations);\n\t\t\trecordWithConditionEvaluationReport(configurations, exclusions);\n\t\t\treturn configurations.toArray(new String[configurations.size()]);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalStateException(ex);\n\t\t}\n\t}\n")])])]),e("p",[t._v("EnableAutoConfigurationImportSelector.selectImports()是何时执行的？其实这个方法会在容器启动过程中执行： AbstractApplicationContext.refresh(),\n这个EnableAutoConfigurationImportSelector类会扫描所有的jar包，将所有符合条件的@Configuration配置类注入的容器中，何为符合条件，看看 META-INF/spring.factories的文件内容：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories\n.....\norg.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\\n.....\n")])])]),e("p",[t._v("然后举例看 DataSourceAutoConfiguration：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceAutoConfiguration.java\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })\n@ConditionalOnMissingBean(type = "io.r2dbc.spi.ConnectionFactory")\n@EnableConfigurationProperties(DataSourceProperties.class)\n@Import({ DataSourcePoolMetadataProvidersConfiguration.class, DataSourceInitializationConfiguration.class })\npublic class DataSourceAutoConfiguration {\n')])])]),e("p",[t._v("@ConditionalOnClass({DataSource.class,EmbeddedDatabaseType.class})：当Classpath中存在DataSource或者EmbeddedDatabaseType类时才启用这个配置，否则这个配置将被忽略。\n注意上面的DataSourceProperties，\n@EnableConfigurationProperties(DataSourceProperties.class)：将DataSource的默认配置类注入到IOC容器中，DataSourceproperties定义为：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('@ConfigurationProperties(prefix = "spring.datasource")\npublic class DataSourceProperties implements BeanClassLoaderAware, InitializingBean {\n\tprivate ClassLoader classLoader;\n\t/**\n\t * Name of the datasource. Default to "testdb" when using an embedded database.\n\t */\n\tprivate String name;\n\t/**\n\t * Whether to generate a random datasource name.\n\t */\n\tprivate boolean generateUniqueName = true;\n\t/**\n\t * Fully qualified name of the connection pool implementation to use. By default, it\n\t * is auto-detected from the classpath.\n\t */\n\tprivate Class<? extends DataSource> type;\n\n\t/**\n\t * Fully qualified name of the JDBC driver. Auto-detected based on the URL by default.\n\t */\n\tprivate String driverClassName;\n\n\t/**\n\t * JDBC URL of the database.\n\t */\n\tprivate String url;\n\n\t/**\n\t * Login username of the database.\n\t */\n\tprivate String username;\n\n\t/**\n\t * Login password of the database.\n\t */\n\tprivate String password;\n\t\n')])])]),e("p",[t._v("很清晰对应配置spring.datasource，然后是连接池配置：")]),t._v(" "),e("p",[t._v("@Import({ Registrar.class, DataSourcePoolMetadataProvidersConfiguration.class })：导入其他额外的配置，就以DataSourcePoolMetadataProvidersConfiguration为例吧,\nDataSourcePoolMetadataProvidersConfiguration是数据库连接池提供者的一个配置类，即Classpath中存在 org.apache.tomcat.jdbc.pool.DataSource.class，则使用tomcat-jdbc连接池，如果Classpath中存在 HikariDataSource.class则使用Hikari连接池。")]),t._v(" "),e("h2",{attrs:{id:"_2-springapplication启动流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-springapplication启动流程"}},[t._v("#")]),t._v(" 2. SpringApplication启动流程")]),t._v(" "),e("h3",{attrs:{id:"_2-1-springapplication初始化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-springapplication初始化"}},[t._v("#")]),t._v(" 2.1. SpringApplication初始化")]),t._v(" "),e("p",[t._v("SpringBoot整个启动流程分为两个步骤：初始化一个SpringApplication对象、执行该对象的run方法。看下SpringApplication的初始化流程，SpringApplication的构造方法：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('public SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {\n\tthis.resourceLoader = resourceLoader;\n\tAssert.notNull(primarySources, "PrimarySources must not be null");\n\tthis.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));\n\tthis.webApplicationType = WebApplicationType.deduceFromClasspath();\n\tsetInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));\n\tsetListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n\tthis.mainApplicationClass = deduceMainApplicationClass();\n}\n')])])]),e("p",[t._v("初始化流程中最重要的就是通过 SpringFactoriesLoader 找到 spring.factories 文件中配置的 ApplicationContextInitializer 和 ApplicationListener 两个接口的实现类名称，以便后期构造相应的实例。 ApplicationContextInitializer 的主要目的是在 ConfigurableApplicationContext 做 refresh之前，对ConfigurableApplicationContext实例做进一步的设置或处理。ConfigurableApplicationContext继承自 ApplicationContext ，其主要提供了对 ApplicationContext 进行设置的能力。")]),t._v(" "),e("p",[t._v("Spring Boot提供两种方式来添加"),e("strong",[t._v("自定义监听器")]),t._v("：")]),t._v(" "),e("p",[t._v("通过 SpringApplication.addListeners()或者 SpringApplication.setListeners()两个方法来添加一个或者多个自定义监听器")]),t._v(" "),e("p",[t._v("既然SpringApplication的初始化流程中已经从 spring.factories中获取到 ApplicationListener的实现类，那么我们直接在自己的jar包的 META-INF/spring.factories文件中新增配置即可：")]),t._v(" "),e("h3",{attrs:{id:"_2-2-启动流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-启动流程"}},[t._v("#")]),t._v(" 2.2. 启动流程")]),t._v(" "),e("p",[t._v("Spring Boot应用的整个启动流程都封装在 SpringApplication.run 方法中，其整个流程真的是太长太长了，但本质上就是在Spring容器启动的基础上做了大量的扩展，按照这个思路来看看源码")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("/**\n\t * Run the Spring application, creating and refreshing a new\n\t * {@link ApplicationContext}.\n\t * @param args the application arguments (usually passed from a Java main method)\n\t * @return a running {@link ApplicationContext}\n\t */\n\tpublic ConfigurableApplicationContext run(String... args) {\n\t\tStopWatch stopWatch = new StopWatch();\n\t\tstopWatch.start();\n\t\tConfigurableApplicationContext context = null;\n\t\tCollection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();\n\t\tconfigureHeadlessProperty();\n\t\tSpringApplicationRunListeners listeners = getRunListeners(args);\n\t\tlisteners.starting();\n\t\ttry {\n\t\t\tApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n\t\t\tConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);\n\t\t\tconfigureIgnoreBeanInfo(environment);\n\t\t\tBanner printedBanner = printBanner(environment);\n\t\t\tcontext = createApplicationContext();\n\t\t\texceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,\n\t\t\t\t\tnew Class[] { ConfigurableApplicationContext.class }, context);\n\t\t\tprepareContext(context, environment, listeners, applicationArguments, printedBanner);\n\t\t\trefreshContext(context);\n\t\t\tafterRefresh(context, applicationArguments);\n\t\t\tstopWatch.stop();\n\t\t\tif (this.logStartupInfo) {\n\t\t\t\tnew StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);\n\t\t\t}\n\t\t\tlisteners.started(context);\n\t\t\tcallRunners(context, applicationArguments);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\thandleRunFailure(context, ex, exceptionReporters, listeners);\n\t\t\tthrow new IllegalStateException(ex);\n\t\t}\n\n\t\ttry {\n\t\t\tlisteners.running(context);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\thandleRunFailure(context, ex, exceptionReporters, null);\n\t\t\tthrow new IllegalStateException(ex);\n\t\t}\n\t\treturn context;\n\t}\n")])])]),e("ol",[e("li",[e("p",[t._v("通过 SpringFactoriesLoader 查找并加载所有的 SpringApplicationRunListeners，通过调用starting()方法通知所有的SpringApplicationRunListener：应用开始启动了。SpringApplicationRunListener 其本质上就是一个事件发布者，它在SpringBoot应用启动的不同时间点发布不同应用事件类型(ApplicationEvent)，如果有哪些事件监听者(ApplicationListener)对这些事件感兴趣，则可以接收并且处理。前面的初始化流程中，SpringApplication 加载了一系列 ApplicationListener。发布事件的代码已经在SpringApplicationRunListeners中实现了。\nSpringApplicationRunListener只有一个实现类： EventPublishingRunListener。此处的代码只会返回一个 SpringApplicationRunListeners ，注意后面多了一个s字母，看下源码就会发现该类就是包含了一个SpringApplicationRunListener的List。操作SpringApplicationRunListeners ，在内部会遍历每一个SpringApplicationRunListener，调用每一个SpringApplicationRunListener的实现类的starting方法")])]),t._v(" "),e("li",[e("p",[t._v("创建并配置当前应用将要使用的 Environment，Environment用于描述应用程序当前的运行环境，其抽象了两个方面的内容：配置文件(profile)和属性(properties)，开发经验丰富的同学对这两个东西一定不会陌生：不同的环境(eg：生产环境、预发布环境)可以使用不同的配置文件，而属性则可以从配置文件、环境变量、命令行参数等来源获取。因此，当Environment准备好后，在整个应用的任何时候，都可以从Environment中获取资源。")]),t._v(" "),e("p",[t._v("总结起来，主要完成以下几件事：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("判断Environment是否存在，不存在就创建（如果是web项目就创建 StandardServletEnvironment，否则创建 StandardEnvironment）")])]),t._v(" "),e("li",[e("p",[t._v("配置Environment：配置profile以及properties")])]),t._v(" "),e("li",[e("p",[t._v("调用SpringApplicationRunListener的 environmentPrepared()方法，通知事件监听者：应用的Environment已经准备好")])])])]),t._v(" "),e("li",[e("p",[t._v("打印Banner图案")])]),t._v(" "),e("li",[e("p",[t._v("根据不同的ApplicationType创建不同的Context，具体的类型回顾初始化中App类型的介绍")])]),t._v(" "),e("li",[e("p",[t._v("初始化ApplicationContext，主要完成以下工作：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("将准备好的Environment设置给ApplicationContext")])]),t._v(" "),e("li",[e("p",[t._v("遍历调用所有的ApplicationContextInitializer的 initialize()方法来对已经创建好的ApplicationContext进行进一步的处理")])]),t._v(" "),e("li",[e("p",[t._v("调用SpringApplicationRunListener的 contextPrepared()方法，通知所有的监听者：ApplicationContext已经准备完毕")])]),t._v(" "),e("li",[e("p",[t._v("将所有的bean加载到容器中")])]),t._v(" "),e("li",[e("p",[t._v("调用SpringApplicationRunListener的 contextLoaded()方法，通知所有的监听者：ApplicationContext已经装载完毕")])])])]),t._v(" "),e("li",[e("p",[t._v("refresh完成配置类的解析、各种BeanFactoryPostProcessor和BeanPostProcessor的注册、国际化配置的初始化、web内置容器的构造等等。")])])]),t._v(" "),e("p",[t._v("以上就是Spring Boot的整个启动流程，其核心就是在Spring容器初始化并启动的基础上加入各种扩展点，这些扩展点包括：")]),t._v(" "),e("ul",[e("li",[t._v("ApplicationContextInitializer")]),t._v(" "),e("li",[t._v("ApplicationListener")]),t._v(" "),e("li",[t._v("自动配置自定义\norg.springframework.boot.env.EnvironmentPostProcessor:\nAllows for customization of the application's {@link Environment} prior to the application context being refreshed.")]),t._v(" "),e("li",[t._v("各种BeanFactoryPostProcessor等等\norg.springframework.beans.factory.config.BeanFactoryPostProcessor：\n允许我们在容器实例化相应对象之前，对注册到容器的BeanDefinition所保存的信息做一些额外的操作，比如修改bean定义的某些属性或者增加其他信息等。")])]),t._v(" "),e("h2",{attrs:{id:"_3-使用springboot开发应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-使用springboot开发应用"}},[t._v("#")]),t._v(" 3. 使用springboot开发应用")]),t._v(" "),e("p",[t._v("spring boot官方提供了很多现成的starter，可以直接引用其depdendency使用比如\nspring-boot-starter-web，spring-boot-starter-jdbc\n"),e("a",{attrs:{href:"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-starter",target:"_blank",rel:"noopener noreferrer"}},[t._v("starters"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("但是问题是引用时需要加版本号，很多starter之间以及跟其他的dependency之间可能有版本依赖冲突，\n所以官方推荐使用parent方式或者import方式引入某个版本的spring-boot-starter-parent，因为这个parent里面已经定义好了各个版本号，\n所以在引用比如spring-boot-starter-web的时候就不需要添加版本号了")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("\x3c!-- Inherit defaults from Spring Boot --\x3e\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.2.6.RELEASE</version>\n</parent>\n\n<dependencyManagement>\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\t</dependencies>\n</dependencyManagement>\n\n\x3c!--The spring-boot-starter-parent POM includes <executions> configuration to bind the repackage goal.--\x3e\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n    </plugins>\n</build>\n\n\x3c!-- Dependence Override \nfull list: https://github.com/spring-projects/spring-boot/blob/v2.2.6.RELEASE/spring-boot-project/spring-boot-dependencies/pom.xml\n--\x3e\n<properties>\n    <spring-data-releasetrain.version>Fowler-SR2</spring-data-releasetrain.version>\n</properties>\n\n")])])]),e("p",[e("a",{attrs:{href:"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-starter",target:"_blank",rel:"noopener noreferrer"}},[t._v("一站式starter"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-auto-configuration",target:"_blank",rel:"noopener noreferrer"}},[t._v("About AutoConfig"),e("OutboundLink")],1),t._v("\nGradually Replacing Auto-configuration\nDisabling Specific Auto-configuration Classes\n(exclude={DataSourceAutoConfiguration.class})")]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("REFERENCE:")]),t._v(" "),e("p",[t._v("https://github.com/javastacks/spring-boot-best-practice\nhttps://github.com/YunaiV/SpringBoot-Labs")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://blog.csdn.net/TheLudlows/article/details/81360067",target:"_blank",rel:"noopener noreferrer"}},[t._v("Spring Boot 2.0 ：深入分析Spring Boot原理"),e("OutboundLink")],1),t._v(" "),e("a",{attrs:{href:"https://mp.weixin.qq.com/s/1yxsCD3IxopIWYceA54Ayw",target:"_blank",rel:"noopener noreferrer"}},[t._v("给你一份超详细 Spring Boot 知识清单"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("EnvironmentPostProcessor\nBeanPostProcessor")]),t._v(" "),e("p",[t._v("spring boot之自动装配（spring-boot-autoconfigure） https://blog.csdn.net/wangjie5540/article/details/99542777")]),t._v(" "),e("p",[t._v("原创 | 我被面试官给虐懵了，竟然是因为我不懂Spring中的@Configuration\nhttps://juejin.im/post/5d005860f265da1b7f297630")]),t._v(" "),e("p",[t._v("spring boot 中的 Parent POM 和 Starter 的作用什么\nhttps://cloud.tencent.com/developer/article/1362790")])])}),[],!1,null,null,null);n.default=o.exports}}]);