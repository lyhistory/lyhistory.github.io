(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{526:function(e,v,_){"use strict";_.r(v);var t=_(56),o=Object(t.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("p",[e._v("single thread queue - LMAX DisruptorHigh Performance Inter-Thread Messaging Library\nhttps://lmax-exchange.github.io/disruptor/")]),e._v(" "),_("p",[e._v("http://lmax-exchange.github.io/disruptor/files/Disruptor-1.0.pdf\nhttps://github.com/LMAX-Exchange/disruptor/wiki/Getting-Started")]),e._v(" "),_("h2",{attrs:{id:"key-concepts"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#key-concepts"}},[e._v("#")]),e._v(" key concepts")]),e._v(" "),_("ul",[_("li",[e._v("Ring Buffer")])]),e._v(" "),_("p",[e._v("它通常被认为是 "),_("code",[e._v("Disruptor")]),e._v(" 的主要方面, 但从 "),_("code",[e._v("3.0")]),e._v(" 开始, 它仅负责存储和更新在 "),_("code",[e._v("Disruptor")]),e._v(" 中移动的数据(事件). 对某些高级用例, 可完全由用户代替.")]),e._v(" "),_("ul",[_("li",[e._v("Sequence")])]),e._v(" "),_("p",[_("code",[e._v("Disruptor")]),e._v(" 使用它作为一种手段来识别特定组件在哪里. 每个消费者 ("),_("code",[e._v("EventProcessor")]),e._v(") 和 "),_("code",[e._v("Disruptor")]),e._v(" 本身一样都维护一个 "),_("code",[e._v("Sequence")]),e._v(" . 大多数并发代码依赖于这些 "),_("code",[e._v("Sequence")]),e._v(" 值的移动, 因此 "),_("code",[e._v("Sequence")]),e._v(" 支持 "),_("code",[e._v("AtomicLong")]),e._v(" 的许多当前功能. 实际上, 和版本 2 之间的唯一真正区别是, "),_("code",[e._v("Sequence")]),e._v(" 包含其他功能, 以防止 "),_("code",[e._v("Sequence")]),e._v(" 与其他值之间的伪共享.")]),e._v(" "),_("ul",[_("li",[e._v("Sequencer")])]),e._v(" "),_("p",[e._v("它是 "),_("code",[e._v("Disruptor")]),e._v(" 的真正核心. 此接口的两个实(单生产者, 多生产者)实现了所有并发算法, 这些算法用于在生产者和消费者之间快速正确地传递数据")]),e._v(" "),_("ul",[_("li",[e._v("Sequence Barrier")])]),e._v(" "),_("p",[e._v("它是由 "),_("code",[e._v("Sequencer")]),e._v(" 产生, 包含主要发布的 "),_("code",[e._v("Sequence")]),e._v(" 的引用以及任何从属消费者的 "),_("code",[e._v("Sequence")]),e._v(" . 它包含确定是否有任何事件可供消费者处理的逻辑.")]),e._v(" "),_("ul",[_("li",[e._v("Wait Strategy")])]),e._v(" "),_("p",[e._v("它确定消费者如何等待生产者将事件放入 "),_("code",[e._v("Disruptor")]),e._v(" 中. 更多详细, 在下面的 可选无锁 部分.")]),e._v(" "),_("ul",[_("li",[e._v("Event")])]),e._v(" "),_("p",[e._v("从生产者到消费者的数据传递单元. 没有特定的代码来表示它, 完全是由用户定义的")]),e._v(" "),_("ul",[_("li",[e._v("EventProcessor")])]),e._v(" "),_("p",[e._v("用来处理来自 "),_("code",[e._v("Disruptor")]),e._v(" 的事件的主事件循环(event loop), 并拥有消费者的 "),_("code",[e._v("Sequence")]),e._v(" 所有权. 有一个  "),_("code",[e._v("BatchEventProcessor")]),e._v(" , 它包含事件循环的高效实现并回调到 "),_("code",[e._v("EventHandler")]),e._v(" 接口的提供的实现中.")]),e._v(" "),_("ul",[_("li",[e._v("EventHandler")])]),e._v(" "),_("p",[e._v("一个用于被用户实现的接口, 对于 "),_("code",[e._v("Disruptor")]),e._v(" 来说, 就是一个消费者")]),e._v(" "),_("ul",[_("li",[e._v("Producer")])]),e._v(" "),_("p",[e._v("它是用户定义的代码, 调用 "),_("code",[e._v("Disruptor")]),e._v(" 将事件进队. 这个概念并没有特定的代码表示.")]),e._v(" "),_("p",[e._v("https://emacsist.github.io/2019/10/12/disruptor%E5%AD%A6%E4%B9%A0/")]),e._v(" "),_("p",[e._v("javadoc")]),e._v(" "),_("p",[e._v("https://javadoc.io/doc/com.lmax/disruptor/latest/index.html")])])}),[],!1,null,null,null);v.default=o.exports}}]);