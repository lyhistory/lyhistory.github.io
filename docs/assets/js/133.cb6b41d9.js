(window.webpackJsonp=window.webpackJsonp||[]).push([[133],{335:function(e,t,n){"use strict";n.r(t);var s=n(0),r=Object(s.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("https secure http")]),e._v(" "),n("p",[e._v("wss secure websocket")]),e._v(" "),n("p",[e._v("refer to 《network.md/tls》")]),e._v(" "),n("h2",{attrs:{id:"ssl-tls-certificate-证书类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ssl-tls-certificate-证书类型"}},[e._v("#")]),e._v(" SSL/TLS Certificate 证书类型")]),e._v(" "),n("p",[e._v("工具：keytool openssl")]),e._v(" "),n("p",[e._v("证书可以单纯只是包含ca认证的证书链（CA的签名）或自签名，以及公钥，也可以同时包含私钥，私钥当然可以独立于证书生成单独存储；")]),e._v(" "),n("p",[e._v("带密码：spring boot mvc程序，这样好处是双重保护，因为需要同时需要密码和私钥才可以")]),e._v(" "),n("p",[e._v("不带密码：ngnix，私钥或者是含有私钥的证书一定要控制读取权限")]),e._v(" "),n("p",[e._v("按照生成方式分为：")]),e._v(" "),n("ul",[n("li",[e._v("self-sgined certificate")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('------------------------------------------------------------\n--- use openssl 不带密码\n------------------------------------------------------------\nsudo mkdir /etc/ssl/privatekey\nsudo chmod 700 /etc/ssl/privatekey\nsudo openssl req -x509 -nodes -days 3650 -newkey rsa:2048 -keyout /etc/ssl/privatekey/nginx-selfsigned.key -out /etc/ssl/certs/nginx-selfsigned.crt\n\n------------------------------------------------------------\n--- use keytool 带密码\n------------------------------------------------------------\nkeytool -genkey -alias secure_netty -keysize 2048 -validity 365 -keyalg RSA -dname "CN=localhost" -keypass 123456 -storepass 123456 -keystore selfsigned.jks\nkeytool -export -alias securechat -keystore selfsigned.jks -storepass 123456 -file selfsigned.cer\n\n\nkeytool -genkey -alias secure_tomcat -keysize 1024 -validity 365 -keyalg RSA -keypass 123456 -storepass 123456 -keystore selfsigned.keystore \nkeytool -list -v -keystore selfsigned.keystore\nkeytool -export -alias secure_tomcat -keystore selfsigned.keystore -file selfsigned.cer\n')])])]),n("ul",[n("li",[e._v("let's encrypt")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('//自动化工具\nwget https://dl.eff.org/certbot-auto\nchmod a+x certbot-auto\n./certbot-auto certonly --standalone -d  www.demoProject.com   # www.demoProject.com为你想要配置https的域名\nls /etc/letsencrypt/live/\n\n//证书定时自动更新\ncrontab -e    #编辑crontab\n30 2 * * 1 /root/certbot-auto renew --pre-hook "systemctl stop nginx" --post-hook "systemctl start nginx" >> /var/log/le-renew.log 2>&1 &\nroot/certbot-auto renew --pre-hook "systemctl stop nginx" --post-hook "systemctl start nginx"\n\n')])])]),n("ul",[n("li",[n("p",[e._v("“购买”免费证书")]),e._v(" "),n("p",[e._v("https://www.cztcms.cn/?p=826")])]),e._v(" "),n("li",[n("p",[e._v("dns解析提供商免费证书")]),e._v(" "),n("p",[e._v("cloudflare dns over tls")]),e._v(" "),n("p",[e._v("https://www.cloudflare.com/learning/dns/dns-over-tls/")])])]),e._v(" "),n("h2",{attrs:{id:"supporting-https"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#supporting-https"}},[e._v("#")]),e._v(" Supporting https")]),e._v(" "),n("h3",{attrs:{id:"browser"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#browser"}},[e._v("#")]),e._v(" browser")]),e._v(" "),n("p",[e._v("浏览器自然是全面支持https的，不过不同浏览器的特性不同，比如")]),e._v(" "),n("p",[e._v("chrome是采用了操作系统本身的CA证书链，")]),e._v(" "),n("p",[e._v("而firefox是有完整自己的一套证书，所以对于渗透测试者来说，firefox是首选，因为不需要改变操作系统本身的证书，只需要安装给firefox本身就行了，当然firefox还有个特性是支持proxy，chrome还得装插件才行；")]),e._v(" "),n("p",[e._v("注意：如果是自签证书，浏览器会提示，可以手动信任，之后就可以正常访问，但是下面的js http client则不同")]),e._v(" "),n("p",[e._v("访问后端的时候需要注意cors也就是same origin的问题，比如reactjs项目本地测试默认开启nodejs服务：http://localhost:3000，这样访问后端服务，如果后端服务没有设置allow origin，因为后端服务端口一般不会刚好是3000，如果是其他端口，即使也是localhost服务，因为端口不同，不属于same origin，无法请求")]),e._v(" "),n("h3",{attrs:{id:"js-http-client"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js-http-client"}},[e._v("#")]),e._v(" js http client")]),e._v(" "),n("p",[e._v("注意：跟上面不同的是，这里是没有用户交互的，而是js代码自动请求到后端，如果是自签证书，浏览器是不信任的，解决办法就是想办法手动从浏览器地址栏访问一次后端，然后手动加信任，之后应该就可以了，或者另外一种方式是")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import axios from 'axios'\nimport https from 'https'\nconst result = await axios.post(\n    `https://${url}/login`,\n    body,\n    {\n      httpsAgent: new https.Agent({\n        rejectUnauthorized: false\n      })\n    }\n  )\n")])])]),n("p",[e._v("这样会完全忽略证书验证，不太好，所以更好的方法是：")]),e._v(" "),n("p",[e._v("https://stackoverflow.com/questions/51363855/how-to-configure-axios-to-use-ssl-certificate")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const httpsAgent = new https.Agent({ ca: MY_CA_BUNDLE });\n")])])]),n("h3",{attrs:{id:"nginx"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#nginx"}},[e._v("#")]),e._v(" nginx")]),e._v(" "),n("p",[e._v("refer to 《buildingblock/nginx.md》")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("\nnginx.conf:\n server {\n        listen       80;\n        listen 443 ssl;\n        listen [::]:443 ssl;\n        server_name  localhost;\n\n        ssl_certificate /etc/ssl/certs/clear-selfsigned.crt;\n        ssl_certificate_key /etc/ssl/privatekey/clear-selfsigned.key;\n        ssl_dhparam /etc/ssl/certs/dhparam.pem;\n")])])]),n("h3",{attrs:{id:"springboot-mvc"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#springboot-mvc"}},[e._v("#")]),e._v(" springboot mvc")]),e._v(" "),n("p",[e._v("首先MVC有自己的端口比如10001，内置的tomcat默认的http端口是8080，")]),e._v(" "),n("p",[e._v("所有请求到spring mvc这个后台的都是通过 http://IP:10001 过来的，然后内部再交由tomcat 8080端口处理，")]),e._v(" "),n("p",[e._v("如果设置https比如8443，如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('yml：\n#debug: true\nserver:\n  servlet:\n    context-path: /test\n  port:\n    10001\n  ssl:\n    key-store: selfsigned.keystore\n    key-store-password: 123456\n    keyStoreType: JKS\n    keyAlias: secure_tomcat\n    \n@EnableAsync\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n\n    @Bean\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n\n    /**\n     * http重定向到https\n     * @return\n     */\n    @Bean\n    public TomcatServletWebServerFactory servletContainer() {\n        TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory() {\n            @Override\n            protected void postProcessContext(Context context) {\n                SecurityConstraint constraint = new SecurityConstraint();\n                constraint.setUserConstraint("CONFIDENTIAL");\n                SecurityCollection collection = new SecurityCollection();\n                collection.addPattern("/*");\n                constraint.addCollection(collection);\n                context.addConstraint(constraint);\n            }\n        };\n        //这里tomcat.getPort拿到的就是8080\n        tomcat.addAdditionalTomcatConnectors(httpConnector(tomcat.getPort()));\n        return tomcat;\n    }\n\n    @Bean\n    public Connector httpConnector(int port) {\n        Connector connector = new Connector("org.apache.coyote.http11.Http11NioProtocol");\n        connector.setScheme("http");\n        //Connector监听的http的端口号\n        connector.setPort(port);\n        connector.setSecure(false);\n        //监听到http的端口号后转向到的https的端口号\n        connector.setRedirectPort(8443);\n        return connector;\n    }\n}\n\n')])])]),n("p",[e._v("注意到上面server本身就监听10001（应该是内置tomcat监听），然后为了https，需要创建tomcatfatory又出现一个http端口8080，为什么不可以直接扩展或override postProcessContext方法，可能是跟整个spring mvc的生命周期启动过程相关：")]),e._v(" "),n("p",[e._v("https://zhuanlan.zhihu.com/p/81807865")]),e._v(" "),n("h3",{attrs:{id:"netty"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#netty"}},[e._v("#")]),e._v(" netty")]),e._v(" "),n("p",[e._v("https://blog.csdn.net/invadersf/article/details/80337380")]),e._v(" "),n("p",[e._v("https://www.cnblogs.com/zhjh256/p/6488668.html")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('import io.netty.handler.ssl.SslHandler;\npublic class SslChannelInitializer extends ChannelInitializer<Channel> {\n    private final SslContext context;\n\n    public SslChannelInitializer(SslContext context) { \n        this.context = context;\n    }\n\n    @Override\n    protected void initChannel(Channel ch) throws Exception {\n        SSLEngine engine = context.newEngine(ch.alloc());\n        engine.setUseClientMode(false);\n        ch.pipeline().addFirst("ssl", new SslHandler(engine));\n        ChannelPipeline pipeline = ch.pipeline(); \n        pipeline.addLast("frameDecoder", new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, 4, 0, 4));  \n        pipeline.addLast("frameEncoder", new LengthFieldPrepender(4));                \n        pipeline.addLast("decoder", new StringDecoder(Charset.forName("UTF-8")));  \n        pipeline.addLast("encoder", new StringEncoder(Charset.forName("UTF-8")));  \n        pipeline.addLast("spiderServerBusiHandler", new SpiderServerBusiHandler());\n    }\n}\n\nbossGroup = new NioEventLoopGroup(1);\nworkerGroup = new NioEventLoopGroup(WORKER_GROUP_SIZE);\nchannelClass = NioServerSocketChannel.class;\nlogger.info("workerGroup size:" + WORKER_GROUP_SIZE);\nlogger.info("preparing to start spider server...");\nb.group(bossGroup, workerGroup);  \nb.channel(channelClass);\nKeyManagerFactory keyManagerFactory = null;\nKeyStore keyStore = KeyStore.getInstance("JKS");\nkeyStore.load(new FileInputStream("selfsigned.jks"), "sNetty".toCharArray());\nkeyManagerFactory = KeyManagerFactory.getInstance("SunX509");\nkeyManagerFactory.init(keyStore,"123456".toCharArray());\nSslContext sslContext = SslContextBuilder.forServer(keyManagerFactory).build();\nb.childHandler(new SslChannelInitializer(sslContext)); \n')])])]),n("h2",{attrs:{id:"basic-model-client-server"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#basic-model-client-server"}},[e._v("#")]),e._v(" Basic model: client-server")]),e._v(" "),n("p",[e._v("这里的client就是浏览器或手机端，")]),e._v(" "),n("p",[e._v("这里的server指的是前后端代码集成一起的后端服务，")]),e._v(" "),n("p",[e._v("比较直白，只有两方参与，浏览器不需要什么设置，后端服务如果是self host则需要其本身实现https，比如spring mvc，如果不是self host，而是host在比如nginx或iis中，则需要对nginx或iis配置https支持即可；")]),e._v(" "),n("h2",{attrs:{id:"complicated-model-separated-frontend-backend前后端分离"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#complicated-model-separated-frontend-backend前后端分离"}},[e._v("#")]),e._v(" Complicated model: separated frontend/backend前后端分离")]),e._v(" "),n("p",[e._v("举例前后端分离项目：\n1.(user interact ) browser request nginx for frontend resource\ncreate self-signed cert and config nignx, so browser will talk to nginx through https (unsafe warning will be alert as it's self signed)")]),e._v(" "),n("p",[e._v("2.(no user interact) js codes will make http call to backend service to retrieve data through nginx, nginx forward http request to backend service\nbackend service has to implement and support https, and nginx also have to act as a https client to handshake with mgr")]),e._v(" "),n("p",[e._v("3.(no user interact) js codes will connect to websocket server directly")]),e._v(" "),n("p",[e._v("假设前端项目用的是create-reactjs-app脚手架，npm run start会开启一个nodejs服务，如下")]),e._v(" "),n("p",[n("img",{attrs:{src:"/docs/docs_image/software/network/ssl_local_env01.png",alt:""}})]),e._v(" "),n("p",[e._v("这种情况下显然是不可行的，首先：")]),e._v(" "),n("p",[e._v("1.默认情况下，origin是https://127.0.0.1:3000，axios http client请求的host是 https://127.0.0.1:10001 ，会被same origin policy阻挡，")]),e._v(" "),n("p",[e._v("注意如果是"),n("code",[e._v("<img src=https://127.0.0.1:3000/verifycode")]),e._v(" 这种图片src的验证码是不会被block住的，因为img link script等标签不会受制于same origin policy")]),e._v(" "),n("p",[e._v("2.浏览器用户互动的部分请求到的host是nodejs，而非用户互动的axios请求到的host是spring mvc，因为开发环境肯定都是自签证书，即使给nodejs设置好了自签证书，浏览器第一次会提醒用户不安全，用户选择继续访问后浏览器则记住该证书，但是axios请求的是spring mvc程序的证书，跟nodejs一般是不同的，这种情况下就会有问题")]),e._v(" "),n("p",[e._v("1的一个解决办法是通过设置chrome浏览器，允许其跨域： https://segmentfault.com/a/1190000021711445")]),e._v(" "),n("p",[e._v("2的一个解决方法是nodejs跟spring mvc用相同的证书，或者手动给浏览器安装证书：https://qastack.cn/superuser/27268/how-do-i-disable-the-warning-chrome-gives-if-a-security-certificate-is-not-trusted")]),e._v(" "),n("p",[e._v("但是其实更完美的解决方法是加一个nginx，nginx作为proxy转发两者的流量到nodejs和springmvc，这样浏览器本身和其中的js代码axios http client只需要跟nginx进行handshake即可，而且origin和host都是test.local，不存在跨域问题，参考下面这张图：")]),e._v(" "),n("p",[n("img",{attrs:{src:"/docs/docs_image/software/network/ssl_local_env02.png",alt:""}})]),e._v(" "),n("p",[e._v("注意，关于websocket有两点：")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("如果网站使用了https，默认必须使用wss，ws会被浏览器block住，另外注意到，这里前端跟nginx之间是使用wss的，nginx跟真正的服务端仍然是明文ws通信，这个很正常，本来nginx就是反向代理，客户端不需要直接跟被代理的服务端连接，所以实际上同理后端的服务也可以只用http跟nginx通信；")])]),e._v(" "),n("li",[n("p",[e._v("如果是本地测试 127.0.0.1，特别要小心，如图域名使用test.local会出现问题：provisional headers are shown")]),e._v(" "),n("p",[e._v("解决办法是，nginx将server_name改为localhost即可")])])]),e._v(" "),n("p",[e._v("而最终部署到服务器上则会简化，因为就不需要nodejs开发环境了：")]),e._v(" "),n("p",[n("img",{attrs:{src:"/docs/docs_image/software/network/ssl_product_env.png",alt:""}})]),e._v(" "),n("p",[e._v("测试完https后，想回去测试http，chrome经常会强制使用https，解决办法：")]),e._v(" "),n("p",[e._v("https://superuser.com/questions/565409/how-to-stop-an-automatic-redirect-from-http-to-https-in-chrome")]),e._v(" "),n("ol",[n("li",[e._v("Go to "),n("code",[e._v("chrome://net-internals/#hsts")]),e._v(". Enter "),n("em",[e._v("3rdrevolution.com")]),e._v(" under "),n("strong",[e._v("Delete domain security policies")]),e._v(" and press the Delete button.")]),e._v(" "),n("li",[e._v("Now go to "),n("code",[e._v("chrome://settings/clearBrowserData")]),e._v(", tick the box "),n("em",[e._v("Cached images and files")]),e._v(" and press click the button "),n("em",[e._v("Clear data")]),e._v(".")])])])}),[],!1,null,null,null);t.default=r.exports}}]);