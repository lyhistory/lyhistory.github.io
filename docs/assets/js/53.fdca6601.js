(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{503:function(e,t,r){"use strict";r.r(t);var i=r(65),a=Object(i.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("Modular Arithmetic")]),e._v(" "),r("h2",{attrs:{id:"_1-definition-1-4-1-modulo-operation"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-definition-1-4-1-modulo-operation"}},[e._v("#")]),e._v(" 1.Definition 1.4.1 Modulo Operation")]),e._v(" "),r("p",[e._v("Let a, r,m ∈ Z (where Z is a set of all integers) and m > 0. We write\n"),r("code",[e._v("a ≡ r mod m")]),e._v("\nif m divides a−r.\nm is called the modulus and r is called the remainder.")]),e._v(" "),r("p",[e._v("=>")]),e._v(" "),r("p",[e._v("It is always possible to write a ∈ Z, such that\na = q ·m+r for 0 ≤ r < m")]),e._v(" "),r("p",[e._v("Since a−r = q ·m (m divides a−r) we can now write: a ≡ r mod m. Note that r ∈ {0,1,2, . . . ,m−1}.")]),e._v(" "),r("p",[e._v("example:")]),e._v(" "),r("p",[e._v('13/5 = 2 ("the quotient") + 3/5 ("the remainder").\n13 = 2(5) + 3.\nIf a and b are positive integers, there exist integers unique non-negative integers q and r so that\na = qb + r , where 0 =< r < b.\nq is called the quotient and r the remainder.')]),e._v(" "),r("h3",{attrs:{id:"properties"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#properties"}},[e._v("#")]),e._v(" Properties")]),e._v(" "),r("h4",{attrs:{id:"_1-the-remainder-is-not-unique"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-the-remainder-is-not-unique"}},[e._v("#")]),e._v(" 1) The Remainder Is Not Unique")]),e._v(" "),r("p",[e._v(" 12 ≡3 mod9, 3 is a valid remainder since 9|(12−3)\n 12 ≡ 21 mod 9, 21 is a valid remainder since 9|(21−3)\n 12≡−6 mod 9, −6 is a valid remainder since 9|(−6−3)")]),e._v(" "),r("p",[e._v("−6 ≡ 21 ≡ 12 ≡ 3 ≡ 3 mod9")]),e._v(" "),r("p",[e._v("where the “x|y” means “x divides y”. There is a system behind this behavior. The set of numbers\n{. . . ,−24,−15,−6,3,12,15,24, . . .}\nform what is called an "),r("strong",[e._v("equivalence class")]),e._v(". There are eight other equivalence classes for the modulus 9:\n{. . . ,−27,−18,−9, 0, 9,18,27, . . .}\n{. . . ,−26,−17,−8, 1, 10,19,28, . . .}\n...\n{. . . ,−19,−10,−1, 8, 17,26,35, . . .}")]),e._v(" "),r("h4",{attrs:{id:"_2-all-members-of-a-given-equivalence-class-behave-equivalently-同态"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-all-members-of-a-given-equivalence-class-behave-equivalently-同态"}},[e._v("#")]),e._v(" 2) All Members of a Given Equivalence Class Behave Equivalently 同态？")]),e._v(" "),r("p",[e._v("If we have involved computations with a fixed modulus — which is usually the case in cryptography — we are free to choose the class element that results in the easiest computation.")]),e._v(" "),r("p",[e._v("The core operation in many practical public-key schemes is an exponentiation of the form x"),r("sup",[e._v("e")]),e._v(" mod m, where x,e,m are very large integers, say, 2048 bits each. Using a toy-size example, we can demonstrate two ways of doing modular exponentiation.\nWe want to compute 3"),r("sup",[e._v("8")]),e._v(" mod 7. The first method is the straightforward approach, and for the second one we switch between equivalent classes.\n 3"),r("sup",[e._v("8")]),e._v(" = 6561 ≡ 2 mod 7, since 6561 = 937 · 7+2\nNote that we obtain the fairly large intermediate result 6561 even though we know that our final result cannot be larger than 6.\n Here is a much smarter method: First we perform two partial exponentiations:\n3"),r("sup",[e._v("8")]),e._v(" = 3"),r("sup",[e._v("4")]),e._v(" · 3"),r("sup",[e._v("4")]),e._v(" = 81 · 81")]),e._v(" "),r("p",[e._v("We can now replace the intermediate results 81 by another member of the same equivalence class. The smallest positive member modulo 7 in the class is 4 (since 81 = 11 · 7+4). Hence:\n3"),r("sup",[e._v("8")]),e._v(" = 81 · 81 ≡ 4 · 4 = 16 mod 7 ≡ 2 mod 7.")]),e._v(" "),r("h3",{attrs:{id:"模的逆"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模的逆"}},[e._v("#")]),e._v(" 模的逆")]),e._v(" "),r("p",[e._v("⅓ mod 28 = 19 (3*19 mod 28 =1)")]),e._v(" "),r("p",[e._v("如何计算参见后面的 Euclidean algorithm")]),e._v(" "),r("p",[r("strong",[e._v("证明x对n模运算的逆存在的前提是公约数gcd(x,n)=1 Proving that modular inverse only exists when gcd(n,x)=1")])]),e._v(" "),r("p",[e._v("https://math.stackexchange.com/questions/2101189/proving-that-modular-inverse-only-exists-when-gcdn-x-1")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("If there is an inverse of x mod n, that gives us a number y so that xy≡1 mod n. That means that xy=kn+1, or (rearranging) that xy−kn=1.\nNow for any common divisor, c, of x and n we will have that c∣(xy−kn) which gives c∣1, that is, c=1. So that is an outcome - and therefore a requirement - of finding the inverse of xmodn\n")])])]),r("p",[e._v("另一种证明没有看懂，在：https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95")]),e._v(" "),r("h3",{attrs:{id:"负数的模"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#负数的模"}},[e._v("#")]),e._v(" 负数的模：")]),e._v(" "),r("p",[e._v("mod(a, n) = a - n * floor(a / n)")]),e._v(" "),r("p",[e._v("-104 mod 28")]),e._v(" "),r("p",[e._v("= -104 - 28*floor(-104/28)")]),e._v(" "),r("p",[e._v("=-104 - 28*(-3.7) 不同程序结果不同，比如-3.7向下取整 -4 ，结果为8，向上取整或向零取整结果为-20")]),e._v(" "),r("h3",{attrs:{id:"ord的意思"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ord的意思"}},[e._v("#")]),e._v(" Ord的意思")]),e._v(" "),r("p",[e._v("https://math.stackexchange.com/questions/638597/what-does-ord-mean/638604")]),e._v(" "),r("p",[e._v("Ord29(x)=7 \t====\t\tx"),r("sup",[e._v("7")]),e._v(" ≡ 1mod29")]),e._v(" "),r("h2",{attrs:{id:"_2-euclidean-algorithms-basic-and-extended"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-euclidean-algorithms-basic-and-extended"}},[e._v("#")]),e._v(" 2. Euclidean algorithms (Basic and Extended)")]),e._v(" "),r("p",[e._v("refer:")]),e._v(" "),r("p",[e._v("https://www.geeksforgeeks.org/euclidean-algorithms-basic-and-extended/")]),e._v(" "),r("p",[e._v("http://www-math.ucdenver.edu/~wcherowi/courses/m5410/exeucalg.html")]),e._v(" "),r("h3",{attrs:{id:"引入"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#引入"}},[e._v("#")]),e._v(" 引入")]),e._v(" "),r("p",[r("strong",[e._v("The greatest common divisor")]),e._v(" of integers a and b, denoted by gcd(a,b), is the largest integer that divides (without remainder) both a and b")]),e._v(" "),r("p",[e._v("For small numbers, the gcd is easy to calculate by factoring both numbers and finding the highest common factor.")]),e._v(" "),r("p",[e._v("For the large numbers which occur in public-key schemes, however, factoring often is not possible, and amore efficient algorithm is used for gcd computations, the Euclidean algorithm.")]),e._v(" "),r("h3",{attrs:{id:"basic"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#basic"}},[e._v("#")]),e._v(" Basic:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("Euclidean Algorithm\nInput: positive integers r0 and r1 with r0 > r1\nOutput: gcd(r0, r1)\nInitialization: i = 1\nAlgorithm:\n1 \tDO\n1.1 \ti = i+1\n1.2 \tri = ri−2 mod ri−1\n\tWHILE ri \b= 0\n2 \tRETURN\n\t\tgcd(r0, r1) = ri−1\n")])])]),r("p",[e._v("两步说明：")]),e._v(" "),r("p",[e._v("The algorithm is based on the below facts:")]),e._v(" "),r("ol",[r("li",[r("p",[e._v("第一步：减法，If we subtract a smaller number from a larger (we reduce a larger number), GCD doesn’t change. So if we keep subtracting repeatedly the larger of two, we end up with GCD.")]),e._v(" "),r("p",[e._v("Prove:")]),e._v(" "),r("p",[e._v("gcd(a, b) = gcd(a,b-a), where we assume that b > a, and that both numbers are positive integers. This property can easily be proven: Let gcd(a, b) = g. Since g divides both a and b, we can write a = g · x and b = g · y, where x < y, and x and y are coprime integers,\ni.e., they do not have common factors. Moreover, it is easy to show that (y-x) and x are also coprime. It follows from here that:\ngcd(a,b-a) = gcd(gx,g(y-x)) = g.")]),e._v(" "),r("p",[e._v("另一种直觉证明：assume a<b, gcd(a,b)=gcd(a,b-a)  分数的基本运算规则:  c|b-a = c|b - c|a 所以如果c是最大公约数，那么c就能同时整除a和b，自然也能整除b-a，所以c也是a和b-a的最大公约数")]),e._v(" "),r("p",[e._v("第一种应用：直接求gcd，不断repeat减法")]),e._v(" "),r("p",[e._v("a0=a,b0=b, a<b, gcd(a,b)=gcd(a,b-a)")]),e._v(" "),r("p",[e._v("if b-a<a,  a1=b-a, b1=a, gcd(b-a,a)=gcd(b-a,a-(b-a))")]),e._v(" "),r("p",[e._v(".....")]),e._v(" "),r("p",[e._v("直到 an=bn")]),e._v(" "),r("p",[e._v("gcd(a,b)=an=bn")]),e._v(" "),r("p",[e._v("e.g:")]),e._v(" "),r("p",[e._v("gcd(5,13) = gcd(5,13-5)=gcd(5,8)=gcd(5,8-5)=gcd(5,3)=gcd(3,5-3)=gcd(3,2)=gcd(2,3-2)=gcd(2,1)=gcd(1,2-1)=gcd(1,1)")]),e._v(" "),r("p",[e._v("第二种应用：引出第二步")]),e._v(" "),r("p",[e._v("gcd(r0, r1) = gcd(r0−r1, r1), where we assume that r0 > r1, and that both numbers are positive integers")]),e._v(" "),r("p",[e._v("It also follows immediately that we can apply the process iteratively:\ngcd(r0, r1) = gcd(r0−r1, r1) = gcd(r0−2r1, r1) = · · · = gcd(r0−mr1, r1)\nas long as (r0 −mr1) > 0.\nThe algorithm uses the fewest number of steps if we choose the maximum value for m. This is the case if we compute:\ngcd(r0, r1) = gcd(r0 mod r1, r1). 因为  "),r("code",[e._v("r0 mod r1 => r0 ≡ r mod r1 => r0=mr1+r,0 ≤ r < r1 => r=r0-mr1")])]),e._v(" "),r("p",[e._v("gcd(13,5)=gcd(13-5,5)=gcd(8,5)=gcd(8-5,5)=gcd(3,5)  r0 mod r1=3, r0-2*r1=3modr1")]),e._v(" "),r("p",[e._v("Since the first term (r0 mod r1) is smaller than the second term r1, we usually swap them:\ngcd(r0, r1) = gcd(r1, r0 mod r1).")]),e._v(" "),r("p",[e._v("gcd(13,5) = gcd(5,3)")]),e._v(" "),r("p",[e._v("The core observation from this process is that we can reduce the problem of finding the gcd of two given numbers to that of the gcd of two smaller numbers.\nThis process can be applied recursively until we obtain finally gcd(rl ,0) = rl . Since each iteration preserves the gcd of the previous iteration step, it turns out that this final gcd is the gcd of the original problem, i.e.,\ngcd(r0, r1) = · · · = gcd(rl ,0) = rl .")]),e._v(" "),r("p",[e._v("gcd(13,5) = gcd(5, 13mod5)=gcd(5,3)=gcd(3,5mod3)=gcd(3,2)=gcd(2,3mod2)=gcd(2,1)=gcd(1,2mod1)=gcd(1,0)")])]),e._v(" "),r("li",[r("p",[e._v("第二步：除法/取模，")]),e._v(" "),r("p",[e._v("前面已经一步的第二种应用已经证明了，这里再用一种方式引入")]),e._v(" "),r("p",[e._v("Now instead of subtraction, if we divide the smaller number, the algorithm stops when we find remainder 0, The gcd of two integers can be found by repeated application of the division algorithm, this is known as the Euclidean Algorithm. You repeatedly divide the divisor by the remainder until the remainder is 0. The gcd is the last non-zero remainder in this algorithm.")]),e._v(" "),r("p",[e._v("assume a<b,")]),e._v(" "),r("p",[e._v("r=b%a=b mod a => b = qa+r")]),e._v(" "),r("p",[e._v("gcd(a,b)=gcd(a,b%a) = gcd(a, r)")]),e._v(" "),r("p",[e._v("显然如果c是a和b的最大公约数，c可以整除a和b，c|b=c|(qa+r)，所以c必然也能整除r，所以c也是a和r的最大公约数")]),e._v(" "),r("p",[e._v("The following example shows the algorithm")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("# Function to return gcd of a and b\ndef gcd(a, b):\n    if a == 0 :\n        return b\n     \n    return gcd(b%a, a)\n \nFinding the gcd of 81 and 57 by the Euclidean Algorithm:\nb=81\na=57\n\nmethod1: substract\nGCD(a, b) = GCD(b-a, a) = GCD(81-57, 57) = GCD(24, 57) = GCD(57-24, 24)=GCD(33, 24)=GCD(33-24, 24)=GCD(9,24)=GCD(24-9, 9)=GCD(15,9)=GCD(15-9,9)=GCD(6,9)=GCD(9-6,6)=GCD(3,6)=GCD(6-3,3)=GCD(3,3)=GCD(3-3,3)=GCD(0,3)\n=>GCD=3\n\nmethod2: divide\nGCD(a, b) = GCD(b%a, a) = GCD(81%57,57)=GCD(24,57)=GCD(57%24,24)=GCD(9,24)=GCD(24%9,9)=GCD(6,9)=GCD(9%6,6)=GCD(3,6)=GCD(6%3,3)=GCD(0,3)\n=>GCD=3\n另一种表示方法：\n 81 = 1(57) + 24\n57 = 2(24) + 9\n24 = 2(9) + 6\n9 = 1(6) + 3\n6 = 2(3) + 0\n")])])])])]),e._v(" "),r("h3",{attrs:{id:"extended"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#extended"}},[e._v("#")]),e._v(" Extended")]),e._v(" "),r("h4",{attrs:{id:"intro"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#intro"}},[e._v("#")]),e._v(" Intro")]),e._v(" "),r("p",[e._v("So far, we have seen that finding the gcd of two integers r0 and r1 can be done by recursively reducing the operands. However, it turns out that finding the gcd is not the main application of the Euclidean algorithm. An extension of the algorithm allows us to compute modular inverses, which is of major importance in public-key cryptography.")]),e._v(" "),r("p",[e._v("Extended Euclidean algorithm also finds integer coefficients x and y such that:\ngcd(a, b) =  ax + by")]),e._v(" "),r("p",[e._v("It is well known that if the gcd(a, b) = r then there exist integers x and y so that:")]),e._v(" "),r("p",[e._v("gcd(a, b) = x(a) + y(b) = r")]),e._v(" "),r("p",[e._v("By reversing the steps in the Euclidean Algorithm, it is possible to find these integers x and y.")]),e._v(" "),r("p",[e._v("Example 6.5. We consider the extended Euclidean algorithm with r0 = 973 and r1 = 301. On the left-hand side, we compute the standard Euclidean algorithm, i.e., we compute new remainders r2, r3, . . .. Also, we have to compute the integer quotient qi−1 in every iteration. On the right-hand side we compute the coefficients si and ti such that ri = sir0 +tir1. The coefficients are always shown in brackets.")]),e._v(" "),r("table",[r("thead",[r("tr",[r("th",[e._v("i")]),e._v(" "),r("th",[e._v("r"),r("sub",[e._v("i−2")]),e._v(" = q"),r("sub",[e._v("i−1")]),e._v(" · r"),r("sub",[e._v("i−1")]),e._v("+ri")]),e._v(" "),r("th",[e._v("ri = [si]r0 +[ti]r1")])])]),e._v(" "),r("tbody",[r("tr",[r("td",[e._v("2")]),e._v(" "),r("td",[e._v("r2=r0modr1=>r0=q1r1+r2"),r("br"),r("br"),e._v("973 = 3 · 301+70")]),e._v(" "),r("td",[e._v("r2=s2r0+t2r1"),r("br"),r("br"),e._v("70 = [1]r0 +[−3]r1")])]),e._v(" "),r("tr",[r("td",[e._v("3")]),e._v(" "),r("td",[e._v("r3=r1modr2=>r1=q2r2+r3"),r("br"),r("br"),e._v("301 = 4 · 70+21")]),e._v(" "),r("td",[e._v("r3=s3r0+t3r1"),r("br"),r("br"),e._v("21 = 301−4 · 70"),r("br"),e._v("= r1−4(1r0−3 r1)"),r("br"),e._v("= [−4]r0 +[13]r1")])]),e._v(" "),r("tr",[r("td",[e._v("4")]),e._v(" "),r("td",[e._v("r4=r2modr3=>r2=q3r3+r4"),r("br"),r("br"),e._v("70 = 3 · 21+7")]),e._v(" "),r("td",[e._v("r4=s4r0+t4r1"),r("br"),r("br"),e._v("7 =70−3 · 21"),r("br"),e._v("= (1r0−3r1)−3(−4r0+13r1)"),r("br"),e._v("= [13]r0 +[−42]r1")])]),e._v(" "),r("tr",[r("td",[e._v("5")]),e._v(" "),r("td",[e._v("r3=q4r4+r5"),r("br"),r("br"),e._v("1 = 3 · 7+0"),r("br"),e._v("r5==0 return")]),e._v(" "),r("td")])])]),e._v(" "),r("p",[e._v("The algorithm computed the three parameters gcd(973,301) = 7, s = 13 and t = −42. The correctness can be verified by:\ngcd(973,301) = 7 = [13]973+[−42]301 = 12649−12642.")]),e._v(" "),r("p",[e._v("You should carefully watch the algebraic steps taking place in the right column of the example above. In particular, observe that the linear combination on the righthand side is always constructed with the help of the previous linear combinations. We will now derive recursive formulae for computing si and ri in every iteration. Assume we are in iteration with index i. In the two previous iterations we computed the values:\nr"),r("sub",[e._v("i−2")]),e._v(" = [s"),r("sub",[e._v("i−2")]),e._v("]r0 +[t"),r("sub",[e._v("i−2")]),e._v("]r1\nr"),r("sub",[e._v("i−1")]),e._v(" = [s"),r("sub",[e._v("i−1")]),e._v("]r0 +[t"),r("sub",[e._v("i−1")]),e._v("]r1\nIn the current iteration i we first compute the quotient q"),r("sub",[e._v("i−1")]),e._v(" and the new remainder\nri from r"),r("sub",[e._v("i−1")]),e._v(" and r"),r("sub",[e._v("i−2")]),e._v(":\nr"),r("sub",[e._v("i−2")]),e._v(" = q"),r("sub",[e._v("i−1")]),e._v(" · r"),r("sub",[e._v("i−1")]),e._v("+ri.\nThis equation can be rewritten as:\nri = r"),r("sub",[e._v("i−2")]),e._v("−q"),r("sub",[e._v("i−1")]),e._v(" · r"),r("sub",[e._v("i−1")]),e._v("\nRecall that our goal is to represent the new remainder ri as a linear combination of r0 and r1. The core step for achieving this happens now:")]),e._v(" "),r("p",[e._v("we simply substitute r"),r("sub",[e._v("i−2")]),e._v(" and r"),r("sub",[e._v("i−1")]),e._v(":\nri = (s"),r("sub",[e._v("i−2")]),e._v("r0+t"),r("sub",[e._v("i−2")]),e._v("r1)−q"),r("sub",[e._v("i−1")]),e._v("(s"),r("sub",[e._v("i−1")]),e._v("r0+t"),r("sub",[e._v("i−1")]),e._v("r1)")]),e._v(" "),r("p",[e._v("If we rearrange the terms we obtain the desired result:\nri = [s"),r("sub",[e._v("i−2")]),e._v("−q"),r("sub",[e._v("i−1")]),e._v("s"),r("sub",[e._v("i−1")]),e._v("]r0 +[t"),r("sub",[e._v("i−2")]),e._v("−q"),r("sub",[e._v("i−1")]),e._v("t"),r("sub",[e._v("i−1")]),e._v("]r1\nri = [si]r0 +[ti]r1")]),e._v(" "),r("p",[e._v("si=s"),r("sub",[e._v("i−2")]),e._v("−q"),r("sub",[e._v("i−1")]),e._v("s"),r("sub",[e._v("i−1")]),e._v(", ti=t"),r("sub",[e._v("i−2")]),e._v("−q"),r("sub",[e._v("i−1")]),e._v("t"),r("sub",[e._v("i−1")])]),e._v(" "),r("p",[e._v("上面的例子是从i=2开始的，因为r"),r("sub",[e._v("i−2")]),e._v(" = q"),r("sub",[e._v("i−1")]),e._v(" · r"),r("sub",[e._v("i−1")]),e._v("+ri，肯定需要从i-2=0开始即")]),e._v(" "),r("p",[e._v("r0=q1r1+r2开始，所以套用前面推导的公式")]),e._v(" "),r("p",[e._v("si=s"),r("sub",[e._v("i−2")]),e._v("−q"),r("sub",[e._v("i−1")]),e._v("s"),r("sub",[e._v("i−1")]),e._v(", ti=t"),r("sub",[e._v("i−2")]),e._v("−q"),r("sub",[e._v("i−1")]),e._v("t"),r("sub",[e._v("i−1")])]),e._v(" "),r("p",[e._v("当i=2时，")]),e._v(" "),r("p",[e._v("s2=s0-q1s1, t2=t0-q1t1")]),e._v(" "),r("p",[e._v("同时根据 r2=r0-q1r1知道")]),e._v(" "),r("p",[e._v("s2=1, t2=-q1")]),e._v(" "),r("p",[e._v("系数对比得出")]),e._v(" "),r("p",[e._v("=>s0-q1s1=1，t0-q1t1=-q1")]),e._v(" "),r("p",[e._v("q1是第一次模的系数是变量，所以得出s1=0，s0=1，t0=0，t1=1，从而得出下面EEA的算法：")]),e._v(" "),r("p",[e._v("Extended Euclidean Algorithm (EEA)\nInput: positive integers r0 and r1 with r0 > r1\nOutput: gcd(r0, r1), as well as s and t such that gcd(r0, r1) = s · r0+t · r1.\nInitialization:\ns0 = 1 t0 = 0\ns1 = 0 t1 = 1\ni = 1\nAlgorithm:\n1 \tDO\n1.1 \ti = i+1\n1.2 \tri = r"),r("sub",[e._v("i−2")]),e._v(" mod r"),r("sub",[e._v("i−1")]),e._v("\n1.3 \tq"),r("sub",[e._v("i−1")]),e._v(" = (r"),r("sub",[e._v("i−2")]),e._v("−ri)/r"),r("sub",[e._v("i−1")]),e._v("\n1.4 \tsi = s"),r("sub",[e._v("i−2")]),e._v("−q"),r("sub",[e._v("i−1")]),e._v(" · s"),r("sub",[e._v("i−1")]),e._v("\n1.5 \tti = t"),r("sub",[e._v("i−2")]),e._v("−q"),r("sub",[e._v("i−1")]),e._v(" · t"),r("sub",[e._v("i−1")]),e._v("\nWHILE ri <> 0\n2 \t RETURN\ngcd(r0, r1) = r"),r("sub",[e._v("i−1")]),e._v("\ns = s"),r("sub",[e._v("i−1")]),e._v("\nt = t"),r("sub",[e._v("i−1")])]),e._v(" "),r("p",[e._v("We shall do this with the above example:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("r0 = 973 and r1 = 301\nInitialization:\ns0 = 1 t0 = 0\ns1 = 0 t1 = 1\ni = 1\n> round 1: i=2,\n    r2=r0 mod r1=70\n    q1=(r0-r2)/r1=(973-70)/301=3\n    s2=s0-q1s1=1-3*0=1\n    t2=t0-q1t1=0-3*1=-3\n> round 2: i=3,\n    r3=r1 mod r2=21\n    q2=(r1-r3)/r2=(301-21)/70=4\n    s3=s1-q2s2=0-4*1=-4\n    t3=t1-q2t2=1-4*(-3)=13\n> round 3: i=4,\n\tr4=r2 mod r3=7\n\tq3=(r2-r4)/r3=(70-7)/21=3\n\ts4=s2-q3s3=1-3*(-4)=13\n\tt4=t2-q3t3=-3-3*13=-42\n> round 4: i=5,\n\tr5=r3 mod r4=21 mod 7 =0\n\tRETURN:\n\t\tgcd(r0,r1)=r<sub>i-1</sub>=r4=7\n\t\ts=si-1=s4=13\n\t\tt=ti-1=t4=-42\n\t\t\n\n另一种思路\nAs seen above, x and y are results for inputs a and b,\n   a.x + b.y = gcd                      ----(1)  \n\nAnd x1 and y1 are results for inputs b%a and a\n   (b%a).x1 + a.y1 = gcd   \n                    \nWhen we put b%a = (b - (⌊b/a⌋).a) in above, we get following. Note that ⌊b/a⌋ is floor(b/a)\n\n   (b - (⌊b/a⌋).a).x1 + a.y1  = gcd\n\nAbove equation can also be written as below\n   b.x1 + a.(y1 - (⌊b/a⌋).x1) = gcd      ---(2)\n\nAfter comparing coefficients of 'a' and 'b' in (1) and (2), we get following\n   x = y1 - ⌊b/a⌋ * x1\n   y = x1\n   \ndef gcdExtended(a, b):\n    # Base Case\n    if a == 0 : \n        return b, 0, 1\n            \n    gcd, x1, y1 = gcdExtended(b%a, a)\n    \n    # Update x and y using results of recursive\n    # call\n    x = y1 - (b//a) * x1\n    y = x1\n    \n    return gcd, x, y\n\ngcdExtended(57,81) |返回 gcd,x1,y1=(3,-7,3) , x=3-(81//57)*-7=3+floor(1.4)*7=10 y=-7 对应 3=10(57) -7(81)\n=>\ngcdExtended(81%57,57)=gcdExtended(24,57) |返回 gcd,x1,y1=(3,3,-1) , x=-1-(57//24)*3=-1-floor(2.3)*3=-7 y=3 对应 3=3(57) - 7(24)\n=>\ngcdExtended(57%24,24)=gcdExtended(9,24) |返回 gcd,x1,y1=(3,-1,1) , x=1-(24//9)*-1=1+floor(2.6)=3 y=-1 对应 3=3*9+-1*24\n=>\ngcdExtended(24%9,9)=gcdExtended(6,9) |返回 gcd,x1,y1=(3,1,0) , x=0-(9//6)*1=-1 y=1 对应 3=-1*6+1*9\n=>\ngcdExtended(9%6,6)=gcdExtended(3,6) |返回 gcd,x1,y1=(3,0,1) , x=1-(6//3)*0=1 y=0  对应 3=1*3+0*6\n=>\ngcdExtended(6%3,3)=gcdExtended(0,3) a==0, return 3,0,1 开始返回   \n")])])]),r("h4",{attrs:{id:"calculate-multiplicative-inverse"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#calculate-multiplicative-inverse"}},[e._v("#")]),e._v(" Calculate Multiplicative Inverse")]),e._v(" "),r("p",[e._v("**How is Extended Algorithm Useful? **")]),e._v(" "),r("p",[e._v("The extended Euclidean algorithm is particularly useful when a and b are coprime (or gcd is 1).")]),e._v(" "),r("p",[e._v("The inverse of a exists if and only if gcd(a, b) = 1,")]),e._v(" "),r("p",[e._v("based on  Extended Algorithm We now know that if this is true, there exist integers x and y so that xa + yb = 1.")]),e._v(" "),r("p",[e._v("=>")]),e._v(" "),r("p",[e._v("xa = 1 + (-y)b, or in other words, xa≡1 (mod b). So, x (reduced mod b if need be) is the inverse of a mod b. The extended Euclidean algorithm will give us a method for calculating x efficiently (note that in this application we do not care about the value for y, so we will simply ignore it.)")]),e._v(" "),r("p",[e._v("=>")]),e._v(" "),r("p",[e._v("**x is the modular multiplicative inverse of “a modulo b”, and y is the modular multiplicative inverse of “b modulo a”. **")]),e._v(" "),r("p",[r("strong",[e._v("In particular, the computation of the modular multiplicative inverse is an essential step in RSA public-key encryption method.")])]),e._v(" "),r("p",[e._v("延续前面的r0，r1的写法：")]),e._v(" "),r("p",[e._v("s·r0+t ·r1 =1=gcd(r0, r1)")]),e._v(" "),r("p",[e._v("即 s · r0+t · r1 = 1 两边mod r0")]),e._v(" "),r("p",[e._v("s · r0 mod r0+t · r1 mod r0 = 1 mod r0")]),e._v(" "),r("p",[e._v("=>  s · 0+t · r1 mod r0 ≡ 1 mod r0")]),e._v(" "),r("p",[e._v("=> t · r1 ≡ 1 mod r0\n=> r1 · t ≡ 1 mod r0  means, that t itself is the inverse of r1(mod r0):\nt = r"),r("sub",[e._v("1")]),r("sup",[e._v("−1")]),e._v(" mod r0")]),e._v(" "),r("p",[e._v("同理可知")]),e._v(" "),r("p",[e._v("s=r"),r("sub",[e._v("0")]),r("sup",[e._v("−1")]),e._v(" mod r1")]),e._v(" "),r("p",[e._v("Find the inverse of 15 mod 26.")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("r0 = 26 and r1 = 15\nInitialization:\ns0 = 1 t0 = 0\ns1 = 0 t1 = 1\ni = 1\n> round 1: i=2,\n    r2=r0 mod r1=26mod15=11\n    q1=(r0-r2)/r1=(26-11)/15=1\n    s2=s0-q1s1=1-1*0=1\n    t2=t0-q1t1=0-1*1=-1\n> round 2: i=3,\n    r3=r1 mod r2=15mod11=4\n    q2=(r1-r3)/r2=(15-4)/11=1\n    s3=s1-q2s2=0-1*1=-1\n    t3=t1-q2t2=1-1*(-1)=2\n> round 3: i=4,\n\tr4=r2 mod r3=11mod4=3\n\tq3=(r2-r4)/r3=(11-3)/4=2\n\ts4=s2-q3s3=1-2*(-1)=3\n\tt4=t2-q3t3=-1-2*2=-5\n> round 4: i=5,\n\tr5=r3 mod r4=4 mod 3 =1\n\tq4=(r3-r5)/r4=(4-1)/3=1\n\ts5=s3-q4s4=-1-1*3=-4\n\tt5=t3-q4t4=2-1*(-5)=7\n> round 5: i=6,\n\tr6=r4 mod r5=3mod1=0\n\tRETURN:\n\t\tgcd(r0,r1)=ri-1=r5=1\n\t\ts=si-1=s5=-4\n\t\tt=ti-1=t5=7\n\t\t\ngcd(r0,r1)=sr0+tr1=-4*26+7*15=1\n=>\n7*15=1+4*26≡ 1 (mod 26).\t\n所以the inverse of 15 mod 26 is 7\n \n另一种思路：\nThe Extended Euclidean Algorithm for finding the inverse of a number mod n.\nWe will number the steps of the Euclidean algorithm starting with step 0. The quotient obtained at step i will be denoted by qi. As we carry out each step of the Euclidean algorithm, we will also calculate an auxillary number, pi. For the first two steps, the value of this number is given: p0 = 0 and p1 = 1. For the remainder of the steps, we recursively calculate pi = p<sub>i-2</sub> - p<sub>i-1</sub> q<sub>i-2</sub> (mod n). Continue this calculation for one step beyond the last step of the Euclidean algorithm.\nThe algorithm starts by \"dividing\" n by x. If the last non-zero remainder occurs at step k, then if this remainder is 1, x has an inverse and it is p<sub>k+2</sub>. (If the remainder is not 1, then x does not have an inverse.) :\nStep 0:\t26 = 1(15) + 11\tp0 = 0, q0=1\nStep 1:\t15 = 1(11) + 4\tp1 = 1, q1=1\nStep 2:\t11 = 2(4) + 3\tp2 = 0 - 1( 1) mod 26 = 25 [ -1 mod 26 =  -1 - 26 * floor(-1/26) = -1 +26 = 25]\nStep 3:\t4 = 1(3) + 1\tp3 = 1 - 25( 1) mod 26 = -24 mod 26 = 2\nStep 4:\t3 = 3(1) + 0\tp4 = 25 - 2( 2) mod 26 = 21\n\nlast non-zeor remainder happens at step 3, and it's 1, x has inverse and it's p<sub>3+2</sub>=p5 = 2 - 21( 1) mod 26 = -19 mod 26 = 7\nNotice that 15(7) = 105 = 1 + 4(26) ≡ 1 (mod 26).\n")])])]),r("h4",{attrs:{id:"multiplicative-inverses-in-galois-fields"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#multiplicative-inverses-in-galois-fields"}},[e._v("#")]),e._v(" Multiplicative inverses in Galois fields")]),e._v(" "),r("p",[e._v("For completeness, we show how the EEA can also be used for computing multiplicative inverses in Galois fields. In modern cryptography this is mainly relevant for the derivation of the AES S-Boxes and for elliptic curve public-key algorithms. The EEA can be used completely analogously with polynomials instead of integers. If we want to compute an inverse in a finite field GF(2"),r("sup",[e._v("m")]),e._v("), the inputs to the algorithm are the field element A(x) and the irreducible polynomial P(x). The EEA computes the auxiliary polynomials s(x) and t(x), as well as the greatest common divisor gcd(P(x),A(x)) such that:\ns(x)P(x)+t(x)A(x) = gcd(P(x),A(x)) = 1\nNote that since P(x) is irreducible, the gcd is always equal to 1. If we take the equation above and reduce both sides modulo P(x), it is straightforward to see that the auxiliary polynomial t(x) is equal to the inverse of A(x):")]),e._v(" "),r("p",[e._v("=> s(x)0+t(x)A(x) ≡ 1 mod P(x)\n=> t(x) ≡ A(x)"),r("sup",[e._v("-1")]),e._v(" mod P(x)\nWe give at this point an example of the algorithm for the small field GF(2"),r("sup",[e._v("3")]),e._v(").")]),e._v(" "),r("p",[e._v("Example 6.7. We are looking for the inverse of A(x) = x"),r("sup",[e._v("2")]),e._v(" in the finite field GF(2"),r("sup",[e._v("3")]),e._v(") with P(x) = x"),r("sup",[e._v("3")]),e._v(" +x+1. The initial values for the t(x) polynomial are: t"),r("sub",[e._v("0")]),e._v("(x) = 0, t"),r("sub",[e._v("1")]),e._v("(x) = 1")]),e._v(" "),r("p",[e._v("r0=P(x) = x"),r("sup",[e._v("3")]),e._v(" +x+1")]),e._v(" "),r("p",[e._v("r1=A(x) = x"),r("sup",[e._v("2")])]),e._v(" "),r("table",[r("thead",[r("tr",[r("th",[e._v("Iteration")]),e._v(" "),r("th",[e._v("r"),r("sub",[e._v("i−2")]),e._v("(x) =[q"),r("sub",[e._v("i−1")]),e._v("(x)] r"),r("sub",[e._v("i−1")]),e._v("(x)+[ri(x)]")]),e._v(" "),r("th",[e._v("t"),r("sub",[e._v("i")]),e._v("(x)  [ri = [si]r0 +[ti]r1]")])])]),e._v(" "),r("tbody",[r("tr",[r("td",[e._v("2")]),e._v(" "),r("td",[e._v("r2=r0modr1=>r0=q1r1+r2"),r("br"),r("br"),e._v("x"),r("sup",[e._v("3")]),e._v(" +x+1 = [x]x"),r("sup",[e._v("2")]),e._v(" +(x+1)")]),e._v(" "),r("td",[e._v("r2=s2r0+t2r1"),r("br"),e._v("x+1 = (x"),r("sup",[e._v("3")]),e._v(" +x+1)+[-x](x"),r("sup",[e._v("2")]),e._v(")"),r("br"),e._v("t2 = t0−q1t1 = 0−x1 ≡ x")])]),e._v(" "),r("tr",[r("td",[e._v("3")]),e._v(" "),r("td",[e._v("x"),r("sup",[e._v("2")]),e._v(" = [x](x+1)+[x]")]),e._v(" "),r("td",[e._v("t3 = t1−q2t2 = 1−x (x) ≡ 1+x"),r("sup",[e._v("2")])])]),e._v(" "),r("tr",[r("td",[e._v("4")]),e._v(" "),r("td",[e._v("x+1 = [1]x+[1]")]),e._v(" "),r("td",[e._v("t4 = t2−q3t3 = x−1(1+x"),r("sup",[e._v("2")]),e._v(")"),r("br"),e._v("t4 ≡ 1+x+x"),r("sup",[e._v("2")])])]),e._v(" "),r("tr",[r("td",[e._v("5")]),e._v(" "),r("td",[e._v("x = [x]1+[0]")]),e._v(" "),r("td",[e._v("Termination since r5 = 0")])])])]),e._v(" "),r("p",[e._v("Note that polynomial coefficients are computed in GF(2), and since addition and multiplication are the same operations, we can always replace a negative coefficient (such as −x) by a positive one. The new quotient and the new remainder that are computed in every iteration are shown in brackets above. The polynomials ti(x) are computed according to the recursive formula that was used for computing the integers ti earlier in this section. The EEA terminates if the remainder is 0, which is the case in the iteration with index 5. The inverse is now given as the last ti(x) value that was computed, i.e., t4(x):\nA(x)"),r("sup",[e._v("−1")]),e._v(" =t(x) =t"),r("sub",[e._v("4")]),e._v("(x) = x"),r("sup",[e._v("2")]),e._v("+x+1.\nHere is the check that t(x) is in fact the inverse of x"),r("sup",[e._v("2")]),e._v(", where we use the properties that x"),r("sup",[e._v("3")]),e._v(" ≡ x+1 mod P(x) and x"),r("sup",[e._v("4")]),e._v(" ≡ x"),r("sup",[e._v("2")]),e._v("+x mod P(x):\nt"),r("sub",[e._v("4")]),e._v("(x) · x"),r("sup",[e._v("2")]),e._v(" = x"),r("sup",[e._v("4")]),e._v("+x"),r("sup",[e._v("3")]),e._v("+x"),r("sup",[e._v("2")]),e._v("\n≡ (x"),r("sup",[e._v("2")]),e._v("+x)+(x+1)+x"),r("sup",[e._v("2")]),e._v(" mod P(x)\n≡ 1 mod P(x)")]),e._v(" "),r("disqus")],1)}),[],!1,null,null,null);t.default=a.exports}}]);