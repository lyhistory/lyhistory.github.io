(window.webpackJsonp=window.webpackJsonp||[]).push([[270],{701:function(n,e,t){"use strict";t.r(e);var o=t(65),i=Object(o.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h2",{attrs:{id:"小车概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小车概述"}},[n._v("#")]),n._v(" 小车概述")]),n._v(" "),t("ul",[t("li",[n._v("底盘\n"),t("ul",[t("li",[n._v("2WD150A")]),n._v(" "),t("li",[n._v("履带")])])]),n._v(" "),t("li",[n._v("控制器\n"),t("ul",[t("li",[n._v("ESP8266")]),n._v(" "),t("li",[n._v("ESP32-C3-DevKitM-1 (ESP32-C3-MINI-1)")])])]),n._v(" "),t("li",[n._v("遥控器\n"),t("ul",[t("li",[n._v("手机连接小车控制器提供的webserver进行网页操控")]),n._v(" "),t("li",[n._v("手机app")]),n._v(" "),t("li",[n._v("控制手柄")])])]),n._v(" "),t("li",[n._v("模块\n"),t("ul",[t("li",[n._v("图传")]),n._v(" "),t("li",[n._v("超声波 "),t("a",{attrs:{href:"https://randomnerdtutorials.com/esp32-hc-sr04-ultrasonic-arduino/",target:"_blank",rel:"noopener noreferrer"}},[n._v("HC-SR04 Ultrasonic Sensor"),t("OutboundLink")],1)])])])]),n._v(" "),t("p",[n._v("参考链接：\n"),t("a",{attrs:{href:"https://www.instructables.com/Arduino-Obstacle-Avoiding-Robot-Car-2WD-With-AA-Ba/",target:"_blank",rel:"noopener noreferrer"}},[n._v("Arduino Obstacle Avoiding Robot Car 2WD With AA Battery"),t("OutboundLink")],1),n._v(" "),t("a",{attrs:{href:"https://github.com/YFROBOT-TM/Yfrobot-Motor-Driver-Library",target:"_blank",rel:"noopener noreferrer"}},[n._v("YFROBOT Motor Driver Library for Arduino 可用模块： L298P / PM-R3 / MD01 / MD02 / MD03 / MD04 / MD_GB36 / IIC_MOTORDRIVER / IIC_MOTORDRIVER_RZ7889 小车套件： VALON / 4WD Mecanum Wheel"),t("OutboundLink")],1)]),n._v(" "),t("p",[t("a",{attrs:{href:"https://www.espressif.com/zh-hans/news/ESP32_Powered_FPV_Car",target:"_blank",rel:"noopener noreferrer"}},[n._v("由 ESP32 驱动的 FPV 汽车"),t("OutboundLink")],1)]),n._v(" "),t("p",[n._v("https://www.youtube.com/watch?v=E2raPpB2aJ0")]),n._v(" "),t("p",[n._v("Arduino智能小车\nhttps://www.hackster.io/goldscrew/arduino-obstacle-avoiding-robot-car-2wd-with-aa-battery-514b3c\nhttps://www.codemahal.com/2wd-robotic-car-arduino\nhttps://www.instructables.com/OSOYOO-2WD-Robot-Car-Starter-Kit/")]),n._v(" "),t("p",[n._v("树莓派 智能小车\n"),t("a",{attrs:{href:"https://yq.aliyun.com/articles/700749?spm=a2c4e.11163080.searchblog.48.32e02ec1I9PHCG",target:"_blank",rel:"noopener noreferrer"}},[n._v("化繁为简！开发者尝鲜阿里小程序云平台，实操讲解如何打造智能小车！"),t("OutboundLink")],1)]),n._v(" "),t("h2",{attrs:{id:"remote-control"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#remote-control"}},[n._v("#")]),n._v(" Remote Control")]),n._v(" "),t("p",[n._v("https://www.youtube.com/watch?v=SVlm7QU5Nkk\nhttps://www.seeedstudio.com/blog/2023/04/13/ble-wifi-remote-using-seeed-studio-xiao-esp32c3/")]),n._v(" "),t("p",[n._v("https://www.e-tinkers.com/2019/11/build-an-esp32-web-server-and-ir-remote/")]),n._v(" "),t("p",[n._v("https://oshwhub.com/satun/c3mini-yao-kong-qi_copy\nhttps://www.youtube.com/watch?v=SVlm7QU5Nkk\nhttps://www.hackster.io/techstudycell/esp32-bluetooth-home-automation-with-ir-remote-control-relay-10d4e8?f=1\nhttps://www.youtube.com/watch?v=dODmsoAu0D4")]),n._v(" "),t("h3",{attrs:{id:"基本控制器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本控制器"}},[n._v("#")]),n._v(" 基本控制器")]),n._v(" "),t("p",[n._v("Remote Control Options for an ESP32-C3 Smart Car")]),n._v(" "),t("ul",[t("li",[t("p",[n._v("低成本、短距离：蓝牙、红外（IR）。")])]),n._v(" "),t("li",[t("p",[n._v("中距离、低功耗：ZigBee、LoRa。")]),n._v(" "),t("ul",[t("li",[n._v("大夏龙雀")])])]),n._v(" "),t("li",[t("p",[n._v("远距离、实时性：4G/5G （LTE LTE stands for Long-Term Evolution. It is a standard for wireless broadband communication, commonly used for high-speed data transfer in cellular networks.)。")]),n._v(" "),t("ul",[t("li",[n._v("4g模块： 中移远")]),n._v(" "),t("li",[n._v("4g模块：EC20")])])]),n._v(" "),t("li",[t("p",[n._v("复杂功能、高扩展性：云平台（如AWS IoT、阿里云IoT）、ROS（机器人操作系统）。")])])]),n._v(" "),t("table",[t("thead",[t("tr",[t("th",[n._v("Method")]),n._v(" "),t("th",[n._v("Technology")]),n._v(" "),t("th",[n._v("Range")]),n._v(" "),t("th",[n._v("Latency")]),n._v(" "),t("th",[n._v("Power Consumption")]),n._v(" "),t("th",[n._v("Ease of Implementation")]),n._v(" "),t("th",[n._v("Pros")]),n._v(" "),t("th",[n._v("Cons")])])]),n._v(" "),t("tbody",[t("tr",[t("td",[n._v("Wi-Fi Web Server")]),n._v(" "),t("td",[n._v("Wi-Fi (ESP32-C3 as AP/STA)")]),n._v(" "),t("td",[n._v("Up to 100m")]),n._v(" "),t("td",[n._v("Medium (~50ms)")]),n._v(" "),t("td",[n._v("High")]),n._v(" "),t("td",[n._v("⭐⭐⭐⭐")]),n._v(" "),t("td",[n._v("- Control via any browser. - No app required.")]),n._v(" "),t("td",[n._v("- Requires Wi-Fi network. - Higher power usage.")])]),n._v(" "),t("tr",[t("td",[n._v("Wi-Fi WebSocket")]),n._v(" "),t("td",[n._v("Wi-Fi (Real-time)")]),n._v(" "),t("td",[n._v("Up to 100m")]),n._v(" "),t("td",[n._v("Low (~10ms)")]),n._v(" "),t("td",[n._v("High")]),n._v(" "),t("td",[n._v("⭐⭐⭐⭐")]),n._v(" "),t("td",[n._v("- Faster than HTTP. - Works on a local network.")]),n._v(" "),t("td",[n._v("- Requires a stable connection.")])]),n._v(" "),t("tr",[t("td",[n._v("Wi-Fi MQTT")]),n._v(" "),t("td",[n._v("Wi-Fi + MQTT Broker")]),n._v(" "),t("td",[n._v("Internet-wide")]),n._v(" "),t("td",[n._v("Medium (~100ms)")]),n._v(" "),t("td",[n._v("Medium")]),n._v(" "),t("td",[n._v("⭐⭐⭐")]),n._v(" "),t("td",[n._v("- Remote control from anywhere. - Supports cloud integration.")]),n._v(" "),t("td",[n._v("- Needs an MQTT broker. - Slight delay.")])]),n._v(" "),t("tr",[t("td",[n._v("Bluetooth Classic")]),n._v(" "),t("td",[n._v("Bluetooth BR/EDR")]),n._v(" "),t("td",[n._v("~10m")]),n._v(" "),t("td",[n._v("Low (~10ms)")]),n._v(" "),t("td",[n._v("Low")]),n._v(" "),t("td",[n._v("⭐⭐⭐")]),n._v(" "),t("td",[n._v("- Works with classic Bluetooth controllers.")]),n._v(" "),t("td",[n._v("- ESP32-C3 lacks Bluetooth Classic.")])]),n._v(" "),t("tr",[t("td",[n._v("Bluetooth LE (BLE)")]),n._v(" "),t("td",[n._v("Bluetooth Low Energy")]),n._v(" "),t("td",[n._v("~10m")]),n._v(" "),t("td",[n._v("Low (~20ms)")]),n._v(" "),t("td",[n._v("Very Low")]),n._v(" "),t("td",[n._v("⭐⭐⭐⭐")]),n._v(" "),t("td",[n._v("- Energy-efficient. - Works with smartphones.")]),n._v(" "),t("td",[n._v("- Less bandwidth than Wi-Fi. - Limited range.")])]),n._v(" "),t("tr",[t("td",[n._v("ESP-NOW")]),n._v(" "),t("td",[n._v("Proprietary ESP32 Protocol")]),n._v(" "),t("td",[n._v("~50m (LOS)")]),n._v(" "),t("td",[n._v("Very Low (~5ms)")]),n._v(" "),t("td",[n._v("Very Low")]),n._v(" "),t("td",[n._v("⭐⭐⭐⭐⭐")]),n._v(" "),t("td",[n._v("- No Wi-Fi required. - Very low latency.")]),n._v(" "),t("td",[n._v("- Limited to ESP-based devices.")])]),n._v(" "),t("tr",[t("td",[n._v("LoRa")]),n._v(" "),t("td",[n._v("Long Range Radio (433MHz - 915MHz)")]),n._v(" "),t("td",[n._v("Up to 10km")]),n._v(" "),t("td",[n._v("High (~500ms+)")]),n._v(" "),t("td",[n._v("Very Low")]),n._v(" "),t("td",[n._v("⭐")]),n._v(" "),t("td",[n._v("- Very long-range.")]),n._v(" "),t("td",[n._v("- Very slow data rate. - Needs extra LoRa module.")])]),n._v(" "),t("tr",[t("td",[n._v("NRF24L01")]),n._v(" "),t("td",[n._v("2.4GHz RF Module")]),n._v(" "),t("td",[n._v("Up to 1km")]),n._v(" "),t("td",[n._v("Low (~10ms)")]),n._v(" "),t("td",[n._v("Low")]),n._v(" "),t("td",[n._v("⭐⭐")]),n._v(" "),t("td",[n._v("- Simple, fast, and reliable.")]),n._v(" "),t("td",[n._v("- Requires additional module. - Not internet-capable.")])]),n._v(" "),t("tr",[t("td",[n._v("IR Remote")]),n._v(" "),t("td",[n._v("Infrared (38kHz)")]),n._v(" "),t("td",[n._v("Up to 5m")]),n._v(" "),t("td",[n._v("Low (~10ms)")]),n._v(" "),t("td",[n._v("Very Low")]),n._v(" "),t("td",[n._v("⭐⭐⭐")]),n._v(" "),t("td",[n._v("- Cheap and simple.")]),n._v(" "),t("td",[n._v("- Needs line-of-sight. - Can be affected by sunlight.")])]),n._v(" "),t("tr",[t("td",[n._v("RF Remote (433MHz/315MHz)")]),n._v(" "),t("td",[n._v("Radio Frequency (RF)")]),n._v(" "),t("td",[n._v("Up to 100m")]),n._v(" "),t("td",[n._v("Low (~20ms)")]),n._v(" "),t("td",[n._v("Low")]),n._v(" "),t("td",[n._v("⭐⭐")]),n._v(" "),t("td",[n._v("- Cheap modules available. - No pairing needed.")]),n._v(" "),t("td",[n._v("- No encryption. - Prone to interference.")])]),n._v(" "),t("tr",[t("td",[n._v("ZigBee")]),n._v(" "),t("td",[n._v("ZigBee（IEEE 802.15.4）")]),n._v(" "),t("td",[n._v("100m")]),n._v(" "),t("td",[n._v("low")]),n._v(" "),t("td",[n._v("low")]),n._v(" "),t("td",[n._v("-")]),n._v(" "),t("td",[n._v("低功耗，支持多设备组网")]),n._v(" "),t("td",[n._v("通信距离较短（通常100米以内）")])]),n._v(" "),t("tr",[t("td",[n._v("4g/5g LTE")]),n._v(" "),t("td",[n._v("基站")]),n._v(" "),t("td",[n._v("不限距离")]),n._v(" "),t("td",[n._v("low")]),n._v(" "),t("td",[n._v("low")]),n._v(" "),t("td",[n._v("不限距离 全球可用")]),n._v(" "),t("td",[n._v("流量费用贵")]),n._v(" "),t("td")])])]),n._v(" "),t("h4",{attrs:{id:"wi-fi-websocket"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#wi-fi-websocket"}},[n._v("#")]),n._v(" Wi-Fi WebSocket")]),n._v(" "),t("p",[n._v("WebSocket provides real-time, low-latency communication between a Web UI or another ESP32 device and your ESP32-C3 smart car over Wi-Fi.")]),n._v(" "),t("p",[n._v("(A) WebSocket Server (Receiver - ESP32-C3 on Smart Car)\nThis ESP32-C3 will receive commands from a WebSocket client (e.g., a web browser or another ESP32).")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#include <WiFi.h>\n#include <WebSocketsServer.h>\nconst char* ssid = "YOUR_SSID";\nconst char* password = "YOUR_PASSWORD";\n\nWebSocketsServer webSocket(81);\n\nvoid handleWebSocketMessage(uint8_t *payload) {\n    Serial.printf("Received: %s\\n", payload);\n    if (strcmp((char*)payload, "FORWARD") == 0) {\n        // Move car forward\n    } else if (strcmp((char*)payload, "STOP") == 0) {\n        // Stop the car\n    }\n}\n\nvoid webSocketEvent(uint8_t num, WStype_t type, uint8_t *payload, size_t length) {\n    if (type == WStype_TEXT) {\n        handleWebSocketMessage(payload);\n    }\n}\n\nvoid setup() {\n    Serial.begin(115200);\n    WiFi.begin(ssid, password);\n    while (WiFi.status() != WL_CONNECTED) {\n        delay(500);\n        Serial.print(".");\n    }\n    Serial.println("Connected!");\n\n    webSocket.begin();\n    webSocket.onEvent(webSocketEvent);\n}\n\nvoid loop() {\n    webSocket.loop();\n}\n\n')])])]),t("p",[n._v("(B) WebSocket Client (Sender - Web Browser)\nUse this simple HTML/JavaScript webpage to control the ESP32 smart car from a browser.")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('<!DOCTYPE html>\n<html>\n<head>\n    <title>ESP32 Car Controller</title>\n</head>\n<body>\n    <button onclick="sendCommand(\'FORWARD\')">Move Forward</button>\n    <button onclick="sendCommand(\'STOP\')">Stop</button>\n    \n    <script>\n        const socket = new WebSocket("ws://ESP32_IP:81");\n\n        socket.onopen = () => console.log("Connected to ESP32");\n        socket.onmessage = (event) => console.log("Received:", event.data);\n\n        function sendCommand(cmd) {\n            socket.send(cmd);\n        }\n    <\/script>\n</body>\n</html>\n')])])]),t("h4",{attrs:{id:"esp-now-esp32-to-esp32-communication"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#esp-now-esp32-to-esp32-communication"}},[n._v("#")]),n._v(" ESP-NOW (ESP32-to-ESP32 Communication)")]),n._v(" "),t("p",[n._v("ESP-NOW is fast (low latency ~5ms), lightweight, and doesn’t require Wi-Fi.")]),n._v(" "),t("p",[n._v("(A) ESP-NOW Receiver (ESP32-C3 on Smart Car)")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#include <esp_now.h>\n#include <WiFi.h>\n\ntypedef struct {\n    char message[32];\n} CarCommand;\n\nvoid OnDataRecv(const uint8_t * mac, const uint8_t *incomingData, int len) {\n    CarCommand command;\n    memcpy(&command, incomingData, sizeof(command));\n    Serial.printf("Received: %s\\n", command.message);\n}\n\nvoid setup() {\n    Serial.begin(115200);\n    WiFi.mode(WIFI_STA);\n    if (esp_now_init() != ESP_OK) {\n        Serial.println("ESP-NOW Init Failed");\n        return;\n    }\n    esp_now_register_recv_cb(OnDataRecv);\n}\n\nvoid loop() {\n}\n')])])]),t("p",[n._v("(B) ESP-NOW Sender (ESP32 Remote)")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#include <esp_now.h>\n#include <WiFi.h>\n\ntypedef struct {\n    char message[32];\n} CarCommand;\n\nCarCommand command;\nesp_now_peer_info_t peerInfo;\nuint8_t receiverMAC[] = {0xXX, 0xXX, 0xXX, 0xXX, 0xXX, 0xXX}; // Replace with receiver ESP32 MAC\n\nvoid sendCommand(const char* cmd) {\n    strcpy(command.message, cmd);\n    esp_now_send(receiverMAC, (uint8_t*)&command, sizeof(command));\n}\n\nvoid setup() {\n    Serial.begin(115200);\n    WiFi.mode(WIFI_STA);\n\n    if (esp_now_init() != ESP_OK) {\n        Serial.println("ESP-NOW Init Failed");\n        return;\n    }\n\n    memcpy(peerInfo.peer_addr, receiverMAC, 6);\n    peerInfo.channel = 0;\n    peerInfo.encrypt = false;\n    esp_now_add_peer(&peerInfo);\n}\n\nvoid loop() {\n    sendCommand("FORWARD");\n    delay(2000);\n    sendCommand("STOP");\n    delay(2000);\n}\n\n')])])]),t("p",[n._v("Note: Replace receiverMAC with the receiver ESP32's MAC Address (use WiFi.macAddress() to get it).")]),n._v(" "),t("h4",{attrs:{id:"nrf24l01-2-4ghz-rf-communication"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nrf24l01-2-4ghz-rf-communication"}},[n._v("#")]),n._v(" NRF24L01 (2.4GHz RF Communication)")]),n._v(" "),t("p",[n._v("NRF24L01 allows ESP32-to-ESP32 communication without Wi-Fi, using radio signals.")]),n._v(" "),t("p",[n._v("Hardware Setup\nConnect the NRF24L01 module to ESP32 via SPI:\nMISO → GPIO 19\nMOSI → GPIO 23\nSCK → GPIO 18\nCSN → GPIO 5\nCE → GPIO 4")]),n._v(" "),t("p",[n._v("(A) NRF24L01 Receiver (ESP32-C3 on Smart Car)")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#include <SPI.h>\n#include <nRF24L01.h>\n#include <RF24.h>\n\nRF24 radio(4, 5); // CE, CSN pins\nconst byte address[] = "00001";\nchar receivedCommand[32];\n\nvoid setup() {\n    Serial.begin(115200);\n    radio.begin();\n    radio.openReadingPipe(0, address);\n    radio.setPALevel(RF24_PA_MIN);\n    radio.startListening();\n}\n\nvoid loop() {\n    if (radio.available()) {\n        radio.read(&receivedCommand, sizeof(receivedCommand));\n        Serial.printf("Received: %s\\n", receivedCommand);\n        // Handle command\n    }\n}\n\n')])])]),t("p",[n._v("(B) NRF24L01 Sender (ESP32 Remote)")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#include <SPI.h>\n#include <nRF24L01.h>\n#include <RF24.h>\n\nRF24 radio(4, 5); // CE, CSN pins\nconst byte address[] = "00001";\n\nvoid setup() {\n    Serial.begin(115200);\n    radio.begin();\n    radio.openWritingPipe(address);\n    radio.setPALevel(RF24_PA_MIN);\n    radio.stopListening();\n}\n\nvoid loop() {\n    char text[] = "FORWARD";\n    radio.write(&text, sizeof(text));\n    Serial.println("Sent FORWARD");\n    delay(2000);\n\n    char stopText[] = "STOP";\n    radio.write(&stopText, sizeof(stopText));\n    Serial.println("Sent STOP");\n    delay(2000);\n}\n\n')])])]),t("h4",{attrs:{id:"lora"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lora"}},[n._v("#")]),n._v(" LORA")]),n._v(" "),t("h4",{attrs:{id:"_4g-5g"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4g-5g"}},[n._v("#")]),n._v(" 4G/5G")]),n._v(" "),t("ol",[t("li",[n._v("通信协议")])]),n._v(" "),t("table",[t("thead",[t("tr",[t("th",[n._v("通信协议")]),n._v(" "),t("th",[n._v("描述")]),n._v(" "),t("th",[n._v("特点")]),n._v(" "),t("th",[n._v("适用场景")])])]),n._v(" "),t("tbody",[t("tr",[t("td",[t("strong",[n._v("4G Cat.1")])]),n._v(" "),t("td",[n._v("中等速率通信协议，适合物联网设备")]),n._v(" "),t("td",[n._v("- 下行速率约10Mbps"),t("br"),n._v("- 低功耗"),t("br"),n._v("- 成本较低")]),n._v(" "),t("td",[n._v("智能表计、共享设备、物流追踪")])]),n._v(" "),t("tr",[t("td",[t("strong",[n._v("4G Cat.4")])]),n._v(" "),t("td",[n._v("高速率通信协议，适合中高带宽需求")]),n._v(" "),t("td",[n._v("- 下行速率约150Mbps"),t("br"),n._v("- 支持语音和定位功能")]),n._v(" "),t("td",[n._v("远程监控、智能交通、工业物联网")])]),n._v(" "),t("tr",[t("td",[t("strong",[n._v("5G")])]),n._v(" "),t("td",[n._v("超高速率通信协议，支持低延迟和高带宽")]),n._v(" "),t("td",[n._v("- 下行速率可达Gbps级别"),t("br"),n._v("- 超低延迟")]),n._v(" "),t("td",[n._v("自动驾驶、远程医疗、工业自动化")])]),n._v(" "),t("tr",[t("td",[t("strong",[n._v("NB-IoT")])]),n._v(" "),t("td",[n._v("窄带物联网协议，适合低功耗、低速率场景")]),n._v(" "),t("td",[n._v("- 超低功耗"),t("br"),n._v("- 覆盖范围广"),t("br"),n._v("- 成本低")]),n._v(" "),t("td",[n._v("智能表计、环境监测、农业物联网")])])])]),n._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[n._v("4G/5G通信模块")])]),n._v(" "),t("table",[t("thead",[t("tr",[t("th",[n._v("模块名称")]),n._v(" "),t("th",[n._v("描述")]),n._v(" "),t("th",[n._v("特点")]),n._v(" "),t("th",[n._v("适用场景")]),n._v(" "),t("th",[n._v("与其他模块的区别")])])]),n._v(" "),t("tbody",[t("tr",[t("td",[t("strong",[n._v("ML307R")])]),n._v(" "),t("td",[n._v("中移物联推出的4G Cat.1通信模块")]),n._v(" "),t("td",[n._v("- 支持4G LTE Cat.1"),t("br"),n._v("- 低功耗"),t("br"),n._v("- 内置GNSS定位")]),n._v(" "),t("td",[n._v("智能表计、共享设备、物流追踪")]),n._v(" "),t("td",[n._v("速率较低，适合低成本场景；SIM7600和EC20速率更高，功能更强大")])]),n._v(" "),t("tr",[t("td",[t("strong",[n._v("SIM7600")])]),n._v(" "),t("td",[n._v("SIMCom推出的4G LTE Cat.4模块")]),n._v(" "),t("td",[n._v("- 支持4G LTE Cat.4"),t("br"),n._v("- 内置GNSS"),t("br"),n._v("- 支持语音通话")]),n._v(" "),t("td",[n._v("远程监控、智能交通、工业物联网")]),n._v(" "),t("td",[n._v("速率较高，功能丰富；ML307R速率较低，适合低成本场景")])]),n._v(" "),t("tr",[t("td",[t("strong",[n._v("Quectel EC20")])]),n._v(" "),t("td",[n._v("Quectel推出的4G LTE Cat.4模块")]),n._v(" "),t("td",[n._v("- 支持全球频段"),t("br"),n._v("- 下行速率150Mbps"),t("br"),n._v("- 内置GNSS")]),n._v(" "),t("td",[n._v("远程监控、智能交通、工业物联网")]),n._v(" "),t("td",[n._v("速率较高，适合全球化应用；ML307R速率较低，适合低成本场景")])]),n._v(" "),t("tr",[t("td",[t("strong",[n._v("Quectel RM500Q")])]),n._v(" "),t("td",[n._v("Quectel推出的5G模块")]),n._v(" "),t("td",[n._v("- 支持5G超高速率和低延迟"),t("br"),n._v("- 适合高带宽应用")]),n._v(" "),t("td",[n._v("自动驾驶、远程医疗、工业自动化")]),n._v(" "),t("td",[n._v("速率和性能远超4G模块（如ML307R、SIM7600、EC20），但成本较高")])])])]),n._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[n._v("固件")])]),n._v(" "),t("table",[t("thead",[t("tr",[t("th",[n._v("固件类型")]),n._v(" "),t("th",[n._v("描述")]),n._v(" "),t("th",[n._v("特点")]),n._v(" "),t("th",[n._v("适用场景")])])]),n._v(" "),t("tbody",[t("tr",[t("td",[t("strong",[n._v("AT固件")])]),n._v(" "),t("td",[n._v("基于AT指令的通信模块固件")]),n._v(" "),t("td",[n._v("- 简单易用"),t("br"),n._v("- 支持多种通信模块（如ML307R、SIM7600、Quectel模块）")]),n._v(" "),t("td",[n._v("嵌入式开发、模块控制")])]),n._v(" "),t("tr",[t("td",[t("strong",[n._v("QuecOpen")])]),n._v(" "),t("td",[n._v("Quectel提供的开发平台固件")]),n._v(" "),t("td",[n._v("- 提供高级API和功能"),t("br"),n._v("- 支持二次开发")]),n._v(" "),t("td",[n._v("工业物联网、车联网、远程监控")])]),n._v(" "),t("tr",[t("td",[t("strong",[n._v("自定义固件")])]),n._v(" "),t("td",[n._v("用户根据需求开发的固件")]),n._v(" "),t("td",[n._v("- 高度定制化"),t("br"),n._v("- 适合特定应用场景")]),n._v(" "),t("td",[n._v("特殊需求项目、科研开发")])])])]),n._v(" "),t("h4",{attrs:{id:"遥控器现成开源产品"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#遥控器现成开源产品"}},[n._v("#")]),n._v(" 遥控器现成开源产品")]),n._v(" "),t("ul",[t("li",[n._v("M5Stack M5At")]),n._v(" "),t("li",[n._v("M5Stack JoyC+M5StickC")])]),n._v(" "),t("h3",{attrs:{id:"transmitter-with-joysticks"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#transmitter-with-joysticks"}},[n._v("#")]),n._v(" Transmitter with Joysticks")]),n._v(" "),t("h4",{attrs:{id:"esp32-esp-now-joystick-controller-tutorial"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#esp32-esp-now-joystick-controller-tutorial"}},[n._v("#")]),n._v(" ESP32 + ESP-NOW Joystick Controller Tutorial")]),n._v(" "),t("p",[n._v("https://www.instructables.com/ESP-NOW-Remote-Control/")]),n._v(" "),t("h4",{attrs:{id:"esp32-nrf24l01-joystick"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#esp32-nrf24l01-joystick"}},[n._v("#")]),n._v(" ESP32 + nrf24l01 joystick")]),n._v(" "),t("p",[n._v("https://github.com/walcht/nRF-transmitter\nhttps://forum.dronebotworkshop.com/2018/the-nrf24l01-wireless-joystick-for-arduino-robot-car-with-nrf24l01/\nhttps://www.youtube.com/watch?v=lhGXAJj8rJw")]),n._v(" "),t("h2",{attrs:{id:"image-video-transmission-图传"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#image-video-transmission-图传"}},[n._v("#")]),n._v(" Image/Video Transmission 图传")]),n._v(" "),t("table",[t("thead",[t("tr",[t("th",[n._v("Option")]),n._v(" "),t("th",[n._v("Resolution")]),n._v(" "),t("th",[n._v("Latency")]),n._v(" "),t("th",[n._v("Range")]),n._v(" "),t("th",[n._v("Difficulty Level")]),n._v(" "),t("th",[n._v("Use Case")])])]),n._v(" "),t("tbody",[t("tr",[t("td",[n._v("ESP32-CAM (Wi-Fi Streaming)")]),n._v(" "),t("td",[n._v("Up to 1600x1200")]),n._v(" "),t("td",[n._v("Medium")]),n._v(" "),t("td",[n._v("Short (~30m)")]),n._v(" "),t("td",[n._v("Medium")]),n._v(" "),t("td",[n._v("Live video to mobile/web browser")])]),n._v(" "),t("tr",[t("td",[n._v("ESP32-CAM (ESP-NOW + Wi-Fi Hybrid)")]),n._v(" "),t("td",[n._v("Up to 1600x1200")]),n._v(" "),t("td",[n._v("Medium")]),n._v(" "),t("td",[n._v("Medium (~100m)")]),n._v(" "),t("td",[n._v("Hard")]),n._v(" "),t("td",[n._v("Streaming with low-latency control")])]),n._v(" "),t("tr",[t("td",[n._v("ESP32-CAM + NRF24L01")]),n._v(" "),t("td",[n._v("Up to 800x600")]),n._v(" "),t("td",[n._v("Medium-High")]),n._v(" "),t("td",[n._v("Long (~1km)")]),n._v(" "),t("td",[n._v("Hard")]),n._v(" "),t("td",[n._v("Video + control over radio")])]),n._v(" "),t("tr",[t("td",[n._v("Analog FPV (Dedicated FPV Camera + 5.8GHz Transmitter)")]),n._v(" "),t("td",[n._v("480p-720p")]),n._v(" "),t("td",[n._v("Very Low")]),n._v(" "),t("td",[n._v("Very Long (~5km)")]),n._v(" "),t("td",[n._v("Medium")]),n._v(" "),t("td",[n._v("FPV drone/car setup")])]),n._v(" "),t("tr",[t("td",[n._v("ESP32 with LoRa (for images, not real-time video)")]),n._v(" "),t("td",[n._v("Low  800x600")]),n._v(" "),t("td",[n._v("High")]),n._v(" "),t("td",[n._v("Very Long (~10km)")]),n._v(" "),t("td",[n._v("Hard")]),n._v(" "),t("td",[n._v("Slow image transfer over long distances")])]),n._v(" "),t("tr",[t("td",[n._v("ESP32-S3 + OV5640 (Higher Resolution Camera)")]),n._v(" "),t("td",[n._v("2592x1944")]),n._v(" "),t("td",[n._v("Medium")]),n._v(" "),t("td",[n._v("Short (~30m)")]),n._v(" "),t("td"),n._v(" "),t("td")]),n._v(" "),t("tr",[t("td",[n._v("ESP32 with USB Camera (UVC)")]),n._v(" "),t("td",[n._v("1080p")]),n._v(" "),t("td",[n._v("Medium")]),n._v(" "),t("td",[n._v("Short (~50m)")]),n._v(" "),t("td"),n._v(" "),t("td")]),n._v(" "),t("tr",[t("td",[n._v("ESP32 + RTSP Streaming (ESP32-CAM or S3)")]),n._v(" "),t("td",[n._v("1080p")]),n._v(" "),t("td",[n._v("Medium")]),n._v(" "),t("td",[n._v("Medium(~100m)")]),n._v(" "),t("td"),n._v(" "),t("td")]),n._v(" "),t("tr",[t("td",[n._v("5.8GHz FPV Camera (Dedicated FPV System)")]),n._v(" "),t("td",[n._v("720p-1080p")]),n._v(" "),t("td",[n._v("Very Low")]),n._v(" "),t("td",[n._v("Very Long (~5km)")]),n._v(" "),t("td"),n._v(" "),t("td")]),n._v(" "),t("tr",[t("td",[n._v("ESP32 + LTE Module (4G Streaming)")]),n._v(" "),t("td",[n._v("1080p")]),n._v(" "),t("td",[n._v("Medium-High")]),n._v(" "),t("td",[n._v("Unlimited (cellular)")]),n._v(" "),t("td"),n._v(" "),t("td")]),n._v(" "),t("tr",[t("td",[n._v("Raspberry Pi + CSI Camera ESP32 Sends Control Commands via UART or I2C to Raspberry Pi")]),n._v(" "),t("td",[n._v("4K")]),n._v(" "),t("td",[n._v("Low")]),n._v(" "),t("td",[n._v("Long (~300m with Wi-Fi)")]),n._v(" "),t("td"),n._v(" "),t("td")])])]),n._v(" "),t("h3",{attrs:{id:"esp32-s3-ov5640-higher-resolution-camera"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#esp32-s3-ov5640-higher-resolution-camera"}},[n._v("#")]),n._v(" ESP32-S3 + OV5640 (Higher Resolution Camera)")]),n._v(" "),t("h3",{attrs:{id:"enable-360-degree-camera-rotation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#enable-360-degree-camera-rotation"}},[n._v("#")]),n._v(" enable 360-degree camera rotation")]),n._v(" "),t("table",[t("thead",[t("tr",[t("th",[n._v("Method")]),n._v(" "),t("th",[n._v("Description")]),n._v(" "),t("th",[n._v("Pros")]),n._v(" "),t("th",[n._v("Cons")])])]),n._v(" "),t("tbody",[t("tr",[t("td",[n._v("1. Servo-Based Pan-Tilt Mechanism")]),n._v(" "),t("td",[n._v("Uses two servo motors (one for pan, one for tilt) to move the camera.")]),n._v(" "),t("td",[n._v("✅ Simple to implement  ✅ Works with all cameras")]),n._v(" "),t("td",[n._v("❌ Limited movement speed  ❌ Servo jitter")])]),n._v(" "),t("tr",[t("td",[n._v("2. Stepper Motor 360° Rotation Base")]),n._v(" "),t("td",[n._v("Uses a stepper motor to rotate the entire camera module.")]),n._v(" "),t("td",[n._v("✅ Precise 360° rotation  ✅ Stable movement")]),n._v(" "),t("td",[n._v("❌ More complex than servos  ❌ Requires driver circuit")])]),n._v(" "),t("tr",[t("td",[n._v("3. DC Motor with Slip Ring (Continuous Rotation)")]),n._v(" "),t("td",[n._v("Uses a DC motor + slip ring to allow continuous, unrestricted 360° rotation.")]),n._v(" "),t("td",[n._v("✅ Infinite rotation  ✅ Smooth movement")]),n._v(" "),t("td",[n._v("❌ Harder to control positioning  ❌ Requires motor driver")])]),n._v(" "),t("tr",[t("td",[n._v("4. ESP32-CAM with a Rotating Mirror (Periscope Style)")]),n._v(" "),t("td",[n._v("Uses a small rotating mirror in front of the fixed camera lens to redirect the view.")]),n._v(" "),t("td",[n._v("✅ No need to move camera  ✅ Works with fixed ESP32-CAM")]),n._v(" "),t("td",[n._v("❌ Optical distortion possible  ❌ Complex mirror system")])])])]),n._v(" "),t("h2",{attrs:{id:"控制器-图传"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#控制器-图传"}},[n._v("#")]),n._v(" 控制器+图传")]),n._v(" "),t("p",[n._v("Recommended Libraries and Frameworks to Search on GitHub")]),n._v(" "),t("ul",[t("li",[t("p",[t("a",{attrs:{href:"https://github.com/espressif/esp32-camera",target:"_blank",rel:"noopener noreferrer"}},[n._v("ESP32 Camera Library: The esp32-camera library for integrating cameras with the ESP32. This can be used in conjunction with other remote control methods."),t("OutboundLink")],1)])]),n._v(" "),t("li",[t("p",[t("a",{attrs:{href:"https://github.com/me-no-dev/ESPAsyncWebServer",target:"_blank",rel:"noopener noreferrer"}},[n._v("ESP32 WebSocket Libraries: For controlling your robot via a WebSocket server, you can use libraries like ESPAsyncWebServer or WebSocketsServer."),t("OutboundLink")],1)])]),n._v(" "),t("li",[t("p",[n._v("ESP32 Joystick Library: You can use a library like ESP32 Joystick to help interface with joysticks.")])])]),n._v(" "),t("h3",{attrs:{id:"option-1-mobile-app-for-remote-control"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#option-1-mobile-app-for-remote-control"}},[n._v("#")]),n._v(" Option 1 Mobile App for Remote Control")]),n._v(" "),t("p",[n._v("WebSocket Control + Video Streaming")]),n._v(" "),t("p",[n._v('Search on GitHub: You can search for active repositories on GitHub by searching these terms:\n"ESP32-CAM WebSocket control"\n"ESP32 robot WiFi camera"\n"ESP32-CAM live video feed control"')]),n._v(" "),t("h3",{attrs:{id:"option-2-esp32-and-joystick-controller-with-display"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#option-2-esp32-and-joystick-controller-with-display"}},[n._v("#")]),n._v(" Option 2 ESP32 and Joystick/Controller with Display")]),n._v(" "),t("p",[n._v("TFT Display\nOLED Display")]),n._v(" "),t("p",[n._v('Search on GitHub: Similarly, you can search for "ESP32 Joystick TFT control" or "ESP32 robot joystick with display" to find available joystick-controlled robot projects.')]),n._v(" "),t("h3",{attrs:{id:"option-3-esp32-and-joystick-controller-mobile-app-for-image-video-transmission"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#option-3-esp32-and-joystick-controller-mobile-app-for-image-video-transmission"}},[n._v("#")]),n._v(" Option 3 ESP32 and  Joystick/Controller + Mobile app for Image/Video transmission")]),n._v(" "),t("p",[n._v("就是前两者的配合，典型的就是遥控器配上手机")]),n._v(" "),t("h2",{attrs:{id:"实战"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实战"}},[n._v("#")]),n._v(" 实战")]),n._v(" "),t("h3",{attrs:{id:"_2wd-esp8266小车-esp32-遥控-espnow"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2wd-esp8266小车-esp32-遥控-espnow"}},[n._v("#")]),n._v(" 2wd esp8266小车 + esp32 遥控 (espnow)")]),n._v(" "),t("h4",{attrs:{id:"小车接线和代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小车接线和代码"}},[n._v("#")]),n._v(" 小车接线和代码")]),n._v(" "),t("p",[n._v("清单：")]),n._v(" "),t("ul",[t("li",[n._v("2wd小车底盘")]),n._v(" "),t("li",[n._v("电机*2")]),n._v(" "),t("li",[n._v("万向轮")]),n._v(" "),t("li",[t("a",{attrs:{href:"https://www.instructables.com/Distance-Measurement-Using-HC-SR04-Via-NodeMCU/",target:"_blank",rel:"noopener noreferrer"}},[n._v("超声波 HC-SR04 Ultrasonic Sensor"),t("OutboundLink")],1)]),n._v(" "),t("li",[n._v("ESP8266")]),n._v(" "),t("li",[t("a",{attrs:{href:"https://randomnerdtutorials.com/esp32-dc-motor-l298n-motor-driver-control-speed-direction/",target:"_blank",rel:"noopener noreferrer"}},[n._v("L298N电机驱动"),t("OutboundLink")],1)]),n._v(" "),t("li",[n._v("废旧7000mAh充电宝+升压模块（淘宝DP2 15W）")]),n._v(" "),t("li",[n._v("todo "),t("a",{attrs:{href:"https://www.techcoil.com/blog/how-to-control-a-sg90-servo-motor-with-the-esp8266-nodemcu-lua-development-board/",target:"_blank",rel:"noopener noreferrer"}},[n._v("SG90舵机云台"),t("OutboundLink")],1)]),n._v(" "),t("li",[n._v("todo ESP23CAM")])]),n._v(" "),t("p",[n._v("接线")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\n电源    --------------  L298N电机驱动\n正极 -------------------------  12V\n负极 -------------------------  GND\n\nESP8266  --------------  超声波 HC-SR04 \n3.3V    -------------------------   VCC\nGND -------------------------   GND\nD4  -------------------------   Trigger Pin\nD0  -------------------------   Echo Pin\n\nESP8266  --------------  L298N电机驱动\nVIN -------------------------   5V (电机给ESP供电)\nGND -------------------------   GND\nD6  -------------------------   ENA \nD8  -------------------------   IN1\t(motorPinA1)\nD7  -------------------------   IN2\t(motorPinA2)\nD2  -------------------------   IN3 (motorPinB2)\nD1  -------------------------   IN4 (motorPinB1)\nD5  -------------------------   ENB\n \n\n电机 -------------- L298N电机驱动\n电机的两级输入线头朝内，然后上面的线接电机驱动的最前面，下面的线接电机驱动的后面第二个\n\n左边电机接电机驱动A侧，右边电机接电机驱动B侧。\n前进时如果哪边电机有反转的情况，将该电机的两电线反接即可。\n\n\n")])])]),t("p",[n._v("代码")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('\n#include <ESP8266WiFi.h>\n#include <espnow.h>\n\nvolatile int enableAvoidCollision;\nvolatile int joystickYMedian;\nvolatile int joystickXMedian;\nvolatile int joystickY;\nvolatile int joystickX;\nvolatile int rotationSensorSpeed;\nvolatile int rotationSensorSpeedAdj;\nvolatile int connectionLostCountdown;\nvolatile int motorASpeed;\nvolatile int motorBSpeed;\nvolatile int motorASpeedAdj;\nvolatile int motorBSpeedAdj;\n\nunsigned long lastTrigger = 0;\n#define timeSeconds 10\n\nconst int trigPin = D4;\nconst int echoPin = D0;\n\n//define sound speed in cm/uS\n#define SOUND_SPEED 0.034\n#define CM_TO_INCH 0.393701\n\nlong duration;\nfloat distanceCm;\n\n// Motor A\nint motorPinA1 = D8; \nint motorPinA2 = D7; \nint enablePinA = D6; \n\n// Motor B\nint motorPinB1 = D1; \nint motorPinB2 = D2; \nint enablePinB = D5;\n\nuint8_t motorPinA1Val;\nuint8_t motorPinA2Val;\nint enablePinAVal;\nuint8_t motorPinB1Val;\nuint8_t motorPinB2Val;\nint enablePinBVal;\n\nvoid OnDataRecv(uint8_t * mac, uint8_t *incomingData, uint8_t len) {\n  //Serial.printf("Recived Message from MAC:%02X:%02X:%02X:%02X:%02X:%02X\\n", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n  String message = "";\n  for (int i = 0; i < static_cast<int>(len); i++) {\n    message += String(static_cast<char>(incomingData[i]));\n  }\n  enableAvoidCollision = String(String(message).substring(0,1)).toInt();\n  joystickY = String(String(message).substring(1,String(message).indexOf(String("Y")))).toInt();\n  joystickX = String(String(message).substring((String(message).indexOf(String("Y")) + 1),String(message).indexOf(String("X")))).toInt();\n  rotationSensorSpeed = String(String(message).substring((String(message).indexOf(String("X")) + 1),String(message).indexOf(String("A")))).toInt();\n  rotationSensorSpeedAdj = String(String(message).substring((String(message).indexOf(String("A")) + 1),String(message).indexOf(String("B")))).toInt();\n  //046Y45X90A44B\n  // sscanf((char*)incomingData, "%1d%2dY%2dX%2dA%2dB", \n  //      &enableAvoidCollision, &joystickY, &joystickX, \n  //      &rotationSensorSpeed, &rotationSensorSpeedAdj);\n    \n  connectionLostCountdown = 10;\n  lastTrigger = millis();\n  RemoteControlMotorsLogic();\n}\n\nvoid ConnectionLostCountdownTimer() {\n  if (millis() - lastTrigger >= (timeSeconds*1000)) { \n    if (connectionLostCountdown > 0) {\n      connectionLostCountdown = connectionLostCountdown - 1;\n\n    }\n    if (connectionLostCountdown == 0) {\n      motorASpeed = 0;\n      motorBSpeed = 0;\n      enableAvoidCollision = 0;\n      // Serial.println("Motion stopped...");\n    }\n  }\n}\n// 0-37 move forward(0 fast, 37 slow)\n// 38-48 STOP (median-4, median+4)\n// 48-99 move backward (99 fast, 48 slow)\nvoid RemoteControlMotorsLogic() {\n  if (joystickY < joystickYMedian - 4) {\n    if (joystickX > joystickXMedian + 4) {\n      motorASpeed = (map(joystickY, 37, 0, 0, 255)) + (map(joystickX, 49, 99, 0, 255));\n      motorBSpeed = (map(joystickY, 37, 0, 0, 255)) - (map(joystickX, 49, 99, 0, 255));\n\n    }\n    if (joystickX >= joystickXMedian - 4 && joystickX <= joystickXMedian + 4) {\n      motorBSpeed = (map(joystickY, 37, 0, 0, 255));\n      motorASpeed = (map(joystickY, 37, 0, 0, 255));\n\n    }\n    if (joystickX < joystickXMedian - 4) {\n      motorASpeed = (map(joystickY, 37, 0, 0, 255)) + (map(joystickX, 37, 0, 0, (-256)));\n      motorBSpeed = (map(joystickY, 37, 0, 0, 255)) - (map(joystickX, 37, 0, 0, (-256)));\n\n    }\n\n  }\n  if (joystickY >= joystickYMedian - 4 && joystickY <= joystickYMedian + 4) {\n    if (joystickX > joystickXMedian + 4) {\n      motorASpeed = (map(joystickX, 49, 99, 0, 255));\n      motorBSpeed = (map(joystickX, 49, 99, 0, (-256)));\n\n    }\n    if (joystickX >= joystickXMedian - 4 && joystickX <= joystickXMedian + 4) {\n      motorASpeed = 0;\n      motorBSpeed = 0;\n\n    }\n    if (joystickX < joystickXMedian - 4) {\n      motorASpeed = (map(joystickX, 37, 0, 0, (-256)));\n      motorBSpeed = (map(joystickX, 37, 0, 0, 255));\n\n    }\n\n  }\n  if (joystickY > joystickYMedian + 4) {\n    if (joystickX > joystickXMedian + 4) {\n      motorASpeed = (map(joystickY, 49, 99, 0, (-256))) - (map(joystickX, 49, 99, 0, 255));\n      motorBSpeed = (map(joystickY, 49, 99, 0, (-256))) + (map(joystickX, 49, 99, 0, 255));\n\n    }\n    if (joystickX >= joystickXMedian - 4 && joystickX <= joystickXMedian + 4) {\n      motorBSpeed = (map(joystickY, 49, 99, 0, (-256)));\n      motorASpeed = (map(joystickY, 49, 99, 0, (-256)));\n\n    }\n    if (joystickX < joystickXMedian - 4) {\n      motorASpeed = (map(joystickY, 49, 99, 0, (-256))) - (map(joystickX, 37, 0, 0, (-256)));\n      motorBSpeed = (map(joystickY, 49, 99, 0, (-256))) + (map(joystickX, 37, 0, 0, (-256)));\n\n    }\n\n  }\n}\n\nvoid AvoidCollision() {\n  digitalWrite(trigPin, LOW);\n  delayMicroseconds(2);\n  digitalWrite(trigPin, HIGH);\n  delayMicroseconds(10);\n  digitalWrite(trigPin, LOW);\n  // Reads the echoPin, returns the sound wave travel time in microseconds\n  duration = pulseIn(echoPin, HIGH);\n  // Calculate the distance\n  distanceCm = duration * SOUND_SPEED/2;\n  Serial.print("Distance (cm): ");\n  Serial.println(distanceCm);\n  if (distanceCm <= 40) {\n    motorPinA1Val=HIGH;\n    motorPinA2Val=LOW;\n    enablePinAVal=map(constrain(180, 0, 255), 0, 255, 0, 1023);\n    motorPinB1Val=LOW;\n    motorPinB2Val=HIGH;\n    enablePinBVal=map(constrain(180, 0, 255), 0, 255, 0, 1023);\n  }else {\n    motorPinA1Val=HIGH;\n    motorPinA2Val=LOW;\n    enablePinAVal=map(constrain(200, 0, 255), 0, 255, 0, 1023);\n    motorPinB1Val=HIGH;\n    motorPinB2Val=LOW;\n    enablePinBVal=map(constrain(200, 0, 255), 0, 255, 0, 1023);\n  }\n  Serial.print("enablePinAVal:");\n  Serial.println(enablePinAVal);\n  Serial.print("enablePinBVal:");\n  Serial.println(enablePinBVal);\n  digitalWrite(motorPinA1, motorPinA1Val);\n  digitalWrite(motorPinA2, motorPinA2Val);\n  analogWrite(enablePinA, enablePinAVal);\n  \n  digitalWrite(motorPinB1, motorPinB1Val);\n  digitalWrite(motorPinB2, motorPinB2Val);\n  analogWrite(enablePinB, enablePinBVal);\n}\n\nvoid SetMotorDirectionSpeed(){\n  if (rotationSensorSpeedAdj < 40) {\n    motorASpeedAdj = (map(rotationSensorSpeedAdj, 0, 39, 120, 3));\n    motorBSpeedAdj = (map(rotationSensorSpeedAdj, 0, 39, (-120), (-3)));\n  } else {\n    if (rotationSensorSpeedAdj > 59) {\n      motorASpeedAdj = (map(rotationSensorSpeedAdj, 60, 99, (-3), (-120)));\n      motorBSpeedAdj = (map(rotationSensorSpeedAdj, 60, 99, 3, 120));\n    } else {\n      motorASpeedAdj = 0;\n      motorBSpeedAdj = 0;\n    }\n  }\n  // Gear0\n  if (rotationSensorSpeed < 33) {\n    motorPinA1Val=LOW;\n    motorPinA2Val=LOW;\n    enablePinAVal=0;\n    motorPinB1Val=LOW;\n    motorPinB2Val=LOW;\n    enablePinBVal=0;\n  }\n  // Gear1\n  if (rotationSensorSpeed >= 33 && rotationSensorSpeed < 66) {\n    \n    if (motorBSpeed > 0) {\n      motorPinA1Val=HIGH;\n      motorPinA2Val=LOW;\n      enablePinAVal=map(constrain(motorBSpeed + motorBSpeedAdj, 0, 255), 0, 255, 0, 1023);\n    } else if (motorBSpeed < 0) {\n      motorPinA1Val=LOW;\n      motorPinA2Val=HIGH;\n      enablePinAVal=map(constrain(abs(motorBSpeed - motorBSpeedAdj), 0, 255), 0, 255, 0, 1023);\n    } else {\n      motorPinA1Val=LOW;\n      motorPinA2Val=LOW;\n      enablePinAVal=0;\n    }\n    \n    if (motorASpeed > 0) {\n      motorPinB1Val=HIGH;\n      motorPinB2Val=LOW;\n      enablePinBVal=map(constrain(motorASpeed + motorASpeedAdj, 0, 255), 0, 255, 0, 1023);\n    } else if (motorASpeed < 0) {\n      motorPinB1Val=LOW;\n      motorPinB2Val=HIGH;\n      enablePinBVal=map(constrain(abs(motorASpeed - motorASpeedAdj), 0, 255), 0, 255, 0, 1023);\n    } else {\n      motorPinB1Val=LOW;\n      motorPinB2Val=LOW;\n      enablePinBVal=0;\n    }\n  }\n  // Gear2\n  if (rotationSensorSpeed >= 66) {\n    \n    if (motorBSpeed > 0) {\n      motorPinA1Val=HIGH;\n      motorPinA2Val=LOW;\n      enablePinAVal=map(constrain(motorBSpeed + motorBSpeedAdj, 0, 255), 0, 255, 0, 1023);\n\n    } else if (motorBSpeed < 0) {\n      motorPinA1Val=LOW;\n      motorPinA2Val=HIGH;\n      enablePinAVal=map(constrain(abs(motorBSpeed - motorBSpeedAdj), 0, 255), 0, 100, 0, 1023);\n\n    } else {\n      motorPinA1Val=LOW;\n      motorPinA2Val=LOW;\n      enablePinAVal=0;\n    }\n\n    if (motorASpeed > 0) {\n      motorPinB1Val=HIGH;\n      motorPinB2Val=LOW;\n      enablePinBVal=map(constrain(motorASpeed + motorASpeedAdj, 0, 255), 0, 255, 0, 1023);\n    } else if (motorASpeed < 0) {\n      motorPinB1Val=LOW;\n      motorPinB2Val=HIGH;\n      enablePinBVal=map(constrain(abs(motorASpeed - motorASpeedAdj), 0, 255), 0, 100, 0, 1023);\n    } else {\n      motorPinB1Val=LOW;\n      motorPinB2Val=LOW;\n      enablePinBVal=0;\n    }\n  }\n\n  // Serial.print("enablePinAVal:");\n  // Serial.println(enablePinAVal);\n  // Serial.print("enablePinBVal:");\n  // Serial.println(enablePinBVal);\n  digitalWrite(motorPinA1, motorPinA1Val);\n  digitalWrite(motorPinA2, motorPinA2Val);\n  analogWrite(enablePinA, enablePinAVal);\n\n  digitalWrite(motorPinB1, motorPinB1Val);\n  digitalWrite(motorPinB2, motorPinB2Val);\n  analogWrite(enablePinB, enablePinBVal);\n}\nvoid setup(){\n  Serial.begin(115200);\n  enableAvoidCollision = 0;\n  joystickYMedian = 43;\n  joystickXMedian = 43;\n  joystickY = 43;\n  joystickX = 43;\n  rotationSensorSpeed = 0;\n  rotationSensorSpeedAdj = 0;\n  connectionLostCountdown = 0;\n  motorASpeed = 0;\n  motorBSpeed = 0;\n  motorASpeedAdj = 0;\n  motorBSpeedAdj = 0;\n\n  Serial.println("Starting setup...");                                                                                                                                                                                                                                                                                                                          \n  delay(10000);\n  Serial.println("Setup complete.");\n\n  // Set device as a Wi-Fi Station\n  WiFi.mode(WIFI_STA);\n\n  //WiFi.persistent(false);\n  //WiFi.mode(WIFI_AP);\n  //WiFi.disconnect();\n  //WiFi.softAP("ESPNOW", nullptr, 3);\n  //WiFi.softAPdisconnect(false);\n\n  Serial.print("Device MAC:");\n  Serial.println(WiFi.softAPmacAddress());\n\n  // Init ESP-NOW\n  if (esp_now_init() != 0) {\n    Serial.println("Error initializing ESP-NOW");\n    ESP.restart();\n    //return;\n  }\n\n  // Once ESPNow is successfully Init, we will register for recv CB to\n  // get recv packer info\n  esp_now_set_self_role(ESP_NOW_ROLE_SLAVE);\n  esp_now_register_recv_cb(OnDataRecv);\n\n  pinMode(motorPinA1, OUTPUT);\n  pinMode(motorPinA2, OUTPUT);\n  pinMode(enablePinA, OUTPUT);\n  pinMode(motorPinB1, OUTPUT);\n  pinMode(motorPinB2, OUTPUT);\n  pinMode(enablePinB, OUTPUT);\n  pinMode(trigPin, OUTPUT);\n  pinMode(echoPin, INPUT);\n\n  // Set PWM frequency to 25 kHz (above the audible range)\n  analogWriteFreq(25000);\n  // Optionally set PWM resolution; default range is 1023 on ESP8266 (10-bit resolution)\n  analogWriteRange(1023);\n\n}\n\nvoid loop(){\n  ConnectionLostCountdownTimer();\n  if (enableAvoidCollision) {\n    AvoidCollision();\n  } else {\n    SetMotorDirectionSpeed();\n  }\n}\n\n')])])]),t("h4",{attrs:{id:"遥控接线和代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#遥控接线和代码"}},[n._v("#")]),n._v(" 遥控接线和代码")]),n._v(" "),t("p",[n._v("接线")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("ESP32  -----------------  OLED屏\n22  --------------------  SCL（SCK）\n21  --------------------  SDA\n3V  --------------------- VCC\nGND  ------------------- GND\n\nESP32  -----------------  摇杆模块\n34  ---------------------  Y轴\n35 ----------------------  X轴\n26 ----------------------- VCC\n\nESP32  -----------------  电位器模块（上）\n32  --------------------  信号（OUT）\n27 ---------------------   VCC\n\nESP32  -----------------  电位器模块（下）\n33  --------------------  信号（OUT）\n14  ---------------------   VCC\n\nESP32  -----------------  按钮模块\n25  --------------------  信号（S）\n12  ---------------------   GND\n\n稳压电源模块  ----------------- 各模块\n5V  ---------------------   ESP32的Vin\nGND  -------------------   ESP32的GND\nGND  -------------------   摇杆模块的GND\nGND  -------------------   电位器模块（上）的GND\nGND  -------------------   电位器模块（下）的GND\nGND  -------------------   按钮模块的VCC\n\n")])])]),t("p",[n._v("代码(mixly 代码，待翻译成esp32版本)")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('\n#include <U8g2lib.h>\n#include <Wire.h>\n#include <WiFi.h>\n#include <WifiEspNow.h>\n#include <SimpleTimer.h>\n\nU8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, U8X8_PIN_NONE);\nvolatile int Y轴;\nvolatile int X轴;\nvolatile int 上旋钮;\nvolatile int 下旋钮;\nvolatile int 按钮;\nString 数据;\nString 挡位;\nvolatile int 功率修正值;\nString 修正方向;\nuint8_t PEER_5CCF7F0A77FB[] = {0x5C, 0xCF, 0x7F, 0x0A, 0x77, 0xFB};\n\nSimpleTimer timer;\n\nvoid page1() {\n  u8g2.setFont(u8g2_font_timR10_tf);\n  u8g2.setFontPosTop();\n  u8g2.setCursor(0,0);\n  u8g2.print(数据);\n  u8g2.setFont(u8g2_font_timB24_tf);\n  u8g2.setFontPosTop();\n  u8g2.setCursor(15,30);\n  u8g2.print(挡位);\n  u8g2.setCursor(60,30);\n  u8g2.print(修正方向);\n  u8g2.setCursor(80,30);\n  u8g2.print(功率修正值);\n}\n\nbool sendMessage(uint8_t *macAddress, String _data) {\n  bool ok = WifiEspNow.addPeer(macAddress, 0, nullptr, WIFI_IF_STA);\n  if (!ok) return false;\n  uint16_t length = _data.length();\n  char _msg[length];\n  strcpy(_msg, _data.c_str());\n  return WifiEspNow.send(macAddress, reinterpret_cast<const uint8_t*>(_msg), length);\n}\n\nvoid Simple_timer_1() {\n  if (digitalRead(25)) {\n    挡位 = "A";\n\n  } else {\n    if (上旋钮 < 33) {\n      挡位 = "0";\n\n    } else {\n      if (上旋钮 >= 33 && 上旋钮 < 66) {\n        挡位 = "1";\n\n      } else {\n        挡位 = "2";\n\n      }\n\n    }\n\n  }\n  if (下旋钮 < 40) {\n    修正方向 = "A";\n    功率修正值 = (map(下旋钮, 0, 39, 40, 1));\n\n  } else {\n    if (下旋钮 > 59) {\n      修正方向 = \'B\';\n      功率修正值 = (map(下旋钮, 60, 99, 1, 40));\n\n    } else {\n      修正方向 = "0";\n      功率修正值 = 0;\n\n    }\n\n  }\n  u8g2.firstPage();\n  do\n  {\n    page1();\n  }while(u8g2.nextPage());\n}\n\nvoid setup(){\n  u8g2.setI2CAddress(0x3C*2);\n  u8g2.begin();\n  pinMode(26, OUTPUT);\n  pinMode(27, OUTPUT);\n  pinMode(14, OUTPUT);\n  pinMode(12, OUTPUT);\n  Y轴 = 0;\n  X轴 = 0;\n  上旋钮 = 0;\n  下旋钮 = 0;\n  按钮 = 0;\n  数据 = "";\n  挡位 = "";\n  功率修正值 = 0;\n  修正方向 = "";\n  digitalWrite(26,HIGH);\n  digitalWrite(27,HIGH);\n  digitalWrite(14,HIGH);\n  digitalWrite(12,HIGH);\n  u8g2.enableUTF8Print();\n\n  pinMode(25, INPUT);\n\n  WiFi.mode(WIFI_STA);\n\n  Serial.print("当前设备MAC:");\n  Serial.println(WiFi.macAddress());\n\n  bool ok = WifiEspNow.begin();\n  if (!ok) {\n    Serial.println("WifiEspNow初始化失败");\n    ESP.restart();\n  }\n  timer.setInterval(100L, Simple_timer_1);\n\n}\n\nvoid loop(){\n  Y轴 = (map(analogRead(34), 0, 4095, 0, 99));\n  X轴 = (map(analogRead(35), 0, 4095, 0, 99));\n  上旋钮 = (map(analogRead(32), 0, 4095, 0, 99));\n  下旋钮 = (map(analogRead(33), 0, 4095, 0, 99));\n  按钮 = digitalRead(25);\n  数据 = String(按钮) + String(Y轴) + String("Y") + String(X轴) + String("X") + String(上旋钮) + String("A") + String(下旋钮) + String("B");\n  if (sendMessage(PEER_5CCF7F0A77FB, 数据)) {\n  } else {\n  }\n\n  timer.run();\n\n}\n')])])]),t("h3",{attrs:{id:"l298n-rz7889"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#l298n-rz7889"}},[n._v("#")]),n._v(" L298N => rz7889")]),n._v(" "),t("p",[n._v("换成 rz7889驱动")]),n._v(" "),t("p",[n._v("连线图:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("ESP8266  --------------  RZ7886电机驱动\nVIN  -------------------------  5V\nGND  -----------------------  GND\nD1  --------------------------   A-1\nD2  ---------------------- ----  A-2\nD3   --------------------------  B-1\nD4   --------------------------  B-2\n\n左边电机接电机驱动A侧，右边电机接电机驱动B侧。\n前进时如果哪边电机有反转的情况，将该电机的两电线反接即可。\n\n")])])]),t("p",[n._v("代码：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('\n#include <ESP8266WiFi.h>\n#include <espnow.h>\n\nvolatile int enableAvoidCollision;\nvolatile int joystickYMedian;\nvolatile int joystickXMedian;\nvolatile int joystickY;\nvolatile int joystickX;\nvolatile int rotationSensorSpeed;\nvolatile int rotationSensorSpeedAdj;\nvolatile int connectionLostCountdown;\nvolatile int motorASpeed;\nvolatile int motorBSpeed;\nvolatile int motorASpeedAdj;\nvolatile int motorBSpeedAdj;\nvolatile int detour;\n\nunsigned long now = millis();\nunsigned long lastTrigger = 0;\n#define timeSeconds 10\t\t\t\t\t  \nconst int trigPin = 12;\nconst int echoPin = 14;\n\n//define sound speed in cm/uS\n#define SOUND_SPEED 0.034\n#define CM_TO_INCH 0.393701\n\nlong duration;\nfloat distanceCm;\n\n// Motor A\nint motorPinA1 = D1; \nint motorPinA2 = D2; \n\n// Motor B\nint motorPinB1 = D4; \nint motorPinB2 = D5; \n\nvoid OnDataRecv(uint8_t * mac, uint8_t *incomingData, uint8_t len) {\n  //Serial.printf("Recived Message from MAC:%02X:%02X:%02X:%02X:%02X:%02X\\n", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n  String message = "";\n  for (int i = 0; i < static_cast<int>(len); i++) {\n    message += String(static_cast<char>(incomingData[i]));\n  }\n  //Serial.println(message);\n  connectionLostCountdown = 10;\n  lastTrigger = millis();\n  enableAvoidCollision = String(String(message).substring(0,1)).toInt();\n  joystickY = String(String(message).substring(1,String(message).indexOf(String("Y")))).toInt();\n  joystickX = String(String(message).substring((String(message).indexOf(String("Y")) + 1),String(message).indexOf(String("X")))).toInt();\n  rotationSensorSpeed = String(String(message).substring((String(message).indexOf(String("X")) + 1),String(message).indexOf(String("A")))).toInt();\n  rotationSensorSpeedAdj = String(String(message).substring((String(message).indexOf(String("A")) + 1),String(message).indexOf(String("B")))).toInt();\n  RemoteControlMotorsLogic();\n}\n\nvoid ConnectionLostCountdownTimer() {\n  if (connectionLostCountdown > 0) {\n    connectionLostCountdown = connectionLostCountdown - 1;\n\n  }\n  if (connectionLostCountdown == 0) {\n    motorASpeed = 0;\n    motorBSpeed = 0;\n    enableAvoidCollision = 0;\n\n  }\n}\n\nvoid RemoteControlMotorsLogic() {\n  if (joystickY < joystickYMedian - 4) {\n    if (joystickX > joystickXMedian + 4) {\n      motorASpeed = (map(joystickY, 37, 0, 0, 255)) + (map(joystickX, 49, 99, 0, 255));\n      motorBSpeed = (map(joystickY, 37, 0, 0, 255)) - (map(joystickX, 49, 99, 0, 255));\n\n    }\n    if (joystickX >= joystickXMedian - 4 && joystickX <= joystickXMedian + 4) {\n      motorBSpeed = (map(joystickY, 37, 0, 0, 255));\n      motorASpeed = (map(joystickY, 37, 0, 0, 255));\n\n    }\n    if (joystickX < joystickXMedian - 4) {\n      motorASpeed = (map(joystickY, 37, 0, 0, 255)) + (map(joystickX, 37, 0, 0, (-256)));\n      motorBSpeed = (map(joystickY, 37, 0, 0, 255)) - (map(joystickX, 37, 0, 0, (-256)));\n\n    }\n\n  }\n  if (joystickY >= joystickYMedian - 4 && joystickY <= joystickYMedian + 4) {\n    if (joystickX > joystickXMedian + 4) {\n      motorASpeed = (map(joystickX, 49, 99, 0, 255));\n      motorBSpeed = (map(joystickX, 49, 99, 0, (-256)));\n\n    }\n    if (joystickX >= joystickXMedian - 4 && joystickX <= joystickXMedian + 4) {\n      motorASpeed = 0;\n      motorBSpeed = 0;\n\n    }\n    if (joystickX < joystickXMedian - 4) {\n      motorASpeed = (map(joystickX, 37, 0, 0, (-256)));\n      motorBSpeed = (map(joystickX, 37, 0, 0, 255));\n\n    }\n\n  }\n  if (joystickY > joystickYMedian + 4) {\n    if (joystickX > joystickXMedian + 4) {\n      motorASpeed = (map(joystickY, 49, 99, 0, (-256))) - (map(joystickX, 49, 99, 0, 255));\n      motorBSpeed = (map(joystickY, 49, 99, 0, (-256))) + (map(joystickX, 49, 99, 0, 255));\n\n    }\n    if (joystickX >= joystickXMedian - 4 && joystickX <= joystickXMedian + 4) {\n      motorBSpeed = (map(joystickY, 49, 99, 0, (-256)));\n      motorASpeed = (map(joystickY, 49, 99, 0, (-256)));\n\n    }\n    if (joystickX < joystickXMedian - 4) {\n      motorASpeed = (map(joystickY, 49, 99, 0, (-256))) - (map(joystickX, 37, 0, 0, (-256)));\n      motorBSpeed = (map(joystickY, 49, 99, 0, (-256))) + (map(joystickX, 37, 0, 0, (-256)));\n\n    }\n\n  }\n}\n\nfloat checkdistance() {\n  digitalWrite(trigPin, LOW);\n  delayMicroseconds(2);\n  digitalWrite(trigPin, HIGH);\n  delayMicroseconds(10);\n  digitalWrite(trigPin, LOW);\n  // Reads the echoPin, returns the sound wave travel time in microseconds\n  duration = pulseIn(echoPin, HIGH);\n  // Calculate the distance\n  distanceCm = duration * SOUND_SPEED/2;\n  Serial.print("Distance (cm): ");\n  Serial.println(distanceCm);\n  delay(10);\n  return distanceCm;\n}\n\nvoid AvoidCollision() {\n  if (detour == 0) {\n    if (checkdistance() <= 40) {\n      detour = 1;\n\n    }\n\n  } else {\n    if (checkdistance() >= 80) {\n      detour = 0;\n\n    }\n\n  }\n  if (detour == 1) {\n    analogWrite(5, 120);\n    analogWrite(4, 0);\n    analogWrite(0, 0);\n    analogWrite(2, 120);\n\n  } else {\n    analogWrite(5, 150);\n    analogWrite(4, 0);\n    analogWrite(0, 150);\n    analogWrite(2, 0);\n\n  }\n}\n\nvoid setup(){\n  Serial.begin(9600);\n  enableAvoidCollision = 0;\n  joystickYMedian = 43;\n  joystickXMedian = 43;\n  joystickY = 43;\n  joystickX = 43;\n  rotationSensorSpeed = 0;\n  rotationSensorSpeedAdj = 0;\n  connectionLostCountdown = 0;\n  motorASpeed = 0;\n  motorBSpeed = 0;\n  motorASpeedAdj = 0;\n  motorBSpeedAdj = 0;\n  detour = 0;\n\n  // Set device as a Wi-Fi Station\n  WiFi.mode(WIFI_STA);\n\n  //WiFi.persistent(false);\n  //WiFi.mode(WIFI_AP);\n  //WiFi.disconnect();\n  //WiFi.softAP("ESPNOW", nullptr, 3);\n  //WiFi.softAPdisconnect(false);\n\n  Serial.print("Device MAC:");\n  Serial.println(WiFi.softAPmacAddress());\n\n  // Init ESP-NOW\n  if (esp_now_init() != 0) {\n    Serial.println("Error initializing ESP-NOW");\n    //ESP.restart();\n    return;\n  }\n\n  // Once ESPNow is successfully Init, we will register for recv CB to\n  // get recv packer info\n  esp_now_set_self_role(ESP_NOW_ROLE_SLAVE);\n  esp_now_register_recv_cb(OnDataRecv);\n\n  pinMode(5, OUTPUT);\n  pinMode(4, OUTPUT);\n  pinMode(0, OUTPUT);\n  pinMode(2, OUTPUT);\n  pinMode(motorPinA1, OUTPUT);\n  pinMode(motorPinA2, OUTPUT);\n  pinMode(motorPinB1, OUTPUT);\n  pinMode(motorPinB2, OUTPUT);\n  pinMode(trigPin, OUTPUT);\n  pinMode(echoPin, INPUT);\n}\n\nvoid loop(){\n  now = millis();\n  if(now - lastTrigger > (timeSeconds*1000)) {\n    \n    ConnectionLostCountdownTimer();\n    \n  }\n\n  if (rotationSensorSpeedAdj < 40) {\n    motorASpeedAdj = (map(rotationSensorSpeedAdj, 0, 39, 120, 3));\n    motorBSpeedAdj = (map(rotationSensorSpeedAdj, 0, 39, (-120), (-3)));\n\n  } else {\n    if (rotationSensorSpeedAdj > 59) {\n      motorASpeedAdj = (map(rotationSensorSpeedAdj, 60, 99, (-3), (-120)));\n      motorBSpeedAdj = (map(rotationSensorSpeedAdj, 60, 99, 3, 120));\n\n    } else {\n      motorASpeedAdj = 0;\n      motorBSpeedAdj = 0;\n\n    }\n\n  }\n  if (enableAvoidCollision) {\n    AvoidCollision();\n\n  } else {\n    // Gear0\n    if (rotationSensorSpeed < 33) {\n      analogWrite(motorPinA1, 0);\n      analogWrite(motorPinA2, 0);\n      analogWrite(motorPinB1, 0);\n      analogWrite(motorPinB1, 0);\n\n    }\n    // Gear1\n    if (rotationSensorSpeed >= 33 && rotationSensorSpeed < 66) {\n      if (motorBSpeed > 0) {\n        analogWrite(motorPinA1, (map(constrain(motorBSpeed + motorBSpeedAdj, 0, 255), 0, 255, 70, 120)));\n        analogWrite(motorPinA2, 0);\n\n      } else {\n        if (motorBSpeed < 0) {\n          analogWrite(motorPinA1, 0);\n          analogWrite(motorPinA2, (map(constrain(abs(motorBSpeed - motorBSpeedAdj), 0, 255), 0, 255, 70, 120)));\n\n        } else {\n          analogWrite(motorPinA1, 0);\n          analogWrite(motorPinA2, 0);\n\n        }\n\n      }\n      if (motorASpeed > 0) {\n        analogWrite(motorPinB1, (map(constrain(motorASpeed + motorASpeedAdj, 0, 255), 0, 255, 70, 120)));\n        analogWrite(motorPinB2, 0);\n\n      } else {\n        if (motorASpeed < 0) {\n          analogWrite(motorPinB1, 0);\n          analogWrite(motorPinB2, (map(constrain(abs(motorASpeed - motorASpeedAdj), 0, 255), 0, 255, 70, 120)));\n\n        } else {\n          analogWrite(motorPinB1, 0);\n          analogWrite(motorPinB2, 0);\n\n        }\n\n      }\n\n    }\n    // Gear2\n    if (rotationSensorSpeed >= 66) {\n      if (motorBSpeed > 0) {\n        analogWrite(motorPinA1, (map(constrain(motorBSpeed + motorBSpeedAdj, 0, 255), 0, 255, 100, 255)));\n        analogWrite(motorPinA2, 0);\n\n      } else {\n        if (motorBSpeed < 0) {\n          analogWrite(motorPinA1, 0);\n          analogWrite(motorPinA2, (map(constrain(abs(motorBSpeed - motorBSpeedAdj), 0, 255), 0, 100, 70, 255)));\n\n        } else {\n          analogWrite(motorPinA1, 0);\n          analogWrite(motorPinA2, 0);\n\n        }\n\n      }\n      if (motorASpeed > 0) {\n        analogWrite(motorPinB1, (map(constrain(motorASpeed + motorASpeedAdj, 0, 255), 0, 255, 100, 255)));\n        analogWrite(motorPinB2, 0);\n\n      } else {\n        if (motorASpeed < 0) {\n          analogWrite(motorPinB1, 0);\n          analogWrite(motorPinB2, (map(constrain(abs(motorASpeed - motorASpeedAdj), 0, 255), 0, 100, 70, 255)));\n\n        } else {\n          analogWrite(motorPinB1, 0);\n          analogWrite(motorPinB2, 0);\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n')])])]),t("h3",{attrs:{id:"esp32cam-car"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#esp32cam-car"}},[n._v("#")]),n._v(" ESP32CAM car")]),n._v(" "),t("p",[t("a",{attrs:{href:"https://yanjingang.com/blog/?p=6598",target:"_blank",rel:"noopener noreferrer"}},[n._v("ESP32-CAM远程视频监控&底盘控制"),t("OutboundLink")],1)]),n._v(" "),t("p",[t("a",{attrs:{href:"https://www.embeddedbrew.com/post/building-a-webserver-controlled-spy-car-with-esp32-cam-a-step-guide",target:"_blank",rel:"noopener noreferrer"}},[n._v("Building a Webserver-Controlled Spy Car with ESP32-Cam: A Step Guide"),t("OutboundLink")],1)]),n._v(" "),t("h3",{attrs:{id:"_4g小车-2wd-esp8266小车-mobile-app-mqttclient"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4g小车-2wd-esp8266小车-mobile-app-mqttclient"}},[n._v("#")]),n._v(" 4g小车 2wd esp8266小车+mobile app（MQTTClient）")]),n._v(" "),t("p",[n._v("ESP8266 + SIM7600 → Connects to MQTT Broker via Cellular\nBatteries (for powering motors and ESP8266)\nVoltage Regulator (if needed for SIM7600)\nWeb/Mobile App → Publishes commands to MQTT Broker\nMQTT Broker (e.g., HiveMQ Cloud, EMQX, or Mosquitto) → Routes messages")]),n._v(" "),t("h4",{attrs:{id:"连线-wiring"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#连线-wiring"}},[n._v("#")]),n._v(" 连线 Wiring")]),n._v(" "),t("p",[n._v("L298N:\nConnect IN1, IN2, IN3, IN4 to ESP8266 GPIO pins (e.g., D1, D2, D3, D4).\nEnable pins (ENA, ENB) can be connected to PWM pins (e.g., D5, D6) for speed control.")]),n._v(" "),t("p",[n._v("SIM7600:\nConnect TX (SIM7600) → RX (ESP8266)\nConnect RX (SIM7600) → TX (ESP8266)")]),n._v(" "),t("p",[n._v("Power the SIM7600 with 5V/12V (check datasheet).\nEnsure common ground between all components.")]),n._v(" "),t("h4",{attrs:{id:"小车代码-esp8266-code-mqtt-cellular"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小车代码-esp8266-code-mqtt-cellular"}},[n._v("#")]),n._v(" 小车代码 ESP8266 Code (MQTT + Cellular)")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#include <SoftwareSerial.h>\n\n// Motor Control Pins\n#define IN1 D1\n#define IN2 D2\n#define IN3 D3\n#define IN4 D4\n\n// SIM7600 Configuration\nSoftwareSerial sim7600(D7, D8); // RX, TX\n\n// Secure MQTT Configuration\nconst char* BROKER = "broker.emqx.io"; // SSL-enabled public broker\nconst int PORT = 8883; // Standard MQTT SSL port\nconst char* CLIENT_ID = "SecureCar_01";\nconst char* TOPIC = "smartcar/secure/control";\nconst char* USER = "your_username";\nconst char* PASS = "your_password";\n\n// SSL Configuration\nconst char* CA_CERT = ""; // Add CA certificate if required\n\nvoid setup() {\n  Serial.begin(115200);\n  sim7600.begin(115200);\n\n  // Initialize Motor Control\n  pinMode(IN1, OUTPUT);\n  pinMode(IN2, OUTPUT);\n  pinMode(IN3, OUTPUT);\n  pinMode(IN4, OUTPUT);\n  stopCar();\n\n  // Initialize Cellular and Secure MQTT\n  setupCellular();\n  setupSSL();\n  connectMQTT();\n}\n\nvoid loop() {\n  checkMQTTMessages();\n  // Add periodic keep-alive if needed\n}\n\n// ================== SSL Configuration ==================\nvoid setupSSL() {\n  // Configure SSL context\n  sendAT("AT+CMQTTSSLCFG=0,0", "OK", 2000); // Context 0, SSL version (0=ALL)\n  sendAT("AT+CMQTTSSLCFG=0,3,1", "OK", 2000); // Verify mode (1=peer verify)\n  sendAT("AT+CMQTTSSLCFG=0,4,1", "OK", 2000); // SSL version (1=TLS 1.2)\n\n  // Load CA certificate (if using)\n  if(strlen(CA_CERT) > 0) {\n    sendAT("AT+CMQTTSSLCFG=0,1,\\"ca.crt\\"", "OK", 2000);\n    // Use AT+FSUPLOAD to upload certificate first\n  }\n}\n\n// ================== Secure MQTT Connection ==================\nvoid connectMQTT() {\n  sendAT("AT+CMQTTSTART", "OK", 5000);\n  \n  // Acquire client\n  String accqCmd = String("AT+CMQTTACCQ=0,\\"") + CLIENT_ID + "\\",1";\n  sendAT(accqCmd.c_str(), "OK", 5000);\n\n  // Set credentials\n  if(strlen(USER) > 0) {\n    String userCmd = String("AT+CMQTTUSERNAME=0,") + String(strlen(USER)+2) + ",\\"" + USER + "\\"";\n    sendAT(userCmd.c_str(), "OK", 2000);\n  }\n  \n  if(strlen(PASS) > 0) {\n    String passCmd = String("AT+CMQTTPASSWORD=0,") + String(strlen(PASS)+2) + ",\\"" + PASS + "\\"";\n    sendAT(passCmd.c_str(), "OK", 2000);\n  }\n\n  // SSL Connection\n  String connCmd = String("AT+CMQTTCONNECT=0,\\"ssl://") + BROKER + ":" + PORT + "\\",60,1";\n  sendAT(connCmd.c_str(), "OK", 15000);\n\n  // Subscribe to topic\n  String subCmd = String("AT+CMQTTSUB=0,") + String(strlen(TOPIC)+2) + ",1";\n  sendAT(subCmd.c_str(), "OK", 5000);\n  sendAT(TOPIC, "OK", 5000);\n}\n\n// ================== Message Handling ==================\nvoid checkMQTTMessages() {\n  sendAT("AT+CMQTTSUBTOPIC=0,100", ">", 2000);\n  sendAT("", "OK", 5000);\n\n  while(sim7600.available()) {\n    String response = sim7600.readStringUntil(\'\\n\');\n    if(response.indexOf("+CMQTTSUBRECV: 0") != -1) {\n      String payload = sim7600.readStringUntil(\'\\n\');\n      processCommand(payload.charAt(0));\n    }\n  }\n}\n\n// ================== Motor Control Functions ==================\nvoid moveForward() {\n  digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW);\n  digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW);\n}\n\nvoid moveBackward() {\n  digitalWrite(IN1, LOW); digitalWrite(IN2, HIGH);\n  digitalWrite(IN3, LOW); digitalWrite(IN4, HIGH);\n}\n\nvoid turnLeft() {\n  digitalWrite(IN1, LOW); digitalWrite(IN2, HIGH);\n  digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW);\n}\n\nvoid turnRight() {\n  digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW);\n  digitalWrite(IN3, LOW); digitalWrite(IN4, HIGH);\n}\n\nvoid stopCar() {\n  digitalWrite(IN1, LOW); digitalWrite(IN2, LOW);\n  digitalWrite(IN3, LOW); digitalWrite(IN4, LOW);\n}\n\n\n// ================== AT Command Utility ==================\nvoid sendAT(const char* cmd, const char* expected, int timeout) {\n  sim7600.println(cmd);\n  uint64_t start = millis();\n  String response;\n  \n  while(millis() - start < timeout) {\n    while(sim7600.available()) {\n      char c = sim7600.read();\n      response += c;\n      if(response.indexOf(expected) != -1) {\n        Serial.print("Success: ");\n        Serial.println(cmd);\n        return;\n      }\n    }\n  }\n  Serial.print("Timeout: ");\n  Serial.println(cmd);\n}\n')])])]),t("h4",{attrs:{id:"controller控制器网页版"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#controller控制器网页版"}},[n._v("#")]),n._v(" Controller控制器网页版")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('<!DOCTYPE html>\n<html>\n<head>\n    <title>Smart Car Control</title>\n    <style>\n        .control-pad {\n            display: grid;\n            grid-template-columns: repeat(3, 100px);\n            gap: 10px;\n            margin: 50px auto;\n            width: 300px;\n        }\n        button {\n            padding: 20px;\n            font-size: 1.2em;\n            border-radius: 10px;\n        }\n        .center {\n            grid-column: 2;\n        }\n    </style>\n</head>\n<body>\n    <div class="control-pad">\n        <button onclick="sendCommand(\'F\')">↑</button>\n        <button class="center" onclick="sendCommand(\'S\')">Stop</button>\n        <button onclick="sendCommand(\'L\')">←</button>\n        <button onclick="sendCommand(\'B\')">↓</button>\n        <button onclick="sendCommand(\'R\')">→</button>\n    </div>\n\n    <script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.1.0/paho-mqtt.min.js"><\/script>\n    <script>\n        // Use secure WebSocket\n        const client = new Paho.MQTT.Client(\n        "wss://" + "broker.emqx.io:8084/mqtt", \n        "webClient_" + Math.random().toString(16)\n        );\n\n        client.connect({\n        onSuccess: () => console.log("Secure connection established"),\n        onFailure: (err) => console.error("SSL error:", err.errorMessage)\n        });\n\n        function sendCommand(cmd) {\n            const message = new Paho.MQTT.Message(cmd);\n            message.destinationName = "smartcar/control";\n            client.send(message);\n        }\n    <\/script>\n</body>\n</html>\n')])])]),t("h4",{attrs:{id:"controller控制器mobile-app"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#controller控制器mobile-app"}},[n._v("#")]),n._v(" Controller控制器MOBILE APP")]),n._v(" "),t("ul",[t("li",[n._v("MQTT Dashboard (Android/iOS) - Pre-built app\nConfigure connection to your MQTT broker\nCreate buttons to publish to smartcar/control")]),n._v(" "),t("li",[n._v("MIT App Inventor - Custom app:\nUse MQTT extension\nCreate similar button interface")])]),n._v(" "),t("p",[n._v("参考：\n"),t("a",{attrs:{href:"https://juejin.cn/post/7315126213696716838",target:"_blank",rel:"noopener noreferrer"}},[n._v("ESP8266采用AT指令连接华为云服务器(MQTT固件)"),t("OutboundLink")],1)]),n._v(" "),t("p",[t("a",{attrs:{href:"https://www.techfens.com/posts/esp32mqttcar.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("ESP32 远程图传遥控车，基于 MQTT"),t("OutboundLink")],1)]),n._v(" "),t("p",[t("a",{attrs:{href:"https://www.youtube.com/watch?app=desktop&v=kOYJ-4oZ8Ws",target:"_blank",rel:"noopener noreferrer"}},[n._v("MCU with 4G LTE Modem. Connecting with the server anywhere!"),t("OutboundLink")],1)]),n._v(" "),t("h2",{attrs:{id:"troubleshooting"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#troubleshooting"}},[n._v("#")]),n._v(" Troubleshooting")]),n._v(" "),t("h3",{attrs:{id:"l298n电机驱动蜂鸣声-beep-buzz"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#l298n电机驱动蜂鸣声-beep-buzz"}},[n._v("#")]),n._v(" L298N电机驱动蜂鸣声 beep buzz")]),n._v(" "),t("p",[n._v("从"),t("a",{attrs:{href:"https://ask.csdn.net/questions/7475568",target:"_blank",rel:"noopener noreferrer"}},[n._v("这个帖子"),t("OutboundLink")],1),n._v("的评论得到启示")]),n._v(" "),t("p",[n._v("pwm分频可以小点，这样频率高出20000hz就听不到了")]),n._v(" "),t("p",[n._v("在esp32中有配置："),t("code",[n._v("ledcAttachChannel(enable1Pin, freq, resolution, pwmChannel);")]),n._v("\n但是 esp8266 中我没有配置，加上：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// Set PWM frequency to 25 kHz (above the audible range)\n  analogWriteFreq(25000);\n  \n  // Optionally set PWM resolution; default range is 1023 on ESP8266 (10-bit resolution)\n  analogWriteRange(1023);\n\n  int dutyCycle = map(desiredValue, 0, 255, 0, 1023); // convert from 0-255 to 0-1023\n  analogWrite(enablePin, dutyCycle);\n\n")])])]),t("h3",{attrs:{id:"l298n两边电机不一致"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#l298n两边电机不一致"}},[n._v("#")]),n._v(" L298N两边电机不一致")]),n._v(" "),t("p",[n._v("原来是一边加了注释，一边没加，可能导致执行快慢有区别，最好是计算好两个轮子的功率后，同时赋值，给pin输出的逻辑之间间隔太久")]),n._v(" "),t("h3",{attrs:{id:"电机智能往前不能往后"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#电机智能往前不能往后"}},[n._v("#")]),n._v(" 电机智能往前不能往后")]),n._v(" "),t("p",[n._v("esp8266:\n// Motor B\nint motorPinB1 = D2;\nint motorPinB2 = D3;\nint enablePinB = D1;")]),n._v(" "),t("p",[n._v("无法后退，可能是D3这个引脚比较特殊: Enters flash mode if LOW at boot，其他的特殊引脚比如：\n❌ GPIO2 (D4) → Must be HIGH at boot. May cause instability.\n❌ GPIO9 (SD2) & GPIO10 (SD3) → Connected to Flash Memory.\n❌ GPIO16 (D0) → No PWM support, only Digital I/O.")]),n._v(" "),t("h3",{attrs:{id:"a-fatal-esptool-py-error-occurred-failed-to-connect-to-esp8266-timed-out-waiting-for-packet-header"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#a-fatal-esptool-py-error-occurred-failed-to-connect-to-esp8266-timed-out-waiting-for-packet-header"}},[n._v("#")]),n._v(" A fatal esptool.py error occurred: Failed to connect to ESP8266: Timed out waiting for packet header")]),n._v(" "),t("p",[n._v("由于前面遇到的问题，现在超声模块的连接是：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("D3  -------------------------   Trigger Pin\nD4  -------------------------   Echo Pin\n")])])]),t("p",[n._v("遇到这个问题我一度以为是板子坏了，结果拔掉跟超声模块的连接后问题消失，怀疑是pin的连接问题：")]),n._v(" "),t("p",[n._v("Note: D4 HIGH at boot connected to on-board LED, boot fails if pulled LOW")]),n._v(" "),t("p",[n._v("On the ESP8266, D3 is GPIO0 and D4 is GPIO2, and the ESP8266’s boot process requires these pins to be in specific states:")]),n._v(" "),t("ul",[t("li",[n._v("GPIO0 (D3) must be HIGH at boot for the ESP8266 to start normally (if it’s LOW, the chip goes into programming/flash mode).")]),n._v(" "),t("li",[n._v("GPIO2 (D4) also must be HIGH at boot.")])]),n._v(" "),t("p",[n._v("Here's what likely happened:")]),n._v(" "),t("p",[n._v("Trigger on GPIO0: As an output, the trigger pin might be driven LOW (or pulled low by the HC-SR04 module) during boot. This violates the boot condition (GPIO0 must be HIGH), causing the ESP8266 to fail to boot properly or to enter flash mode—resulting in failed uploads.\nEcho on GPIO2: Even if the echo pin behaves normally, if GPIO0 isn’t in the correct state, the board won’t boot as expected.")]),n._v(" "),t("p",[n._v("解决方案：\nAI 回答说可以：\nUse an external pull-up resistor (e.g., 10kΩ to 3.3V) to keep it HIGH at boot.\n不过我尝试没有成功，")]),n._v(" "),t("p",[n._v("然后自己尝试了调换 D3 和 D4 成功了")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("D4  -------------------------   Trigger Pin\nD3  -------------------------   Echo Pin\n")])])]),t("p",[n._v("至于原因，这是AI的回答：\nSwapping the pins can change how the sensor’s output affects the ESP8266’s boot conditions—even though both GPIO0 (D3) and GPIO2 (D4) ideally should be high at boot. Here’s a more detailed explanation:")]),n._v(" "),t("ol",[t("li",[n._v("Different Pin Roles (Input vs. Output):")])]),n._v(" "),t("p",[n._v("In your original setup, you had the Trigger on D3 (GPIO0) and the Echo on D4 (GPIO2).\nThe Trigger pin is an output from the ESP8266, so you actively drive it. In contrast, the Echo pin is an input that the HC-SR04 drives.\nEven if both pins are required to be high at boot, an input pin (Echo) might be influenced by the sensor’s characteristics (for example, if the sensor’s output is low or floating) more than an output pin (Trigger), which is actively driven by your code.")]),n._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[n._v("Internal Pull-up Differences:")])]),n._v(" "),t("p",[n._v("GPIO0 (D3) typically has a weak internal pull-up, but when it is used as an input (Echo), it might more reliably be pulled high by an external resistor or the sensor’s circuitry.\nGPIO2 (D4), while also needing to be high at boot, can be more sensitive to external circuitry. If the sensor’s Echo output isn’t actively driven high (or if it has a tendency to be low when idle), it might force GPIO2 to remain low, preventing a normal boot.")]),n._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[n._v("Sensor Output Characteristics:")])]),n._v(" "),t("p",[n._v("The HC-SR04’s Echo pin may not output a solid HIGH level when idle—its output can be weak or even low if nothing is triggering it.\nWhen you connect this potentially “low” signal to GPIO2 (D4), the ESP8266 might interpret that as a violation of its boot condition.\nSwapping the pins means the Echo signal is now on GPIO0 (D3). In this configuration, if GPIO0’s internal pull-up (or an external pull-up if used) manages to keep the pin high despite the sensor’s output, the board can boot normally.\nPractical Outcome:")]),n._v(" "),t("p",[n._v("Original configuration (Trigger on D3, Echo on D4): The Echo signal on D4 may be inadvertently pulling GPIO2 low during boot, causing upload failures.\nSwapped configuration (Trigger on D4, Echo on D3): The Echo signal on D3 is less likely to drop below the necessary HIGH threshold (due to internal/external pull-up properties or the sensor’s output characteristics), allowing the ESP8266 to boot and upload code properly.")]),n._v(" "),t("p",[n._v("In short, swapping D3 and D4 works because the behavior of the sensor’s Echo output on those two pins is different—likely due to differences in internal pull-up strength and how the sensor interacts with each pin. Even though both pins are required to be high at boot, the sensor’s output may affect one pin (GPIO2/D4) more adversely than the other (GPIO0/D3) when left in its default state.")]),n._v(" "),t("h3",{attrs:{id:"esp8266无法启动"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#esp8266无法启动"}},[n._v("#")]),n._v(" ESP8266无法启动")]),n._v(" "),t("p",[n._v("发现 serial monitor没有任何输出，setup和loop貌似没有执行，怀疑根本没启动，发现是因为为了解决上面上传代码的问题调换了接线：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("D4  -------------------------   Trigger Pin\nD3  -------------------------   Echo Pin\n")])])]),t("p",[n._v("现在代码可以上传了，但是无法启动")]),n._v(" "),t("p",[n._v("Note: D3 connected to FLASH button, boot fails if pulled LOW")]),n._v(" "),t("p",[n._v("AI回答原因：")]),n._v(" "),t("p",[n._v("The ESP8266’s boot process is very sensitive to the state of certain GPIO pins, particularly GPIO0 (commonly D3) and GPIO2 (commonly D4). Here’s what that means and why your wiring might be affecting boot-up:")]),n._v(" "),t("ul",[t("li",[n._v("GPIO0 (D3) and GPIO2 (D4) must be in a specific state (usually pulled HIGH) during power-up for the ESP8266 to exit the bootloader and start running your user code.")]),n._v(" "),t("li",[n._v("If one or both of these pins are pulled LOW at boot, the ESP8266 may enter flash/programming mode (or fail to boot normally). This means it could get stuck in the bootloader, never fully starting your application.")])]),n._v(" "),t("p",[n._v("D3 (GPIO 0) is connected to the Echo pin: The HC-SR04’s Echo pin is an output that starts LOW when idle (before a measurement is triggered). This could pull GPIO 0 LOW during boot, preventing the ESP8266 from starting normally.\nD4 (GPIO 2) is connected to the Trigger pin: The Trigger pin is an input to the HC-SR04 and should be floating or HIGH when idle, so this is less likely to cause an issue unless there’s a wiring problem.\nThe most probable culprit is D3 (GPIO 0) being held LOW by the Echo pin, forcing the ESP8266 into a non-bootable state.")]),n._v(" "),t("p",[n._v("尝试解决方案：")]),n._v(" "),t("p",[n._v("AI说可以尝试 pull up 10kΩ resistor，就是在D3和vcc（3.3v）之间加一个10kΩ的电阻，加上后还是没反应，我测了下此时D3的电压，只有0.2v左右，\n又换成220Ω的，只升了一点点0.25v\nWith the 10kΩ pull-up, D3 was 0.2V. With 220Ω, it’s now 0.25V—slightly higher, but still far below the ~2V needed for the ESP8266 to boot normally.")]),n._v(" "),t("p",[n._v("Voltage Divider Effect:\nThe HC-SR04 Echo pin, when idle (LOW), acts like a low-impedance path to GND (likely <100Ω).\nWith a 220Ω pull-up to 3.3V, the voltage on D3 is determined by the divider:\nV_D3 = 3.3V * (R_Echo / (220Ω + R_Echo)), where R_Echo is the Echo pin’s effective resistance when LOW.\nSolving for R_Echo:\n0.25V = 3.3V * (R_Echo / (220Ω + R_Echo))\n=>\nR_Echo ≈ 18Ω.")]),n._v(" "),t("p",[n._v("The HC-SR04 Echo pin’s LOW state has an effective impedance of ~18Ω—extremely low! This explains why even 220Ω (15mA pull-up current) can’t lift D3 above 0.25V.")]),n._v(" "),t("p",[n._v("Why 220Ω Isn’t Enough\nCurrent: 220Ω provides 3.3V / 220Ω = 15mA to pull D3 HIGH. The Echo pin sinks almost all of this to GND through its ~18Ω impedance, leaving D3 near 0V.")]),n._v(" "),t("p",[n._v("多少欧合适？\nIdea: Use a lower resistance to provide more current and raise D3’s voltage above 2V.\nCalculation: To get >2V with R_Echo ≈ 18Ω:\nV_D3 = 3.3V * (18Ω / (R_pullup + 18Ω)) > 2V\n=>\nR_pullup < 11.7Ω.")]),n._v(" "),t("p",[n._v("潜在问题 Problem: Even 110Ω isn’t enough, and 10Ω (330mA!) risks overheating the resistor or stressing the HC-SR04’s Echo pin (max current ~20-40mA).")]),n._v(" "),t("p",[n._v("所以pull up方案即使可以，高出这么多的电流有可能会让传感器挂掉")]),n._v(" "),t("p",[t("strong",[n._v("最终解决方案")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("D4  -------------------------   Trigger Pin\nD0  -------------------------   Echo Pin\n")])])]),t("p",[n._v("附： 好奇pull up方案如果成功，HC-SR04如何在正常工作的时候把这个pin拉回低电平？")]),n._v(" "),t("p",[n._v("据说是跟内部的transistor有关 When LOW: The HC-SR04 turns on an internal NPN transistor or MOSFET connected between Echo and GND. This creates a low-impedance path to ground")]),n._v(" "),t("ol",[t("li",[n._v("Idle with Pull-Up (D3 Case)")])]),n._v(" "),t("p",[n._v("220Ω Pull-Up: With D3 at 0.25V, the 220Ω (15mA to 3.3V) and ~18Ω to GND form a divider, as we calculated. The transistor’s LOW state wins, but the pull-up keeps D3 above 0V.")]),n._v(" "),t("p",[n._v("Stronger Pull-Up: If you used a much stronger pull-up (e.g., 10Ω, 330mA to 3.3V) to get D3 to 2V when idle:\nV_D3 = 3.3V * (18Ω / (10Ω + 18Ω)) ≈ 2.12V.")]),n._v(" "),t("p",[n._v("This would indeed hold D3 above 2V, making boot possible.\nProblem: During operation, the same ~18Ω transistor would still pull against the 10Ω pull-up, keeping D3 at ~2.12V when LOW—not low enough for the ESP8266 to reliably detect as a logic LOW (<0.8V).")]),n._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[t("p",[n._v("Transistor’s Actual Behavior\n~18Ω is an Estimate: The 18Ω was derived from the idle state with a 220Ω pull-up. In reality, the transistor’s ON resistance (R_ON) is likely lower (e.g., 5-10Ω), and the 0.25V included some measurement or wiring factors. Without a pull-up (like on D0), it pulls closer to 0V.\nActive Drive: When the HC-SR04 switches Echo LOW, the transistor is fully ON, aiming for ~0V. With no pull-up, it achieves this. With a pull-up, the voltage depends on the resistor’s strength.")])]),n._v(" "),t("li",[t("p",[n._v("Can It Pull LOW If Idle is 2V or 3.3V? Let’s test your hypothesis with scenarios:")])])]),n._v(" "),t("p",[n._v("Scenario 1: Idle at 3.3V (Diode Isolation)\nSetup: Echo → Diode → D3, 220Ω pull-up to 3.3V. Idle D3 = 3.3V (diode blocks LOW).\nOperation:\nTrigger: Echo goes HIGH, diode conducts, D3 ≈ 3.3V (or adjusted by divider).\nPost-Pulse: Echo goes LOW (0V), but diode blocks, D3 stays 3.3V via pull-up.\nIssue: pulseIn() won’t work—it needs a HIGH-to-LOW transition. The diode prevents the LOW state, so duration = 0 or infinite.\nFix: Remove the diode or use a buffer—D3 must see the LOW.")]),n._v(" "),t("p",[n._v("Scenario 2: Idle at 2V (Strong Pull-Up)\nSetup: 10Ω pull-up to 3.3V, Echo on D3, idle V_D3 ≈ 2.12V (18Ω vs. 10Ω).\nOperation:\nTrigger: Echo HIGH, D3 ≈ 3.3V.\nPost-Pulse: Echo LOW, D3 back to 2.12V.\nIssue: 2.12V isn’t LOW (<0.8V) for the ESP8266. pulseIn() might not detect the transition, or it’ll misread the duration.\nReality Check: Your D0 setup worked because no pull-up kept LOW near 0V.")]),n._v(" "),t("p",[n._v("所以结论是行不通，即使可能成功boot成功，但是后续会阻止echo从高电平到低电平 无法正常工作")]),n._v(" "),t("h3",{attrs:{id:"esp8266不断重启"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#esp8266不断重启"}},[n._v("#")]),n._v(" esp8266不断重启")]),n._v(" "),t("p",[n._v("观察到 esp8266 后面的蓝色led rear blue led 总会突然熄灭")]),n._v(" "),t("p",[n._v("When motors or other loads suddenly draw extra current, the supply voltage can drop. This can cause the ESP8266 (and its peripherals, like the LED) to reset or behave erratically.")]),n._v(" "),t("p",[n._v("我用的是一个废旧的充电宝加上一个升压模块，很有可能是输出不稳定，当电机工作时会突然导致重启")]),n._v(" "),t("p",[n._v("Make sure your power supply can handle the peak current required by the motors. Consider adding a capacitor (e.g., a 470µF or 1000µF electrolytic capacitor) across the power supply near the ESP8266 to help smooth out transients.")]),n._v(" "),t("h3",{attrs:{id:"esp-now遥控延迟"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#esp-now遥控延迟"}},[n._v("#")]),n._v(" esp-now遥控延迟")]),n._v(" "),t("p",[n._v("Possible Causes:")]),n._v(" "),t("ul",[t("li",[n._v("Radio Interference/Environment:\nESP-NOW is designed for low latency, but in a noisy RF environment or with many obstacles, latency can increase.")]),n._v(" "),t("li",[n._v("Processing Overhead:\nIf your code (such as sensor readings, string parsing, or collision logic) takes significant time, it might delay handling incoming ESP-NOW messages.")]),n._v(" "),t("li",[n._v("ESP8266 Limitations:\nThe ESP8266 is less robust than the ESP32 in handling concurrent tasks, so heavy code in the loop() might introduce delays.")])]),n._v(" "),t("p",[n._v("Optimizing Code:\nSimplify message parsing (e.g., using sscanf() instead of multiple String operations) and try to offload heavy tasks or optimize collision detection logic to reduce delays.")])])}),[],!1,null,null,null);e.default=i.exports}}]);