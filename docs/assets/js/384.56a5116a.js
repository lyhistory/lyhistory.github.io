(window.webpackJsonp=window.webpackJsonp||[]).push([[384],{817:function(e,t,r){"use strict";r.r(t);var s=r(65),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("Refers to\n<"),r("a",{attrs:{href:"Blockchain:EOS"}},[e._v("Blockchain:EOS")]),e._v(">")]),e._v(" "),r("p",[e._v("http://cpp.sh/\nhttps://developers.google.com/edu/c++/")]),e._v(" "),r("p",[e._v("在函数外存取局部变量的一个比喻\nhttps://coolshell.cn/articles/4907.html#/")]),e._v(" "),r("p",[e._v("GCC and MakeCompiling, Linking and BuildingC/C++ Applications\nhttps://www3.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html")]),e._v(" "),r("p",[e._v("8The Build Process - C/C++  https://www.hackerearth.com/practice/notes/build-process-cc/\nhttp://faculty.cs.niu.edu/~mcmahon/CS241/Notes/compile.html\nhttps://www.toptal.com/c-plus-plus/c-plus-plus-understanding-compilation")]),e._v(" "),r("p",[e._v("gcc -v -o hello.exe hello.c")]),e._v(" "),r("p",[e._v("ldd - print shared object dependencies")]),e._v(" "),r("p",[e._v("C++ Primer 5th\nhttps://github.com/Mooophy/Cpp-Primer")]),e._v(" "),r("p",[e._v("expected unqualified-id before ‘(’ token\nhttps://blog.csdn.net/dreamvyps/article/details/80658176\n#undef errno")]),e._v(" "),r("p",[e._v("Virtual destructors are useful when you might potentially delete an instance of a derived class through a pointer to base class\nhttps://stackoverflow.com/questions/461203/when-to-use-virtual-destructors#/\nc++ free 原理")]),e._v(" "),r("p",[e._v("GPU编程CUBA\n锁页内存")]),e._v(" "),r("p",[e._v("RAII模式（Resource Acquisition Is Initialization）资源获取即初始化，是 C++ 中最基本、应用最广范的惯用法（idiom）之一。")]),e._v(" "),r("p",[e._v("RAII 的基本思想是通过构造/析构函数，对资源的获取/释放进行封装，然后借助局部对象的自动生命周期来管理资源。使用 RAII 可以让用户无需手动管理资源的获取/释放，减少出错的机会。不仅如此，RAII 还是异常安全的：即使获取资源后，在使用资源的过程中抛出异常，也可以自动释放，避免资源泄露。")]),e._v(" "),r("p",[e._v("C++ 标准库里面有很多 RAII 的例子，如 unique_ptr、lock_guard、fstream、string 以及 vector 等各类容器。我们在实现自己的类时，也要尽量遵循 RAII。")]),e._v(" "),r("h2",{attrs:{id:"内存模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存模型"}},[e._v("#")]),e._v(" 内存模型")]),e._v(" "),r("p",[e._v("C++ 的内存模型（自 C++11 标准引入）更直接地映射到硬件。它没有“工作内存”和“主内存”这样的抽象概念，而是直接讨论内存位置和内存访问顺序。")]),e._v(" "),r("p",[e._v("核心概念：内存位置与内存序")]),e._v(" "),r("ol",[r("li",[e._v("​内存位置​：")])]),e._v(" "),r("p",[e._v("一个内存位置就是一个标量对象（如 int, char*）或相邻的位域。")]),e._v(" "),r("p",[e._v("基本规则是：​不同的线程可以安全地同时修改不同的内存位置，而不会发生数据竞争。​​")]),e._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[e._v("​内存序​：")])]),e._v(" "),r("p",[e._v("这是 C++ 内存模型的核心和难点。它定义了非原子操作相对于原子操作的可见性顺序。主要有以下几种：")]),e._v(" "),r("p",[e._v("memory_order_relaxed：只保证原子操作的原子性，不提供任何同步或排序约束。性能最好，但最难用对。")]),e._v(" "),r("p",[e._v("memory_order_acquire：通常用于读操作​（load）。保证在本操作之后的所有读写操作不会被重排序到本操作之前。")]),e._v(" "),r("p",[e._v("memory_order_release：通常用于写操作​（store）。保证在本操作之前的所有读写操作不会被重排序到本操作之后。")]),e._v(" "),r("p",[e._v("memory_order_acq_rel：同时具有 acquire 和 release 语义，用于读-改-写操作（如 fetch_add）。")]),e._v(" "),r("p",[e._v("memory_order_seq_cst：​顺序一致性。这是最严格的模式，也是默认模式。它保证所有线程看到的操作顺序是一致的。这最接近 Java 的 volatile语义，但性能开销也最大。")]),e._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[e._v("C++ 的工具（std::atomic, std::mutex）\n​std::atomic​：用于定义原子变量。你可以为每个原子操作指定内存序。")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("std::atomic<int> data(0);\n// 线程 A (生产者)\ndata.store(42, std::memory_order_release); // 相当于“发布”数据\n\n// 线程 B (消费者)\nint value = data.load(std::memory_order_acquire); // 相当于“获取”数据\nif (value == 42) {\n    // 这里能保证看到线程A在store之前的所有写操作\n}\n")])])]),r("p",[e._v("​std::mutex​：互斥锁。在锁的范围内，它天然地创建了一种最强的内存屏障（类似于 memory_order_seq_cst），保证临界区内的操作不会被重排序到锁外，并且解锁操作具有 release 语义，加锁操作具有 acquire 语义。")])])}),[],!1,null,null,null);t.default=a.exports}}]);