(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{536:function(e,t,n){"use strict";n.r(t);var i=n(65),o=Object(i.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("从选材到制作上传视频-全自动化脚本运行\nhttps://mp.weixin.qq.com/s/ZJeNBar21dILzSEiBHI01Q")]),e._v(" "),n("p",[e._v("我自己也创立了油管频道，所以对于油管的教程关注比较多，今天介绍这个教程是关于如何从YouTube Shorts获得免费流量以及如何解放劳动力，使用 python自动化该过程。")]),e._v(" "),n("p",[e._v("教程有些许门槛，涉及一些基础的编程知识，本文涉及很多的下载链接，如果确实没法消化或者不感兴趣，可直接划到最下方领取免费脚本。建议收藏，等到后期需要的时候再拿出来测试。")]),e._v(" "),n("p",[e._v("介绍的是思维以及运作的方法，你需要自己寻找不同的利基市场和货币化选项。")]),e._v(" "),n("p",[e._v("不应该简单地复制本电子书中提到的示例方法。此教程并非致富指南，而是一种经过充分研究的流量变现方法。")]),e._v(" "),n("p",[e._v("在本指南中分享的所有代码都经过测试，并在发布时可正常运行。考虑到YouTube算法可能会发生变化，因此请理解您可能需要调整您的频道策略。")]),e._v(" "),n("p",[e._v("洞察：对于垂直短视频，YouTube和Tiktok还有有一些区别，Youtube并不关心帐户的年龄，只要您可以验证与帐户关联的电话号码和电子邮件就能解锁额外的高级功能，例如在社区帖子和描述中添加链接。不过，YouTube和TikTok一样都是从原籍国推送内容。这意味着，如果您创建一个频道并上传来自爱尔兰的短视频，则超过 90%的视频观看者将来自爱尔兰，YouTube会尝试尽可能将其推送到本地。幸运的是，Youtube可以有办法克服这个问题，这个教程推荐的方法是专用 VPS。全自动短频道运行在具有2GB内存的共享 VPS 上。具有此类规格的虚拟服务器的价格可低至 5 美元/月。如果你不愿意在没赚钱的情况下进行任何投资，你可以先在你的电脑上运行。知道这个算法以及解决的方法就行了。")]),e._v(" "),n("p",[e._v("接来下进入正题：")]),e._v(" "),n("p",[e._v("获取YouTube shorts内容的方法数不胜数，但在本指南中，我将展示卡通和Reddit 故事的示例。这两个示例想法都可以获得大量的日常流量，但这些可能不是货币化的理想的利基。您可以简单地调整下面演示的方法来适应您自己的想法和利基。")]),e._v(" "),n("p",[e._v("栗子1：Short Reddit horror stories")]),e._v(" "),n("p",[e._v("栗子2：Random funny cartoon clips")]),e._v(" "),n("p",[e._v("步骤1：")]),e._v(" "),n("p",[e._v("您将需要Python来运行自动化。截至本指南发布,最稳定的版本将是 3.9.16（不是最新版本）")]),e._v(" "),n("p",[e._v("下载链接：https://www.python.org/downloads/")]),e._v(" "),n("p",[e._v("步骤2：")]),e._v(" "),n("p",[e._v("安装所需的库。为了让事情变得更简单，我们将安装一些 Python库来帮助我们完成自动化过程。要安装库，只需打开终端并输入 pip install library-name")]),e._v(" "),n("p",[e._v("为您的项目创建一个新文件夹，输入 cd 并将该文件夹拖放到终端窗口顶部。然后我们就可以开始安装库了。它应该看起来像这样：")]),e._v(" "),n("p",[e._v("这是我们需要的所有库的列表：")]),e._v(" "),n("p",[e._v("-MoviePy   https://pypi.org/project/moviepy/")]),e._v(" "),n("p",[e._v("-Requests  https://pypi.org/project/requests/")]),e._v(" "),n("p",[e._v("-Naked      https://pypi.org/project/Naked/")]),e._v(" "),n("p",[e._v("-NLTK        https://pypi.org/project/nltk/")]),e._v(" "),n("p",[e._v("-TTS          https://pypi.org/project/TTS/")]),e._v(" "),n("p",[e._v("-BS4          https://pypi.org/project/beautifulsoup4/")]),e._v(" "),n("p",[e._v("其他需求：")]),e._v(" "),n("p",[e._v("-eSpeak TTS module for Windows")]),e._v(" "),n("p",[e._v("https://github.com/espeak-ng/espeak-ng/releases/tag/1.51")]),e._v(" "),n("p",[e._v("-Some sort of text editor of your choice")]),e._v(" "),n("p",[e._v("https://notepad-plus-plus.org/")]),e._v(" "),n("p",[e._v("-FFMPEG library for Windows")]),e._v(" "),n("p",[e._v("https://github.com/BtbN/FFmpeg-Builds/releases")]),e._v(" "),n("p",[e._v("-lmageMagic editor software")]),e._v(" "),n("p",[e._v("https://imagemagick.org/")]),e._v(" "),n("p",[e._v("步骤3：")]),e._v(" "),n("p",[e._v("我们需要一些内容来使用，第一个示例将包括Reddit。没有多少人知道 Reddit 有这个功能。如果您转到任何 Reddit子版块并在 URL 栏中输入/random，您就会从该 Reddit 子版块中获得一个随机帖子。这意味着获取内容的系统已经就位，我们只需要“刮掉它”。我个人喜欢恐怖故事，所以让我们尝试使用 /r/shortscarystories 中的故事创建一些恐怖短片。")]),e._v(" "),n("p",[e._v("所以我们找到了我们想要的内容，但我们不想每次都自己复制粘贴。让我们编写一个简短的脚本来为我们完成这件事。在撰写本指南时，Reddit 的旧移动网站仍然处于活动状态，这非常方便抓取，因为它简单且加载速度快。我们可以通过输入 i 来访问它。在reddit.com前面。")]),e._v(" "),n("p",[e._v("该脚本的主要目标：")]),e._v(" "),n("p",[e._v("1.导航至https://i.reddit.com/r/shortscarvstories/random")]),e._v(" "),n("p",[e._v("2.找到正文的元素")]),e._v(" "),n("p",[e._v("3.从元素中提取故事文本")]),e._v(" "),n("ol",{attrs:{start:"4"}},[n("li",[e._v("将故事保存到文件")])]),e._v(" "),n("p",[e._v("正如您所看到的，帖子的主体文本位于一些带有名为 usertext-body 的类的 div 标签之间，我们所要做的就是告诉我们的机器人导航到网页，找到具有相同类的元素，并获取文本。对于此任务，我们将使用 Requests库 来访问站点，并使用 BS4 来解释站点的HTML。就像任何流行网站一样，Reddit不喜欢机器人抓取他们的页面，但幸运的是，只要你不这样做，他们对此并没有那么严格。")]),e._v(" "),n("p",[e._v("为避免造成太多麻烦，让我们使用随机用户代理以防万一。如果您想抓取更多数据，可以使用他们的 API 来实现，但在本教程中，我们将保持简单。")]),e._v(" "),n("p",[e._v("它应该以 .py 文件扩展名保存，并且可以通过打开终端并输入py yourscript.py 进行测试脚本应该在同一目录中创建一个新的 .txt 文件。")]),e._v(" "),n("p",[e._v("步骤4：")]),e._v(" "),n("p",[e._v("通过上面的操作，我们有了内容，让我们制作视频吧！")]),e._v(" "),n("p",[e._v("您可以手动完成，但这并不有趣，所以让我们编写另一个python 脚本，将其转换为视频。")]),e._v(" "),n("p",[e._v("该视频将包括：")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("库存背景素材")])]),e._v(" "),n("li",[n("p",[e._v("叠加故事字幕")])]),e._v(" "),n("li",[n("p",[e._v("文字转语音")])]),e._v(" "),n("li",[n("p",[e._v("旁白背景音乐")])])]),e._v(" "),n("p",[e._v("该脚本的目标是将库存背景素材裁剪为 9:16 的宽高比，使用 TTS 将 Reddit 故事转换为音频，将其切成适合屏幕的单独文本行，使用 TTS 将这些行转换为音频并叠加，让它带有一些背景氛围。")]),e._v(" "),n("p",[e._v("在此代码的开头，我们定义必要的库并下载 NLTK 模块，该模块有助于将我们的脚本分成更小的句子，以使字幕适合屏幕。然后我们选择所需的 TTS 语音。第一次尝试此代码时，TTS 库将下载所选的语音。除了英语之外，还有相当多的语言，只需更改型号名称即可选择您想要的声音。")]),e._v(" "),n("p",[e._v("注意：")]),e._v(" "),n("p",[e._v("我标记了更改字幕速度的数字（更少 = 更快），但是要更改每 1 个字幕行的最大字数，您需要将所有 4 更改为所需的数字。当前设置为每个字幕行最多 4 个单词，因为使用当前字体很难在垂直视频中容纳更多单词。")]),e._v(" "),n("p",[e._v("以上自动化的方法也适用与其他平台，例如tiktok。")]),e._v(" "),n("p",[e._v("Image完整且可复制的脚本如下：")]),e._v(" "),n("p",[e._v("从 Reddit 上抓取内容")]),e._v(" "),n("p",[e._v("->https://pastebin.com/ZYU3KRZn")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("#Import the required libraries\nimport requests\nfrom bs4 import BeautifulSoup\n#Link to the subreddit of your choice\nurl = 'https://i.reddit.com/r/shortscarystories/random'\n#Set a random useragent to avoid suspicion\nheaders = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'}\n#Go the the url and get the sites data, allow redirects to get random story\nresponse = requests.get(url, headers=headers, allow_redirects=True)\n#Use BS4 (BeautifulSoup4 HTML library) to read the data\nsoup = BeautifulSoup(response.text, 'html.parser')\n# Get the main body text of the post\nmain_text = soup.find('div', {'class': 'usertext-body'}).text.strip()\n# Write the title and main text to a file\nwith open('video_script.txt', 'w') as f:\n    f.write(main_text + '\\n')\n")])])]),n("p",[e._v("从故事生成视频")]),e._v(" "),n("p",[e._v("->https://pastebin.com/gXHZ98Hz")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("# Import the necessary libraries and modules\nimport nltk  # for natural language processing tasks\nimport datetime  # for date and time manipulation\nfrom TTS.api import TTS  # text to speech package\nfrom moviepy.editor import *  # video editing package\nfrom nltk.tokenize import sent_tokenize  # sentence tokenization from natural language\nfrom moviepy.video.tools.subtitles import SubtitlesClip # tools for reading and displaying subtitles\n# Download the 'punkt' module used for sentence tokenization if it has not already been downloaded\nnltk.download('punkt')\n \n# Select the model for text-to-speech conversion\nmodel_name = TTS.list_models()[12]\n# Create an instance of the selected text-to-speech model\ntts = TTS(model_name)\n# Open the text file containing the video script, and read the contents\nvideo_script = open('video_script.txt', 'r').read()\n# Convert the video script to an audio file using the selected text-to-speech model\ntts.tts_to_file(text=video_script, file_path=\"voiceover.wav\")\n# Load the newly created audio file, and adjust the volume of the background music\nnew_audioclip = CompositeAudioClip([\n    AudioFileClip(\"voiceover.wav\"),\n    AudioFileClip('background_music.mp3').volumex(0.2)\n])\n# Load the video file that will be used as the background of the final clip\nvideo = VideoFileClip('background_video.mp4')\n# Determine the dimensions of the video, and calculate the desired width based on the aspect ratio of 16:9\nwidth, height = video.size\nnew_width = int(height * 9/16)\n# Crop the video to the desired width, centered horizontally\nclip = video.crop(x1=(width - new_width) / 2, x2=(width - new_width) / 2 + new_width)\n# Set the audio of the cropped video to the adjusted background music and voiceover audio\nclip.audio = new_audioclip\n \n# Define a function to create subtitles for the video\ndef subtitles(sentences):\n    # Initialize an empty list to store the SRT file contents\n    srt_lines = []\n    # Initialize the start and end time to zero\n    start = datetime.timedelta(seconds=0)\n    end = datetime.timedelta(seconds=0)\n    # Initialize a counter to keep track of subtitle numbers\n    counter = 1\n    # Loop over each sentence in the list of sentences passed to the function\n    for sentence in sentences:\n        # Split the sentence into words\n        words = sentence.split()\n        # Calculate the number of lines needed for this sentence (assuming each line has 4 words)\n        num_lines = len(words) // 4 + 1\n        # Loop over each line of the sentence\n        for j in range(num_lines):\n            # Get the words for this line\n            line_words = words[j * 4: (j + 1) * 4]\n            # Join the words into a single string to form the line\n            line = ' '.join(line_words)\n            # Calculate the end time for this line based on the length of the line\n            end += datetime.timedelta(seconds=len(line_words) * 0.35)\n            # Check if the line is not empty\n            if line:\n                # Format the start and end times as strings in the SRT format\n                start_str = '{:02d}:{:02d}:{:02d},{:03d}'.format(\n                    start.seconds // 3600,\n                    (start.seconds // 60) % 60,\n                    start.seconds % 60,\n                    start.microseconds // 1000\n                )\n                end_str = '{:02d}:{:02d}:{:02d},{:03d}'.format(\n                    end.seconds // 3600,\n                    (end.seconds // 60) % 60,\n                    end.seconds % 60,\n                    end.microseconds // 1000\n                )\n                # Add the subtitle number, start and end times, and line to the SRT list\n                srt_lines.append(str(counter))\n                srt_lines.append(start_str + ' --\x3e ' + end_str)\n                srt_lines.append(line)\n                srt_lines.append('')\n                # Increment the subtitle counter\n                counter += 1\n            # Update the start time for the next line\n            start = end\n    # Join the lines of the SRT file into a single string\n    srt_file = '\\n'.join(srt_lines)\n    # Write the SRT file to disk\n    with open(\"subtitles.srt\", \"w\") as f:\n        f.write(srt_file)\n \n# Call the 'subtitles' function with a list of sentences, which are obtained by tokenizing the video script\nsubtitles(list(filter(None, (sent_tokenize(video_script)))))\n# Define a lambda function to generate the subtitle clips from the SRT file\ngenerator = lambda txt: TextClip(txt, font='Arial-Bold', fontsize=20, color='white', bg_color='rgba(0,0,0,0.4)')\n# Create the subtitle clip from the SRT file\nsubtitle_source = SubtitlesClip(\"subtitles.srt\", generator)\n# Combine the video clip and the subtitle clip, and adjust the speed and length of the result\nclip = CompositeVideoClip([clip, subtitle_source.set_pos(('center', 400))]).speedx(factor=1.1).subclip(0, 60)\n# Write the final video clip to disk\nclip.write_videofile(\"clip.mp4\")\n")])])]),n("p",[e._v("从电视剧集剪辑")]),e._v(" "),n("p",[e._v("->https://pastebin.com/U5RpYK70")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import os  # importing os module for interacting with operating system\nimport random  # importing random module for generating random values\nfrom moviepy.editor import *  # importing necessary classes from moviepy module\nfrom moviepy.video.VideoClip import TextClip\n \n# creating a list of .mp4 files in the 'Episodes' directory using list comprehension\nmp4_files = [file for file in os.listdir('Episodes') if file.endswith('.mp4')]\n# randomly choosing a file from the list\nrandom_file = random.choice(mp4_files)\n# creating the full path of the chosen video file\nvideo_file = os.path.join('Episodes', random_file)\n# loading the video file using VideoFileClip() class\nvideo = VideoFileClip(video_file)\n# getting the duration of the video\nduration = video.duration\n# choosing a random start time between 30 seconds and 60 seconds before the end of the video\nstart = random.uniform(30, max(30, duration - 60))\n# choosing a random length between 20 seconds and 40 seconds\nlenght = random.randint(20, 40)\n# extracting the clip from the video using the chosen start time and length\nclip = video.subclip(start, start + lenght)\n# getting the width and height of the clip\nwidth, height = clip.size\n# calculating the aspect ratio of the clip\naspect_ratio = width / height\n# calculating the new width of the clip with a 16:9 aspect ratio\nnew_width = int(height * 9/16)\n# calculating the left margin to center the clip horizontally\nleft_margin = (width - new_width) / 2\n# cropping the clip to the new width and centering it horizontally\nclip = clip.crop(x1=left_margin, x2=left_margin + new_width)\n# increasing the speed of the clip by 10%\nclip = clip.speedx(factor=1.1)\n# flipping the clip horizontally\nclip = clip.fx(vfx.mirror_x)\n# creating a TextClip object with the desired text and properties\ntext = \"Surprise in comments\\nEnter & WIN!\"\ntxt_clip = TextClip(text, fontsize=15, color='white', font='Arial-Bold')\n# setting the position of the text clip to be centered near the bottom of the screen\ntxt_clip = txt_clip.set_position(('center', 0.8), relative=True)\n# creating a CompositeVideoClip object by combining the clip and text clip\nfinal_clip = CompositeVideoClip([clip, txt_clip])\n# setting the duration of the final clip to be the same as the cropped clip\nfinal_clip.duration = clip.duration\n# writing the final clip to a file named 'clip.mp4'\nfinal_clip.write_videofile(\"clip.mp4\")\n")])])]),n("p",[e._v("Reddit 到视频")]),e._v(" "),n("p",[e._v("->https://pastebin.com/TdyF60wF")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("# Import the necessary libraries and modules\nimport nltk  # for natural language processing tasks\nimport datetime  # for date and time manipulation\nimport requests # for scraping reddit\nfrom bs4 import BeautifulSoup # for reading html\nfrom TTS.api import TTS  # text to speech package\nfrom moviepy.editor import *  # video editing package\nfrom nltk.tokenize import sent_tokenize  # sentence tokenization from natural language\nfrom moviepy.video.tools.subtitles import SubtitlesClip # tools for reading and displaying subtitles\n# Download the 'punkt' module used for sentence tokenization if it has not already been downloaded\nnltk.download('punkt')\n \n#Link to the subreddit of your choice\nurl = 'https://i.reddit.com/r/shortscarystories/random'\n#Set a random useragent to avoid suspicion\nheaders = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'}\n#Go the the url and get the sites data, allow redirects to get random story\nresponse = requests.get(url, headers=headers, allow_redirects=True)\n#Use BS4 (BeautifulSoup4 HTML library) to read the data\nsoup = BeautifulSoup(response.text, 'html.parser')\n# Get the main body text of the post\nmain_text = soup.find('div', {'class': 'usertext-body'}).text.strip()\n# Write the title and main text to a file\nwith open('video_script.txt', 'w') as f:\n    f.write(main_text + '\\n')\n \n# Select the model for text-to-speech conversion\nmodel_name = TTS.list_models()[12]\n# Create an instance of the selected text-to-speech model\ntts = TTS(model_name)\n# Open the text file containing the video script, and read the contents\nvideo_script = open('video_script.txt', 'r').read()\n# Convert the video script to an audio file using the selected text-to-speech model\ntts.tts_to_file(text=video_script, file_path=\"voiceover.wav\")\n# Load the newly created audio file, and adjust the volume of the background music\nnew_audioclip = CompositeAudioClip([\n    AudioFileClip(\"voiceover.wav\"),\n    AudioFileClip('background_music.mp3').volumex(0.2)\n])\n# Load the video file that will be used as the background of the final clip\nvideo = VideoFileClip('background_video.mp4')\n# Determine the dimensions of the video, and calculate the desired width based on the aspect ratio of 16:9\nwidth, height = video.size\nnew_width = int(height * 9/16)\n# Crop the video to the desired width, centered horizontally\nclip = video.crop(x1=(width - new_width) / 2, x2=(width - new_width) / 2 + new_width)\n# Set the audio of the cropped video to the adjusted background music and voiceover audio\nclip.audio = new_audioclip\n \n# Define a function to create subtitles for the video\ndef subtitles(sentences):\n    # Initialize an empty list to store the SRT file contents\n    srt_lines = []\n    # Initialize the start and end time to zero\n    start = datetime.timedelta(seconds=0)\n    end = datetime.timedelta(seconds=0)\n    # Initialize a counter to keep track of subtitle numbers\n    counter = 1\n    # Loop over each sentence in the list of sentences passed to the function\n    for sentence in sentences:\n        # Split the sentence into words\n        words = sentence.split()\n        # Calculate the number of lines needed for this sentence (assuming each line has 4 words)\n        num_lines = len(words) // 4 + 1\n        # Loop over each line of the sentence\n        for j in range(num_lines):\n            # Get the words for this line\n            line_words = words[j * 4: (j + 1) * 4]\n            # Join the words into a single string to form the line\n            line = ' '.join(line_words)\n            # Calculate the end time for this line based on the length of the line\n            end += datetime.timedelta(seconds=len(line_words) * 0.35)\n            # Check if the line is not empty\n            if line:\n                # Format the start and end times as strings in the SRT format\n                start_str = '{:02d}:{:02d}:{:02d},{:03d}'.format(\n                    start.seconds // 3600,\n                    (start.seconds // 60) % 60,\n                    start.seconds % 60,\n                    start.microseconds // 1000\n                )\n                end_str = '{:02d}:{:02d}:{:02d},{:03d}'.format(\n                    end.seconds // 3600,\n                    (end.seconds // 60) % 60,\n                    end.seconds % 60,\n                    end.microseconds // 1000\n                )\n                # Add the subtitle number, start and end times, and line to the SRT list\n                srt_lines.append(str(counter))\n                srt_lines.append(start_str + ' --\x3e ' + end_str)\n                srt_lines.append(line)\n                srt_lines.append('')\n                # Increment the subtitle counter\n                counter += 1\n            # Update the start time for the next line\n            start = end\n    # Join the lines of the SRT file into a single string\n    srt_file = '\\n'.join(srt_lines)\n    # Write the SRT file to disk\n    with open(\"subtitles.srt\", \"w\") as f:\n        f.write(srt_file)\n \n# Call the 'subtitles' function with a list of sentences, which are obtained by tokenizing the video script\nsubtitles(list(filter(None, (sent_tokenize(video_script)))))\n# Define a lambda function to generate the subtitle clips from the SRT file\ngenerator = lambda txt: TextClip(txt, font='Arial-Bold', fontsize=20, color='white', bg_color='rgba(0,0,0,0.4)')\n# Create the subtitle clip from the SRT file\nsubtitle_source = SubtitlesClip(\"subtitles.srt\", generator)\n# Combine the video clip and the subtitle clip, and adjust the speed and length of the result\nclip = CompositeVideoClip([clip, subtitle_source.set_pos(('center', 400))]).speedx(factor=1.1).subclip(0, 60)\n# Write the final video clip to disk\nclip.write_videofile(\"clip.mp4\")\n \npos1 = ['Entry1', 'Entry2']\npos2 = ['Entry1', 'Entry2']\nwith open(\"count.txt\", 'r') as file:\n    counter = file.read()\ntitle = f\"Horror Story {random.choice(pos1)} #{counter} ({os.path.splitext(random_file)[0]})\\n\"\ndescription = f\"\"\"{random.choice(pos2)} subscribe for more {os.path.splitext(random_file)[0]} | Special offer: yourcpalink\n#tag1, #tag1, #tag3\n\"\"\"\ntag_list = [\"tag1\", \"tag2\", \"tag3\"]\ntags = random.choice(tag_list)+','+random.choice(tag_list)+','+random.choice(tag_list)\nwith open(\"video_text.txt\", 'w') as file:\n    file.write(title+description+tags)\nexecute_js('upload.js')\n")])])]),n("p",[e._v("卡通剪辑")]),e._v(" "),n("p",[e._v("->https://pastebin.com/1PEYc2tW")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import os # Import the os module to handle file operations\nimport random # Import the random module to generate random numbers\nfrom moviepy.editor import * # Import the necessary classes from the moviepy module\nfrom moviepy.video.VideoClip import TextClip\nfrom Naked.toolshed.shell import execute_js, muterun_js # Import execute_js and muterun_js from Naked.toolshed.shell\n \nmp4_files = [file for file in os.listdir('Episodes') if file.endswith('.mp4')]  # Get all the .mp4 files in the Episodes directory\nrandom_file = random.choice(mp4_files)  # Choose a random file from the list\nvideo_file = os.path.join('Episodes', random_file)  # Construct the file path of the chosen video\nvideo = VideoFileClip(video_file)  # Create a VideoFileClip object from the chosen video file\nduration = video.duration  # Get the duration of the video in seconds\nstart = random.uniform(30, max(30, duration - 60))  # Choose a random starting time for the clip\nlength = random.randint(20, 40)  # Choose a random length for the clip\nclip = video.subclip(start, start + length)  # Create a subclip from the chosen start time and length\nwidth, height = clip.size  # Get the width and height of the clip\naspect_ratio = width / height  # Calculate the aspect ratio of the clip\nnew_width = int(height * 9/16)  # Calculate the new width of the clip based on a 16:9 aspect ratio\nleft_margin = (width - new_width) / 2  # Calculate the left margin needed to center the clip horizontally\nclip = clip.crop(x1=left_margin, x2=left_margin + new_width)  # Crop the clip to the new dimensions\nclip = clip.speedx(factor=1.1)  # Speed up the clip by 10%\nclip = clip.fx(vfx.mirror_x)  # Apply a mirror effect to the clip\ntext = \"Surprise in comments!\\nSubscribe for more\"  # Create the text to display in the video\ntxt_clip = TextClip(text, fontsize=15, color='white', font='Arial-Bold')  # Create a TextClip object with the specified text\ntxt_clip = txt_clip.set_position(('center', 0.8), relative=True)  # Set the position of the text relative to the center of the clip\nfinal_clip = CompositeVideoClip([clip, txt_clip])  # Create a composite clip with the video clip and the text clip\nfinal_clip.duration = clip.duration  # Set the duration of the final clip to match the duration of the video clip\nfinal_clip.write_videofile(\"clip.mp4\")  # Save the final clip as a new video file\n \npos1 = ['Entry1', 'Entry2']  # List of possible values for position 1 in the video title\npos2 = ['Entry1', 'Entry2']  # List of possible values for position 2 in the video description\nwith open(\"count.txt\", 'r') as file:  # Open the count.txt file for reading\n    counter = file.read()  # Read the current value of the counter from the file\ntitle = f\"Funny Cartoon {random.choice(pos1)} #{counter} ({os.path.splitext(random_file)[0]})\\n\"  # Construct the video title\ndescription = f\"\"\"{random.choice(pos2)} subscribe for more {os.path.splitext(random_file)[0]} | Special offer: yourcpalink\n#tag1, #tag1, #tag3\n\"\"\"\ntag_list = [\"tag1\", \"tag2\", \"tag3\"]\ntags = random.choice(tag_list)+','+random.choice(tag_list)+','+random.choice(tag_list)\nwith open(\"video_text.txt\", 'w') as file:\n    file.write(title+description+tags)\n \n# Execute a JavaScript file called \"upload.js\" to upload the video to YouTube\nexecute_js('upload.js')\n \n# Increment a counter in a file called \"count.txt\" to keep track of the number of videos uploaded\nwith open(\"count.txt\", 'r') as file:\n    counter = int(file.read())\n    counter += 1\nwith open(\"count.txt\", 'w') as file:\n    file.write(str(counter))\n")])])]),n("p",[e._v("视频上传")]),e._v(" "),n("p",[e._v("->https://pastebin.com/USsm1pKC")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// Import required packages\nconst fs = require('fs'); // For reading files\nconst puppeteer = require('puppeteer-core'); // For browser automation\nconst url = 'https://studio.youtube.com/'; // URL to navigate to\nconst delayRandom = require('delay-random'); // For adding random delays\n \n// Read the upload text that was created previously\nfs.readFile('upload_text.txt', 'utf8', function(err, data) {\n    if (err) throw err; // Show if something is wrong with the file\n    lines = data.split('\\n'); // Split the file into individual lines\n});\n \n// Launch Puppeteer browser instance with a local cache storage\npuppeteer.launch({\n  userDataDir: './uploader_cache', // The location where the cache will be stored\n  executablePath: require('puppeteer').executablePath(), // Path to the executable of a specific version of Chrome (installed by Puppeteer)\n  headless: false, // Run the browser in GUI mode\n  args: ['--no-sandbox'] // Arguments to pass to the browser\n})\n.then(async browser => {\n    const page = await browser.newPage(); // Open a new page\n    await page.setCacheEnabled(true); // Enable the cache to save the sessions\n    await page.setViewport({ width: 1280, height: 720 }); // Set the size for the browser window\n    // Read the cookies from a JSON file\n    const cookies = JSON.parse(fs.readFileSync('cookies.json', 'utf8'));\n    // Add the cookies to the page\n    for (const cookie of cookies) {\n    await page.setCookie(cookie);\n    }\n    await page.goto(url); // Go to the YouTube Studio website\n    await delayRandom(14000, 26000); // Wait for the website to load (adjust based on your internet speed)\n    // From this point on, the script interacts with the website by clicking buttons and entering text\n    await page.click('#create-icon'); // Click on the 'Create' button\n    await delayRandom(1000, 2000); // Wait for the next step to load\n    await page.click('#text-item-0'); // Click on the 'Text' option\n    await delayRandom(1000, 2000); // Wait for the next step to load\n    await page.click('#select-files-button'); // Click on the 'Select files' button\n    await delayRandom(1000, 2000); // Wait for the next step to load\n    const elementHandle = await page.$(\"input[type=file]\"); // Get the file input element\n    await elementHandle.uploadFile('clip.mp4'); // Upload the video file (make sure everything is in the same folder)\n    await delayRandom(8000, 10000); // Wait for the file to upload (adjust based on your file size)\n    await page.keyboard.type(lines[0], {delay: 150}); // Enter the title of the video\n    await delayRandom(1000, 2000); // Wait for the next step to load\n    await page.keyboard.press('Tab'); // Move to the next input field\n    await delayRandom(500, 600); // Wait for the next step to load\n    await page.keyboard.press('Tab'); // Move to the next input field\n    await delayRandom(1000, 2000); // Wait for the next step to load\n    await page.focus('#description-container'); //focus on the description container\n    await delayRandom(1000, 2000); //wait for a random amount of time\n    await page.keyboard.type(lines[1], {delay: 150}); //type the first line of the description with a delay between keystrokes\n    await delayRandom(1000, 2000); //wait for a random amount of time\n    await page.keyboard.type(lines[2], {delay: 150}); //type the second line of the description with a delay between keystrokes\n    await delayRandom(1000, 2000); //wait for a random amount of time\n    await page.click('#audience > ytkc-made-for-kids-select > div.made-for-kids-rating-container.style-scope.ytkc-made-for-kids-select > tp-yt-paper-radio-group > tp-yt-paper-radio-button:nth-child(2)'); //click the \"No, it's not made for kids\" radio button\n    await delayRandom(1000, 2000); //wait for a random amount of time\n    await page.keyboard.press('Tab'); //press the Tab key\n    await delayRandom(1000, 2000); //wait for a random amount of time\n    await page.keyboard.press('Tab'); //press the Tab key again\n    await delayRandom(1000, 2000); //wait for a random amount of time\n    await page.keyboard.press('Enter'); //press the Enter key\n    await delayRandom(1000, 2000); //wait for a random amount of time\n    for (let i = 0; i < 8; i++) { //loop 8 times\n        await page.keyboard.press('Tab'); //press the Tab key\n        await delayRandom(300, 600); //wait for a random amount of time\n    }\n    await delayRandom(1000, 2000); //wait for a random amount of time\n    await page.keyboard.type(lines[3], {delay: 150}); //type the third line of the description with a delay between keystrokes\n    await delayRandom(1000, 2000); //wait for a random amount of time\n    await page.click('#next-button'); //click the \"Next\" button\n    await delayRandom(1000, 2000); //wait for a random amount of time\n    await page.click('#next-button'); //click the \"Next\" button again\n    await delayRandom(1000, 2000); //wait for a random amount of time\n    await page.click('#next-button'); //click the \"Next\" button a third time\n    await delayRandom(1000, 2000); //wait for a random amount of time\n    await page.click('#offRadio'); //click the \"Not made for kids\" radio button\n    await delayRandom(1000, 2000); //wait for a random amount of time\n    await page.keyboard.press('Tab'); //press the Tab key\n    await delayRandom(1000, 2000); //wait for a random amount of time\n    await page.keyboard.press('ArrowUp'); //press the Up Arrow key\n    await delayRandom(15000, 20000); //wait for a random amount of time\n    await page.click('#done-button');\n    await delayRandom(15000, 20000);\n    // At this point, the video should be uploaded. The following code navigates to the newly uploaded video's page and leaves a comment.\n    // Get the URL of the newly uploaded video\n    const element = await page.$('#share-url');\n    const share = await page.evaluate(el => el.innerHTML, element);\n    await page.goto(share);\n    await delayRandom(10000, 15000);\n    // Click the \"Comments\" button to expand the comments section\n    await page.click('#comments-button');\n    await delayRandom(5000, 10000);\n    // Press the \"Tab\" key several times to navigate to the comment text box\n    await page.keyboard.press('Tab');\n    await delayRandom(1000, 2000);\n    await page.keyboard.press('Tab');\n    await delayRandom(1000, 2000);\n    await page.keyboard.press('Tab');\n    await delayRandom(1000, 2000);\n    // Type the comment text into the text box\n    await page.keyboard.type('Special prize for you: cpalinkhere', {delay: 150});\n    await delayRandom(1000, 2000);\n    // Click the \"Submit\" button to post the comment\n    await page.click('#submit-button');\n    await delayRandom(15000, 20000);\n    // Print a message to indicate that the upload and comment posting are complete, and exit the script\n    console.log('Upload completed')\n    process.exit();\n})\n.catch(function(error) {\n    console.error(error);\n    //process.exit();\n});\n")])])]),n("p",[e._v("对于脚本感兴趣的同学可以再深入研究，但是基于YouTube和Tiktok算法随时可能会发生变化，因此需要随时调整策略。")])])}),[],!1,null,null,null);t.default=o.exports}}]);