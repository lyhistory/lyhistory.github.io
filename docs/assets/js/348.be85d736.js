(window.webpackJsonp=window.webpackJsonp||[]).push([[348],{783:function(e,a,t){"use strict";t.r(a);var s=t(65),n=Object(s.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"基本概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[e._v("#")]),e._v(" 基本概念")]),e._v(" "),t("h3",{attrs:{id:"步骤一-编译器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#步骤一-编译器"}},[e._v("#")]),e._v(" 步骤一：编译器：")]),e._v(" "),t("p",[e._v("首先需要编译器将高级的.java程序文件编译成.class类文件，内容即byte code字节码指令/jvm指令（这段.class文件是一段包含着虚拟机指令、程序和数据片段的二进制文件，即字节码，为什么叫字节码？因为这种类型的代码以一个字节8bit为最小单位储存），\n然后聚合类文件、相关元数据和资源到同一个文件，以.jar为扩展名")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("java代码编译--\x3ejava class\n")])])]),t("p",[e._v("字节码引擎对应jvm指令:"),t("a",{attrs:{href:"https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java bytecode instruction listings"),t("OutboundLink")],1)]),e._v(" "),t("h3",{attrs:{id:"步骤二-解释器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#步骤二-解释器"}},[e._v("#")]),e._v(" 步骤二：解释器：")]),e._v(" "),t("p",[e._v("字节码经过JVM(解释器)的处理后生成电脑可以直接执行的机器码（JDK安装的JVM翻译成对应操作系统的机器码），至此java程序才能得以正确运行。\nJVM,java虚拟机，只是给字节码byte code提供解释翻译加载运行的一个工具（通常编程打包的程序都是直接到机器码，比如exe文件是windows的机器码可执行文件，Java语言设计只默认编译成中间语言byte code字节码，不编译成最终的机器码，然后jvm就会去解释执行），实际上不只是java语言，任何语言只要能转成bytecode 字节码都可以交由jvm加载，jvm会找到主程序并根据当前的操作系统解释成机器码运行；")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Tips:\n工具hsdis打印汇编指令；\n反过来：\njavap java.class 可以把汇编指令/机器码反编译成jvm指令/字节码指令；\n")])])]),t("h3",{attrs:{id:"jvm-的线程是用户态线程还是内核态线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm-的线程是用户态线程还是内核态线程"}},[e._v("#")]),e._v(" JVM 的线程是用户态线程还是内核态线程？")]),e._v(" "),t("p",[e._v("【解析】 JVM 自己本身有一个线程模型。在 JDK 1.1 的时候，JVM 自己管理用户级线程。这样做缺点非常明显，操作系统只调度内核级线程，用户级线程相当于基于操作系统分配到进程主线程的时间片，再次拆分，因此无法利用多核特性。")]),e._v(" "),t("p",[e._v("为了解决这个问题，后来 Java 改用线程映射模型，因此，需要操作系统支持。在 Windows 上是 1 对 1 的模型，在 Linux 上是 n 对 m 的模型。顺便说一句，Linux 的PThreadAPI 创建的是用户级线程，如果 Linux 要创建内核级线程有KThreadAPI。映射关系是操作系统自动完成的，用户不需要管。")]),e._v(" "),t("p",[e._v("在JVM中运行的线程与Linux内核之间的关系是一个复杂但重要的概念。首先，需要澄清的是，JVM管理的线程（即Java线程）与操作系统（如Linux）的线程之间并不是完全隔离的，它们之间存在紧密的交互。")]),e._v(" "),t("p",[e._v("JVM线程与操作系统线程的关系\n一对一模型：")]),e._v(" "),t("p",[e._v("在许多现代JVM实现中，特别是HotSpot JVM，Java线程与操作系统的本地线程（在Linux中通常是轻量级进程）之间存在一对一的映射关系。这意味着每当在Java中创建一个新线程时，JVM都会请求操作系统创建一个新的本地线程12。\n在这种模型下，Java线程的调度、创建、销毁以及上下文切换等操作都是由操作系统内核来管理的。JVM本身并不直接进行这些操作，而是依赖于操作系统提供的API和机制12。\n线程创建与销毁：")]),e._v(" "),t("p",[e._v("当Java程序创建一个新线程时，JVM会调用操作系统的API（如Linux中的pthread_create）来创建一个新的本地线程。这个过程中，操作系统会为线程分配必要的资源，如内存和堆栈空间12。\n类似地，当Java线程结束时，JVM会请求操作系统销毁相应的本地线程，并回收其占用的资源3。\n线程调度：")]),e._v(" "),t("p",[e._v("线程的调度（即决定哪个线程在何时运行）完全由操作系统内核负责。Java线程的优先级设置可能会反映为底层操作系统线程的优先级设置，但这不是一个严格的一一对应关系4。\n在Java中，线程的调度通常是基于抢占式的，这意味着优先级更高的线程更可能被操作系统选中执行，但它并不能保证一定会被执行3。\n上下文切换：")]),e._v(" "),t("p",[e._v("当操作系统需要从一个线程切换到另一个线程时（例如，由于时间片用完、等待I/O操作等），它会保存当前线程的状态（如寄存器值和程序计数器值），并加载另一个线程的状态3。\n这个过程称为上下文切换，它涉及到用户态和内核态之间的切换，因此可能会消耗一定的处理器时间3。\n同步与互斥：")]),e._v(" "),t("p",[e._v("Java提供了自己的同步机制（如synchronized关键字和java.util.concurrent包中的高级同步结构），但这些机制在底层通常是由操作系统的线程同步机制实现的4。\n例如，Java中的锁（如ReentrantLock）在底层可能使用操作系统的互斥量（Mutex）来实现。\n总结\n因此，可以说JVM中的线程并不是完全由JVM管理的，而是与操作系统线程紧密相关。JVM依赖于操作系统提供的线程管理机制来实现Java线程的创建、销毁、调度和同步等操作。这种关系使得Java程序能够充分利用操作系统的多线程特性，同时也带来了与操作系统交互的开销。")]),e._v(" "),t("p",[e._v("需要注意的是，虽然JVM和操作系统之间的交互是不可避免的，但JVM通过其高级抽象和优化机制（如JIT编译、垃圾回收等）为Java程序提供了跨平台的一致性和高性能。因此，在编写Java程序时，开发者通常不需要关心底层操作系统线程的具体实现细节。")]),e._v(" "),t("p",[e._v("线程阻塞\n当Java线程执行到某个阻塞点时（如执行了阻塞的I/O操作、调用了线程的sleep方法、等待某个条件变量的满足等），JVM会向操作系统发出请求，将当前线程的状态从运行状态（RUNNABLE）切换到阻塞状态（BLOCKED或WAITING等）。这个过程中，JVM会调用操作系统的API来实现线程的阻塞。")]),e._v(" "),t("p",[e._v("操作系统层面：在操作系统层面，线程的状态变化是通过修改线程的状态标志（如Linux中的task_struct结构体中的状态字段）来实现的。当线程进入阻塞状态时，操作系统会将其从运行队列中移除，并可能将其添加到等待队列中（对于需要等待某个事件或资源的线程）。此时，线程将不再参与CPU的调度，直到被唤醒1。")]),e._v(" "),t("p",[e._v("内核态与用户态切换：线程的阻塞和唤醒过程通常涉及用户态和内核态之间的切换。用户态是用户程序运行的环境，而内核态是操作系统内核运行的环境。当线程需要执行阻塞操作时，JVM会发起系统调用（如Linux中的read系统调用），这会导致CPU从用户态切换到内核态，执行相应的内核代码来处理阻塞请求。内核代码会使用当前进程的内核栈来保存上下文信息，并在处理完成后将CPU切换回用户态2。")]),e._v(" "),t("p",[e._v("线程唤醒\n当线程被唤醒时（如等待的I/O操作完成、调用了线程的interrupt方法、其他线程调用了notify/notifyAll方法等），操作系统会接收到相应的通知，并将线程从等待队列中移除，重新添加到运行队列中。此时，线程将有机会再次参与CPU的调度，并执行其后续任务。")]),e._v(" "),t("p",[e._v("唤醒机制：唤醒机制通常依赖于操作系统的中断机制和事件通知机制。例如，在Linux中，当硬件中断发生时（如I/O操作完成），中断处理程序会执行相应的中断服务例程，并通过回调函数或信号量等方式通知等待的线程。线程被唤醒后，其task_struct结构体中的状态字段会被修改为TASK_RUNNING，并重新参与CPU的调度1。")]),e._v(" "),t("p",[e._v("性能影响：线程的阻塞和唤醒操作会消耗一定的系统资源，包括CPU时间和内存空间。特别是当线程频繁地进行阻塞和唤醒操作时，这种开销会更加明显。因此，在编写多线程程序时，需要合理设计线程之间的同步和通信机制，以减少不必要的阻塞和唤醒操作，提高程序的性能和响应速度")]),e._v(" "),t("h2",{attrs:{id:"jvm运行原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm运行原理"}},[e._v("#")]),e._v(" jvm运行原理")]),e._v(" "),t("p",[e._v("类型：hotspot vm /  OpenJ9")]),e._v(" "),t("p",[e._v("JVM是一份本地化的程序，本质上是可执行的文件-"),t("code",[e._v("/jre/bin/server/jvm.dll")]),e._v("，是静态的概念。")]),e._v(" "),t("p",[e._v("程序运行起来成为进程，是动态的概念。java程序是跑在JVM上的，严格来讲，是跑在JVM实例上的，一个JVM实例其实就是JVM跑起来的进程，二者合起来称之为一个JAVA进程。各个JVM实例之间是相互隔离的。")]),e._v(" "),t("p",[t("img",{attrs:{src:"/docs/docs_image/software/java/java_jvm01.png",alt:""}})]),e._v(" "),t("p",[e._v("线程栈：栈帧的先进先出（异步方法呢？）")]),e._v(" "),t("p",[e._v("栈帧：对应每个线程中调用的方法，相应概念：\n局部变量表\n操作数栈\n动态链接\n方法出口")]),e._v(" "),t("p",[e._v("本地方法：\tNative method Stack，比如JNI调用c/C++程序")]),e._v(" "),t("p",[e._v("方法区 Method Area： 静态变量")]),e._v(" "),t("p",[e._v("Linux的内存空间地址从低到高一般分为五个部分：内核空间、栈区域、堆区域、BBS段、数据段和代码段")]),e._v(" "),t("p",[e._v("内核空间：我们在编写应用程序（非内核空间程序）的时候，这一块地址我们是不能够使用的\n栈区域：程序中局部变量、函数参数、返回地址的地方地址。地址从低到高分配\n堆区域：由malloc,calloc等创建的空间，是运行的时候由程序申请的。地址由高到低\nBBS段：未初始化或初值为0的全局变量和静态局部变量\n数据段：已初始化且初值非0的全局变量和静态局部变量\n代码段：可执行代码、字符串字面值、只读变量")]),e._v(" "),t("p",[t("strong",[e._v("Notes:")]),e._v(" "),t("a",{attrs:{href:"https://medium.com/@rahul77349/difference-between-compiler-and-interpreter-with-respect-to-jvm-java-virtual-machine-and-pvm-22fc77ae0eb7",target:"_blank",rel:"noopener noreferrer"}},[e._v("JVM VS Python VM"),t("OutboundLink")],1),e._v("\nJAVA需要经过一次编译成class文件，然后交给JVM跑，Python不需要编译，直接py交给PVM解释运行")]),e._v(" "),t("h3",{attrs:{id:"jvm程序计数器-vs-os程序计数器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm程序计数器-vs-os程序计数器"}},[e._v("#")]),e._v(" JVM程序计数器 VS OS程序计数器")]),e._v(" "),t("p",[e._v("一. 介绍\nJVM程序计数器：")]),e._v(" "),t("p",[e._v("程序计数器是一块较小的内存空间，它的作用可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。- - 摘自《深入理解Java虚拟机》")]),e._v(" "),t("p",[e._v("pc 寄存器又称：程序计数器，指的是：当前线程正在执行的字节码指令地址（行号），简单的说指的是当前线程执行到了哪一行，任意时刻，一个线程只会执行一个方法，pc 寄存器保存一个指向当前线程正在执行的语句的指针。程序运行时，字节码解释器通过改变 pc 寄存器里面的值，达到选取下一条要执行的字节码指令地址的目的。个人理解是，pc 寄存器存储当前正在执行的指令的字节码地址，当该指令结束，字节码解释器会根据pc寄存器里的值选取下一条指令并修改pc寄存器里面的值，达到执行下一条指令的目的。\n字节码解释器可以拿到所有的字节码指令执行顺序，而程序计数器只是为了记录当前执行的字节码指令地址，防止线程切换找不到下一条指令地址。")]),e._v(" "),t("p",[e._v("OS程序计数器：\n为了保证程序(在操作系统中理解为进程)能够连续地执行下去，CPU必须具有某些手段来确定下一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器。在程序开始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器（PC）的内容即是从内存提取的第一条指令的地址。当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址。由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1。 当程序转移时，转移指令执行的最终结果就是要改变PC的值，此PC值就是转去的地址，以此实现转移。有些机器中也称PC为指令指针IP（Instruction Pointer）")]),e._v(" "),t("p",[e._v("二. 特点\nJVM程序计数器：")]),e._v(" "),t("p",[e._v("如果线程正在执行的是Java 方法，则这个计数器记录的是正在执行的虚拟机字节码指令地址")]),e._v(" "),t("p",[e._v("如果正在执行的是Native 方法，则这个技术器值为空（Undefined）")]),e._v(" "),t("p",[e._v("此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域")]),e._v(" "),t("p",[e._v("在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存")]),e._v(" "),t("p",[e._v("OS程序计数器：")]),e._v(" "),t("p",[e._v("PC永远指向下一条待执行指令的内存地址（永远不会为Undefined），并且在程序开始执行前，将程序指令序列的起始地址，即程序的第一条指令所在的内存单元地址送入PC， CPU按照PC的指示从内存读取第一条指令（取指）。")]),e._v(" "),t("p",[e._v("当执行指令时，CPU自动地修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数（指令字节数），使PC总是指向下一条将要取指的指令地址。")]),e._v(" "),t("p",[e._v("由于大多数指令都是按顺序来执行的，所以修改PC的过程通常只是简单的对PC 加“指令字节数”。\n当程序转移时，转移指令执行的最终结果就是要改变PC的值，此PC值就是转去的目标地址。\n处理器总是按照PC指向，取指、译码、执行，以此实现了程序转移。")]),e._v(" "),t("p",[e._v("三.存储位置\nJVM程序技术器：")]),e._v(" "),t("p",[e._v("线程独立的，JVM内存模型一块独立的存储区域，一般是CPU高速缓存中（L1～L3）")]),e._v(" "),t("p",[e._v("OS程序计数器：")]),e._v(" "),t("p",[e._v("OS线程的PC寄存器中。")]),e._v(" "),t("h3",{attrs:{id:"堆heap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆heap"}},[e._v("#")]),e._v(" 堆heap")]),e._v(" "),t("p",[e._v("Heap memory  =  The younger generation  +  The old generation  +  Forever\nThe younger generation  = Eden District  +  Two Survivor District （From and To）")]),e._v(" "),t("p",[e._v("ps_survivor_space\nhttps://stackoverflow.com/questions/14436183/ps-survivor-space-almost-full")]),e._v(" "),t("p",[e._v("字节码引擎后在后台线程执行垃圾收集（minor gc和full gc），当发生垃圾收集的时候，会stop the world暂停当前活跃的线程")]),e._v(" "),t("p",[e._v("gc root")]),e._v(" "),t("p",[e._v("object header 分代年龄")]),e._v(" "),t("p",[e._v("minor gc： 对象new除了后先放到新生代，满了后触发minor gc，挪到from(survivor0)，后面就在from(survivor0) to(survivor1)之间周转，直到被回收，或者直到年龄到达15，被挪到老生代")]),e._v(" "),t("p",[e._v("老生代包含：\n1.长生不死的对象 （比如web服务的bean对象，线程池对象等）\n2.大对象\n3.动态年龄判断")]),e._v(" "),t("p",[e._v("full gc：老年代满了会触发")]),e._v(" "),t("p",[e._v("jdk调优工具jvisualvm （插件 visualgc）")]),e._v(" "),t("p",[t("img",{attrs:{src:"/docs/docs_image/software/java/java_jvm02.png",alt:""}})]),e._v(" "),t("p",[e._v("图中下部分给出了调优的例子")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://www.bilibili.com/video/av74868832/",target:"_blank",rel:"noopener noreferrer"}},[e._v("双十一电商网站亿级流量JVM调优实战视频教程全集"),t("OutboundLink")],1)]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("jmap -heap <pid>\nprint result:\nusing thread-local object allocation.\nParallel GC with 8 thread(s)\n\nHeap Configuration:\n   MinHeapFreeRatio         = 0\n   MaxHeapFreeRatio         = 100\n   MaxHeapSize              = 5221908480 (4980.0MB)\n   NewSize                  = 109051904 (104.0MB)\n   MaxNewSize               = 1740636160 (1660.0MB)\n   OldSize                  = 218103808 (208.0MB)\n   NewRatio                 = 2\n   SurvivorRatio            = 8\n   MetaspaceSize            = 21807104 (20.796875MB)\n   CompressedClassSpaceSize = 1073741824 (1024.0MB)\n   MaxMetaspaceSize         = 17592186044415 MB\n   G1HeapRegionSize         = 0 (0.0MB)\n\nHeap Usage:\nPS Young Generation\nEden Space:\n   capacity = 967835648 (923.0MB)\n   used     = 368550864 (351.4774932861328MB)\n   free     = 599284784 (571.5225067138672MB)\n   38.079901764478095% used\nFrom Space:\n   capacity = 2097152 (2.0MB)\n   used     = 0 (0.0MB)\n   free     = 2097152 (2.0MB)\n   0.0% used\nTo Space:\n   capacity = 20447232 (19.5MB)\n   used     = 0 (0.0MB)\n   free     = 20447232 (19.5MB)\n   0.0% used\nPS Old Generation\n   capacity = 207618048 (198.0MB)\n   used     = 22015016 (20.995155334472656MB)\n   free     = 185603032 (177.00484466552734MB)\n   10.60361380528922% used\n\n21451 interned Strings occupying 2317096 bytes.\n\n\nXX:SurvivorRatio\nhttps://blog.csdn.net/flyfhj/article/details/86630105\n")])])]),t("h2",{attrs:{id:"java内存模型-jmm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java内存模型-jmm"}},[e._v("#")]),e._v(" JAVA内存模型 JMM")]),e._v(" "),t("p",[e._v("从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。 本地内存是JMM的一个抽象概念，它涵盖了各种CPU缓存、寄存器以及其他的硬件和编译器优化。")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://jcp.org/en/jsr/detail?id=133",target:"_blank",rel:"noopener noreferrer"}},[e._v("JSR 133规范"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("openJDK, IBM JDK, 阿里巴巴内部定制JVM")]),e._v(" "),t("p",[e._v("Java 内存模型对主内存与工作内存之间的具体交互协议定义了八种操作，具体如下：")]),e._v(" "),t("ul",[t("li",[e._v("lock（锁定）：作用于主内存变量，把一个变量标识为一条线程独占状态。")]),e._v(" "),t("li",[e._v("unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。")]),e._v(" "),t("li",[e._v("read（读取）：作用于主内存变量，把一个变量从主内存传输到线程的工作内存中，以便随后的 load 动作使用。")]),e._v(" "),t("li",[e._v("load（载入）：作用于工作内存变量，把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。")]),e._v(" "),t("li",[e._v("use（使用）：作用于工作内存变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量值的字节码指令时执行此操作。")]),e._v(" "),t("li",[e._v("assign（赋值）：作用于工作内存变量，把一个从执行引擎接收的值赋值给工作内存的变量，每当虚拟机遇到一个需要给变量进行赋值的字节码指令时执行此操作。")]),e._v(" "),t("li",[e._v("store（存储）：作用于工作内存变量，把工作内存中一个变量的值传递到主内存中，以便后续 write 操作。")]),e._v(" "),t("li",[e._v("write（写入）：作用于主内存变量，把 store 操作从工作内存中得到的值放入主内存变量中。")])]),e._v(" "),t("p",[t("img",{attrs:{src:"/docs/docs_image/software/java/java_jmm01.png",alt:""}})]),e._v(" "),t("p",[e._v("默认如图采用缓存一致性：MESI一致性协议\n总线消息；总线嗅探；总线裁决；\n指令重排 https://efectivejava.blogspot.com/2013/07/what-is-reordering-in-java-when-you.html")]),e._v(" "),t("p",[e._v("总线锁，如果是跨多个缓存行则采取总线锁")]),e._v(" "),t("p",[e._v("volatile避免指令重排，图下部分可见，volatile并不能保证线程安全（线程1最终并非基于线程2的最新结果2加1，而是基于旧的值1计算，虽然知道线程2修改的结果，但是它的做法是直接覆盖！）")]),e._v(" "),t("p",[e._v("入门到放弃\nhttps://juejin.im/post/5b45ef49f265da0f5140489c")]),e._v(" "),t("p",[e._v("JMX Monitor\nhttps://docs.oracle.com/javase/6/docs/technotes/guides/management/agent.html")]),e._v(" "),t("p",[e._v("JPDA\nhttps://zhuanlan.zhihu.com/p/59639046")]),e._v(" "),t("p",[e._v("Load jni library from jar:\nhttps://blog.csdn.net/Revivedsun/article/details/86562934\nhttps://stackoverflow.com/questions/1611357/how-to-make-a-jar-file-that-includes-dll-files\nhttp://www.jdotsoft.com/JarClassLoader.php#tempfiles")]),e._v(" "),t("p",[t("img",{attrs:{src:"/docs/docs_image/software/java/java11.png",alt:""}})]),e._v(" "),t("p",[e._v("file:/C:/Workspace/Temp/XXX.jar!/BOOT-INF/lib/XXX-1.0-SNAPSHOT.jar!/XXXJNI.dll")]),e._v(" "),t("p",[e._v("file:/opt/XXX.jar!/BOOT-INF/lib/XXX-1.0-SNAPSHOT.jar!/libXXXJNI.so")]),e._v(" "),t("p",[e._v('getClass().getResourceAsStream("/filename");\nhttps://stackoverflow.com/questions/20389255/reading-a-resource-file-from-within-jar')]),e._v(" "),t("h3",{attrs:{id:"gc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gc"}},[e._v("#")]),e._v(" GC")]),e._v(" "),t("p",[e._v("https://www.baeldung.com/java-verbose-gc#/\nhttps://juejin.cn/post/6999865723145158670#/\nhttps://www.baeldung.com/jvm-garbage-collectors#/")]),e._v(" "),t("h4",{attrs:{id:"the-serial-collector-stop-the-world"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#the-serial-collector-stop-the-world"}},[e._v("#")]),e._v(" The Serial Collector(Stop-the-world)")]),e._v(" "),t("p",[e._v("The serial collector is the simplest one, and the one you probably won’t be using, as it’s mainly designed for single-threaded environments (e.g. 32 bit or Windows) and for small heaps. This collector freezes all application threads whenever it’s working, which disqualifies it for all intents and purposes from being used in a server environment.")]),e._v(" "),t("p",[e._v("How to use it: You can use it by turning on the -XX:+UseSerialGC JVM argument")]),e._v(" "),t("h4",{attrs:{id:"the-parallel-throughput-collector"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#the-parallel-throughput-collector"}},[e._v("#")]),e._v(" The Parallel/Throughput Collector")]),e._v(" "),t("p",[e._v("Next off is the Parallel collector. This is the JVM’s default collector. Much like its name, its biggest advantage is that is uses multiple threads to scan through and compact the heap. The downside to the parallel collector is that it will stop application threads when performing either a minor or full GC collection. The parallel collector is best suited for apps that can tolerate application pauses and are trying to optimize for lower CPU overhead caused by the collector.")]),e._v(" "),t("h4",{attrs:{id:"the-cms-collector"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#the-cms-collector"}},[e._v("#")]),e._v(" The CMS Collector")]),e._v(" "),t("p",[e._v("Following up on the parallel collector is the CMS collector (“concurrent-mark-sweep”). This algorithm uses multiple threads (“concurrent”) to scan through the heap (“mark”) for unused objects that can be recycled (“sweep”). This algorithm will enter “stop the world” (STW) mode in two cases: when initializing the initial marking of roots (objects in the old generation that are reachable from thread entry points or static variables) and when the application has changed the state of the heap while the algorithm was running concurrently, forcing it to go back and do some final touches to make sure it has the right objects marked.")]),e._v(" "),t("p",[e._v("The biggest concern when using this collector is encountering promotion failures which are instances where a race condition occurs between collecting the young and old generations. If the collector needs to promote young objects to the old generation, but hasn’t had enough time to make space clear it,  it will have to do so first which will result in a full STW collection – the very thing this CMS collector was meant to prevent. To make sure this doesn’t happen you would either increase the size of the old generation (or the entire heap for that matter) or allocate more background threads to the collector for him to compete with the rate of object allocation.")]),e._v(" "),t("p",[e._v("Another downside to this algorithm in comparison to the parallel collector is that it uses more CPU in order to provide the application with higher levels of continuous throughput, by using multiple threads to perform scanning and collection. For most long-running server applications which are adverse to application freezes, that’s usually a good trade off to make. Even so, this algorithm is not on by default. You have to specify XX:+USeParNewGC to actually enable it. If you’re willing to allocate more CPU resources to avoid application pauses this is the collector you’ll probably want to use, assuming that your heap is less than 4Gb in size.  However, if it’s greater than 4GB, you’ll probably want to use the last algorithm – the G1 Collector.")]),e._v(" "),t("h4",{attrs:{id:"the-g1-collector"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#the-g1-collector"}},[e._v("#")]),e._v(" The G1 Collector")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Garbage-First Garbage Collector"),t("OutboundLink")],1),e._v(" "),t("a",{attrs:{href:"https://www.oracle.com/technical-resources/articles/java/g1gc.html#/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Garbage First Garbage Collector Tuning"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("The Garbage first collector (G1) introduced in JDK 7 update 4 was designed to better support heaps larger than 4GB. The G1 collector utilizes multiple background threads to scan through the heap that it divides into regions, spanning from 1MB to 32MB (depending on the size of your heap). G1 collector is geared towards scanning those regions that contain the most garbage objects first, giving it its name (Garbage first). This collector is turned on using the –XX:+UseG1GC flag.")]),e._v(" "),t("p",[e._v("This strategy reduced the chance of the heap being depleted before background threads have finished scanning for unused objects, in which case the collector will have to stop the application which will result in a STW collection. The G1 also has another advantage that is that it compacts the heap on-the-go, something the CMS collector only does during full STW collections.")]),e._v(" "),t("p",[e._v("Large heaps have been a fairly contentious area over the past few years with many developers moving away from the single JVM per machine model to more micro-service, componentized architectures with multiple JVMs per machine. This has been driven by many factors including the desire to isolate different application parts, simplifying deployment and avoiding the cost which would usually come with reloading application classes into memory (something which has actually been improved in Java 8).")]),e._v(" "),t("p",[e._v("Even so, one of the biggest drivers to do this when it comes to the JVM stems from the desire to avoid those long “stop the world” pauses (which can take many seconds in a large collection) that occur with large heaps. This has also been accelerated by container technologies like Docker that enable you to deploy multiple apps on the same physical machine with relative ease.")]),e._v(" "),t("h3",{attrs:{id:"jvm-crash-debug"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm-crash-debug"}},[e._v("#")]),e._v(" JVM Crash debug")]),e._v(" "),t("p",[e._v("注意：jdk版本要跟工具一致（不过我成功的用oracle jdk的visualvm解析了openjdk的hprof文件）")]),e._v(" "),t("ul",[t("li",[e._v("文件类型：\n"),t("ul",[t("li",[e._v("core dump: core.xxx")]),e._v(" "),t("li",[e._v("heap dump: pid.hprof")])])]),e._v(" "),t("li",[e._v("常用工具：\n"),t("ul",[t("li",[e._v("jvisualvm")]),e._v(" "),t("li",[e._v("jps")]),e._v(" "),t("li",[e._v("jstat")]),e._v(" "),t("li",[e._v("jmap")]),e._v(" "),t("li",[e._v("jstack\nhttps://www.jianshu.com/p/c6a04c88900a\nhttps://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr016.html")])])])]),e._v(" "),t("h4",{attrs:{id:"debug-live-process"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#debug-live-process"}},[e._v("#")]),e._v(" Debug Live Process:")]),e._v(" "),t("h5",{attrs:{id:"javax-net-debug"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javax-net-debug"}},[e._v("#")]),e._v(" javax.net.debug")]),e._v(" "),t("p",[e._v("tls/ssl:\njava -jar -Djavax.net.debug=all\njava -jar -Djavax.net.debug=help")]),e._v(" "),t("p",[e._v("java -XX:ErrorFile=/var/log/java/java_error%p.log\nIf the -XX:ErrorFile=file flag is not specified, the default log file name is hs_err_pid.log, where pid is the PID of the process.")]),e._v(" "),t("p",[e._v("JVM参数\nhttps://stackoverflow.com/questions/43087831/complete-list-of-jvm-options\njava -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+PrintFlagsFinal -XX:+PrintFlagsWithComments -version\nJVM启动参数大全 https://www.cnblogs.com/qlqwjy/p/8037797.html")]),e._v(" "),t("p",[e._v("java -cp vs java -jar\nhttps://stackoverflow.com/questions/11922681/differences-between-java-cp-and-java-jar\n基本区别就是，如果jar包，比如springboot的包将依赖都已经打入了META-INF，则用-jar，否则如果需要依赖外部的lib，则需要用cp指定classpath\njava -server -jar *.jar\njava程序启动参数-D含义详解 https://www.cnblogs.com/grefr/p/6087955.html")]),e._v(" "),t("h5",{attrs:{id:"strace"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#strace"}},[e._v("#")]),e._v(" strace")]),e._v(" "),t("p",[e._v("strace -tt -f -o /tmp/output.log -p {pid}")]),e._v(" "),t("h4",{attrs:{id:"analysis-core-dump"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#analysis-core-dump"}},[e._v("#")]),e._v(" Analysis Core dump")]),e._v(" "),t("p",[e._v("core file(core.XXX):\nIn case of a JVM crash, the operating system creates a core dump file which is a memory snapshot of a running process. A core dump is created by the operating system when a fatal or unhandled error like signal or system exception occurs.")]),e._v(" "),t("p",[e._v("版本问题： 如果产品上装了多个JVM环境的化，注意core dump要和JVM的分析的版本一致（比如用的是openjdk还是oracle的）\nSA环境需要root权限")]),e._v(" "),t("p",[e._v("系统配置：\nulimit -c unlimited，")]),e._v(" "),t("p",[e._v("不过对于java来说，jvm本身可能有自己的设置，默认应该就是unlimited，所以可以忽略系统设置，查看配置：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("jps\njinfo <PROCESS ID>\ncat /proc/<PROCESS ID>/limits\n")])])]),t("h4",{attrs:{id:"jstat"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jstat"}},[e._v("#")]),e._v(" JSTAT")]),e._v(" "),t("p",[e._v("JVM Statistical monitoring tools")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("jstat -gc <PID> 250 4 //sampling interval is 250ms,Sampling number for 4\n\nOutput:\nS0C、S1C、S0U、S1U：Survivor 0/1 Area capacity （Capacity） And usage （Used）\nEC、EU：Eden Area capacity and usage \nOC、OU： Capacity and usage of older generations \nPC、PU： Permanent generation capacity and usage \nYGC、YGT： The younger generation GC Times and GC Time consuming \nFGC、FGCT：Full GC Times and Full GC Time consuming \nGCT：GC Total time \n")])])]),t("p",[e._v("hprof: to show CPU Usage rate , Statistics heap memory usage .")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("java -agentlib:hprof[=options] ToBeProfiledClass\njava -Xrunprof[:options] ToBeProfiledClass\njavac -J-agentlib:hprof[=options] ToBeProfiledClass\n\nexample:\njava -agentlib:hprof=cpu=samples,interval=20,depth=3 Hello\n\nEvery other day on the top 20 Millisecond sampling CPU Consumption information , The stack depth is 3, Generated profile File name is java.hprof.txt, In the current directory .\n")])])]),t("h4",{attrs:{id:"jstack-live-process-core-dump"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jstack-live-process-core-dump"}},[e._v("#")]),e._v(" JSTACK -> Live Process|Core dump")]),e._v(" "),t("p",[e._v("查死锁\njstack -J-d64 -l -m $JAVA_HOME/bin/java core.xxxxx")]),e._v(" "),t("p",[e._v("查内存泄露")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('top -Hp <PID>\n输出结果，TIME一列查看时间占用比较久的 NID\nprintf "%x" <NID>\njstack <PID>|grep <NID IN hex format>\n')])])]),t("p",[e._v("https://www.cnblogs.com/duanxz/p/5487576.html")]),e._v(" "),t("h4",{attrs:{id:"jmap-jhat"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jmap-jhat"}},[e._v("#")]),e._v(" JMAP | JHAT")]),e._v(" "),t("p",[e._v("查内存占用，jhat追查内存泄露\nhttps://programs.wiki/wiki/performance-test-and-analysis-tools-jps-jstack-jmap-jhat-jstat-hprof-use-details.html")]),e._v(" "),t("p",[e._v("jmap $JAVA_HOME/bin/java core.xxxxx")]),e._v(" "),t("p",[e._v("jmap -J-d64")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("jmap -heap \njmap -histo\n")])])]),t("p",[e._v("jmap + jhat")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("jmap -dump:format=b,file=core.xxxxx.dump  $JAVA_HOME/bin/java core.xxxxx\n\njhat -port 9998 core.xxxxx.dump\n\nopen in browser: http://XXX:9998\n")])])]),t("p",[e._v('jmap crashes with "can not get class data for" known bug, fixed starting with Java 8 Update 60.\nhttps://stackoverflow.com/questions/26882094/jmap-crashes-with-can-not-get-class-data-for')]),e._v(" "),t("h4",{attrs:{id:"hsdb-live-process-core-dump"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hsdb-live-process-core-dump"}},[e._v("#")]),e._v(" HSDB -> Live Process|Core dump")]),e._v(" "),t("p",[e._v("Java9为了简化hsdb和clhsdb的使用引入了一个新的命令jhsdb，可以通过该命令直接调用hsdb，clhsdb，jstack, jmap等命令\njhsdb jmap --histo --exe $JAVA_HOME/bin/java --core core.xxxxx")]),e._v(" "),t("p",[e._v("openjdk:\nGUI: sun.jvm.hotspot.HSDB\ncommand: sun.jvm.hotspot.CLHSDB")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("java -cp .:$JAVA_HOME/lib/sa-jdi.jar sun.jvm.hotspot.CLHSDB\njava -cp .:$JAVA_HOME/lib/sa-jdi.jar sun.jvm.hotspot.CLHSDB $JAVA_HOME/bin/java /opt/core.10759\njava -cp .:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.232.b09-0.el7_7.x86_64/lib/sa-jdi.jar sun.jvm.hotspot.CLHSDB /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.232.b09-0.el7_7.x86_64/bin/java /opt/core.10759\n\n\n输入threads可以查看所有的子线程，输入thread 线程id可以查看该线程的详情\njhisto：trying to print a histogram from the core dump, which shows an unusually high number of instances for Object. \nclasses是列出已经加载的所有的类的类型信息，class 完整类名是查找该类的类型信息\nInspect，用于查看指定地址的类（C++的类）的各属性信息\njstack用于查看是否存在死锁，查看所有线程的调用栈，加上-v选项可以输出详细的内存地址信息\npstack [-v]\nuniverse同图形界面中的Heap Paramters选项，显示年轻代和老年代堆内存的地址范围\nscanoops 用于在指定地址范围内搜索所有指定类型的所有实例（Oop），后跟起始地址和类型信息，然后通过inspect 可查看具体的实例属性\nrevptrs可根据对象地址查看引用该对象的活跃对象的地址，这里的引用是指通过类全局属性而非局部变量引用，修改上述测试用例在类A中增加一个私有属性，private Base ba=new Base(1);，然后依次执行universe，scanoops,revptrs，inspect命令\nmem命令可查看指定起始地址和以位宽为单位的长度的内存的数据，64位CPU的位宽是8字节\nprint输入一个Klass*, Method*的地址，可以打印该类或者方法，效果等同于Code Viewer选项\nwhere 通过threads可查看所有的线程，输入线程id，查看该线程的调用栈，输入-a，查看所有线程的调用栈\nprintas 后跟一个Hotspot Type和地址，会打印该Type对象的各属性，效果同inspect命令，不过不局限与oop，也可以是对象的真实地址\nprintstatics 可以用于获取Hotspot 定义的C++类的静态属性，如表示Java堆内存的Universe对象\nprintmdo用于打印指定地址的MethodData对象，该对象保存了Profile统计的方法性能的数据\n\nhsdb> threads\n.....\n30977 main\nhsdb> where 30977\nThread 30977 Address: 0x00007fbd80008800\n\nJava Stack Trace for main\nThread state = BLOCKED\n\nhsdb> jhisto\n\nhsdb> help\nAvailable commands:\n  assert true | false\n  attach pid | exec core\n  buildreplayjars [ all | app | boot ]  | [ prefix ]\n  class name\n  classes\n  detach\n  dis address [length]\n  disassemble address\n  dumpcfg { -a | id }\n  dumpclass { address | name } [ directory ]\n  dumpcodecache\n  dumpheap [ file ]\n  dumpideal { -a | id }\n  dumpilt { -a | id }\n  dumpreplaydata { <address > | -a | <thread_id> }\n  echo [ true | false ]\n  examine [ address/count ] | [ address,address]\n  field [ type [ name fieldtype isStatic offset address ] ]\n  findpc address\n  flags [ flag | -nd ]\n  help [ command ]\n  history\n  inspect expression\n  intConstant [ name [ value ] ]\n  jdis address\n  jhisto\n  jseval script\n  jsload file\n  jstack [-v]\n  livenmethods\n  longConstant [ name [ value ] ]\n  mem address [ length ]\n  pmap\n  print expression\n  printall\n  printas type expression\n  printmdo [ -a | expression ]\n  printstatics [ type ]\n  pstack [-v]\n  quit\n  reattach\n  revptrs address\n  scanoops start end [ type ]\n  search [ heap | perm | rawheap | codecache | threads ] value\n  source filename\n  symbol address\n  symboldump\n  symboltable name\n  sysprops\n  thread { -a | id }\n  threads\n  tokenize ...\n  type [ type [ name super isOop isInteger isUnsigned size ] ]\n  universe\n  verbose true | false\n  versioncheck [ true | false ]\n  vmstructsdump\n  whatis address\n  where { -a | id }\n\n")])])]),t("h4",{attrs:{id:"jdb"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jdb"}},[e._v("#")]),e._v(" JDB")]),e._v(" "),t("p",[e._v("https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jdb.html\nhttps://stackoverflow.com/questions/20018866/specifying-sourcepath-in-jdb-what-am-i-doing-wrong\nhttps://stackoverflow.com/questions/19843096/how-to-debug-a-java-application-without-access-to-the-source-code/58555431#58555431\nhttps://stackoverflow.com/questions/3668379/use-a-jar-with-source-as-source-for-jdb/58603802#58603802")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Live:\njava -jar -agentlib:jdwp=transport=dt_shmem,address=jdbconn,server=y,suspend=n C:\\Workspace\\EclipseWorkspace\\lyhistory-websocket\\lyhistory-websocket.jar\njdb -attach jdbconn\njdb -sourcepath BOOT-INF/classes/ -classpath . org.springframework.boot.loader.JarLauncher\n\njdb -sourcepath BOOT-INF/classes/ -classpath .;BOOT-INF/classes/\nstop at com.lyhistory.framework.websocket.endpoint.GeneralWebSocketEndpoint:54\nstop at com.lyhistory.framework.websocket.handler.DefaultWebSocketMessageHandler:32\nstop in DefaultWebSocketMessageHandler.receiveMessage\nstop in com.lyhistory.framework.websocket.endpoint.GeneralWebSocketEndpoint.onMessage\nstop in com.alibaba.fastjson.parser.JSONLexerBase.scanString\n\t  public final void scanString() {\n\t  public String scanString(char expectNextChar) {\nstop at com.alibaba.fastjson.parser.JSONLexerBase:880\nrun org.springframework.boot.loader.JarLauncher\n\njdb -sourcepath BOOT-INF/classes/ -classpath .;BOOT-INF/classes/;BOOT-INF/lib/\n\tstop at com.lyhistory.framework.cache.autoconfigure.support.WebsocketMessageListener:35\n\tstop at org.springframework.data.redis.listener.RedisMessageListenerContainer:968\n\tstop at com.lyhistory.framework.websocket.endpoint.GeneralWebSocketEndpoint:54\nstop at com.lyhistory.framework.websocket.handler.DefaultWebSocketMessageHandler:32\nstop at com.alibaba.fastjson.parser.JSONLexerBase:880\nrun org.springframework.boot.loader.JarLauncher\n\n** command list **\nconnectors                -- list available connectors and transports in this VM\n\nrun [class [args]]        -- start execution of application's main class\n\nthreads [threadgroup]     -- list threads\nthread <thread id>        -- set default thread\nsuspend [thread id(s)]    -- suspend threads (default: all)\nresume [thread id(s)]     -- resume threads (default: all)\nwhere [<thread id> | all] -- dump a thread's stack\nwherei [<thread id> | all]-- dump a thread's stack, with pc info\nup [n frames]             -- move up a thread's stack\ndown [n frames]           -- move down a thread's stack\nkill <thread id> <expr>   -- kill a thread with the given exception object\ninterrupt <thread id>     -- interrupt a thread\n\nprint <expr>              -- print value of expression\ndump <expr>               -- print all object information\neval <expr>               -- evaluate expression (same as print)\nset <lvalue> = <expr>     -- assign new value to field/variable/array element\nlocals                    -- print all local variables in current stack frame\n\nclasses                   -- list currently known classes\nclass <class id>          -- show details of named class\nmethods <class id>        -- list a class's methods\nfields <class id>         -- list a class's fields\n\nthreadgroups              -- list threadgroups\nthreadgroup <name>        -- set current threadgroup\n\nstop in <class id>.<method>[(argument_type,...)]\n                          -- set a breakpoint in a method\nstop at <class id>:<line> -- set a breakpoint at a line\nclear <class id>.<method>[(argument_type,...)]\n                          -- clear a breakpoint in a method\nclear <class id>:<line>   -- clear a breakpoint at a line\nclear                     -- list breakpoints\ncatch [uncaught|caught|all] <class id>|<class pattern>\n                          -- break when specified exception occurs\nignore [uncaught|caught|all] <class id>|<class pattern>\n                          -- cancel 'catch' for the specified exception\nwatch [access|all] <class id>.<field name>\n                          -- watch access/modifications to a field\nunwatch [access|all] <class id>.<field name>\n                          -- discontinue watching access/modifications to a field\ntrace [go] methods [thread]\n                          -- trace method entries and exits.\n                          -- All threads are suspended unless 'go' is specified\ntrace [go] method exit | exits [thread]\n                          -- trace the current method's exit, or all methods' exits\n                          -- All threads are suspended unless 'go' is specified\nuntrace [methods]         -- stop tracing method entrys and/or exits\nstep                      -- execute current line\nstep up                   -- execute until the current method returns to its caller\nstepi                     -- execute current instruction\nnext                      -- step one line (step OVER calls)\ncont                      -- continue execution from breakpoint\n\nlist [line number|method] -- print source code\nuse (or sourcepath) [source file path]\n                          -- display or change the source path\nexclude [<class pattern>, ... | \"none\"]\n                          -- do not report step or method events for specified classes\nclasspath                 -- print classpath info from target VM\n\nmonitor <command>         -- execute command each time the program stops\nmonitor                   -- list monitors\nunmonitor <monitor#>      -- delete a monitor\nread <filename>           -- read and execute a command file\n\nlock <expr>               -- print lock info for an object\nthreadlocks [thread id]   -- print lock info for a thread\n\npop                       -- pop the stack through and including the current frame\nreenter                   -- same as pop, but current frame is reentered\nredefine <class id> <class file name>\n                          -- redefine the code for a class\n\ndisablegc <expr>          -- prevent garbage collection of an object\nenablegc <expr>           -- permit garbage collection of an object\n\n!!                        -- repeat last command\n<n> <command>             -- repeat command n times\n# <command>               -- discard (no-op)\nhelp (or ?)               -- list commands\nversion                   -- print version information\nexit (or quit)            -- exit debugger\n\n<class id>: a full class name with package qualifiers\n<class pattern>: a class name with a leading or trailing wildcard ('*')\n<thread id>: thread number as reported in the 'threads' command\n<expr>: a Java(TM) Programming Language expression.\nMost common syntax is supported.\n\nStartup commands can be placed in either \"jdb.ini\" or \".jdbrc\"\nin user.home or user.dir\n\nCore dump:\njdb -connect sun.jvm.hotspot.jdi.SACoreAttachingConnector:javaExecutable=$JAVA_HOME/bin/java,core=core.XXXX\n")])])]),t("p",[t("img",{attrs:{src:"/docs/docs_image/software/java/java01.png",alt:"测试例子"}})]),e._v(" "),t("h4",{attrs:{id:"gdb"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gdb"}},[e._v("#")]),e._v(" GDB")]),e._v(" "),t("p",[e._v("https://darkdust.net/files/GDB%20Cheat%20Sheet.pdf")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ export LD_LIBRARY_PATH=/customized/lib\n$ gdb --args bin/HelloWorld config/some.xml\n<gdb>run\n\n\n$ gdb $JAVA_HOME/bin/java core.xxxxx\n>where\n>bt\n")])])]),t("p",[e._v("https://blog.csdn.net/haolipengzhanshen/article/details/106728244?ops_request_misc=%7B%22request_id%22%3A%22165362535516781818746673%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=165362535516781818746673&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-106728244-null-null.142%5Ev11%5Epc_search_result_control_group,157%5Ev12%5Enew_style1&utm_term=free%28%29%3A+invalid+size&spm=1018.2226.3001.4187")]),e._v(" "),t("h4",{attrs:{id:"arthas-阿尔萨斯"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#arthas-阿尔萨斯"}},[e._v("#")]),e._v(" Arthas（阿尔萨斯）")]),e._v(" "),t("p",[e._v("https://github.com/alibaba/arthas\nhttps://arthas.aliyun.com/doc/")]),e._v(" "),t("p",[e._v("case study: https://github.com/alibaba/arthas/issues?q=label%3Auser-case")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("unzip arthas-bin.zip -d arthas\ncd arthas\njava -jar arthas-boot.jar\n>dashboard\n\njava -javaagent:/tmp/test/arthas-agent.jar -jar math-game.jar\n./as.sh --select <program name>\n")])])]),t("h4",{attrs:{id:"mat"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mat"}},[e._v("#")]),e._v(" MAT")]),e._v(" "),t("p",[e._v("https://www.eclipse.org/mat/downloads.php")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("jmap -dump:format=b,file=core.26635.dump  $JAVA_HOME/bin/java core.26635 \n")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);