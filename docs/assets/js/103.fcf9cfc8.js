(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{533:function(e,t,n){"use strict";n.r(t);var o=n(56),a=Object(o.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"_1-intro"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-intro"}},[e._v("#")]),e._v(" 1. intro")]),e._v(" "),n("p",[e._v("https://cbonte.github.io/haproxy-dconv/2.3/intro.html")]),e._v(" "),n("p",[e._v("what it does, what it doesn't do, some known traps to avoid, some OS-specific limitations, how to get it, how it evolves, how to ensure you're running with all known fixes")]),e._v(" "),n("p",[e._v("Load balancing consists in aggregating multiple components in order to achieve a total processing capacity above each component's individual capacity, without any intervention from the end user and in a scalable way.")]),e._v(" "),n("p",[e._v("A good example of this is the number of lanes on a highway which allows as many cars to pass during the same time frame without increasing their individual speed")]),e._v(" "),n("p",[e._v("A load balancer may act :")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("at the link level : this is called link load balancing, and it consists in\nchoosing what network link to send a packet to;\nL4 传输层（通过L3网络层的ip加传输层的端口决定流量负载） Stateful/Stateless")])]),e._v(" "),n("li",[n("p",[e._v("at the network level : this is called network load balancing, and it\nconsists in choosing what route a series of packets will follow;\nL7 应用层（在L4基础上，还可以通过URL、头信息、浏览器等决定流量负载） Stateful")])]),e._v(" "),n("li",[n("p",[e._v("at the server level : this is called server load balancing and it consists\nin deciding what server will process a connection or request.")])])]),e._v(" "),n("p",[e._v("packet based VS proxy based:")]),e._v(" "),n("p",[e._v("[https://ipwithease.com/packet-based-design-vs-full-proxy-design-in-f5/#:~:text=Packet%20based%20designs%20have%20a,connection%20between%20client%20and%20server.&text=With%20full%20proxy%20mode%2C%20we,middle%20of%20client%20and%20server.](https://ipwithease.com/packet-based-design-vs-full-proxy-design-in-f5/#:~:text=Packet based designs have a,connection between client and server.&text=With full proxy mode%2C we,middle of client and server.)")]),e._v(" "),n("p",[e._v("Packet-based load balancers are generally deployed in cut-through mode, so they are installed on the normal path of the traffic and divert it according to the configuration.\nProxy-based load balancers are deployed as a server with their own IP addresses and ports, without architecture changes. \tSometimes this requires to perform some adaptations to the applications so that clients are properly directed to the load balancer's IP address and not directly to the server's.")]),e._v(" "),n("p",[e._v("Note:")]),e._v(" "),n("p",[e._v("haproxy is not a packet-based load balancer: it will not see IP packets nor UDP datagrams, will not perform NAT or even less DSR. These are tasks for lower layers. Some kernel-based components such as IPVS (Linux Virtual Server) already do this pretty well and complement perfectly with HAProxy.")]),e._v(" "),n("p",[e._v("Linux Virtual Server (LVS or IPVS) is the layer 4 load balancer included within the Linux kernel. It works at the packet level and handles TCP and UDP.")]),e._v(" "),n("p",[e._v("所以网上说haproxy提供了L4转发能力，实际上haproxy只是借助内核来实现的")]),e._v(" "),n("p",[e._v("https://www.cnblogs.com/passzhang/p/12090657.html")]),e._v(" "),n("p",[e._v("HAProxy:")]),e._v(" "),n("p",[e._v("TCP Proxy:")]),e._v(" "),n("p",[e._v("it can accept a TCP connection from a listening socket, connect to a server and attach these sockets together allowing traffic to flow in both directions; "),n("strong",[e._v("IPv4, IPv6 and even UNIX sockets")]),e._v("are supported on either side")]),e._v(" "),n("p",[e._v("HTTP reverse-proxy/Gateway:")]),e._v(" "),n("p",[e._v("it presents itself as a server, receives HTTP requests over connections accepted on a listening TCP socket, and passes the requests from these connections to servers using different connections")]),e._v(" "),n("p",[e._v("SSL terminator / initiator / offloader:")]),e._v(" "),n("p",[e._v("SSL/TLS may be used on the connection coming from the client, on the connection going to the server, or even on both connections.")]),e._v(" "),n("p",[e._v("TCP normalizer:")]),e._v(" "),n("p",[e._v("abnormal traffic such as invalid packets, flag combinations, window advertisements, sequence numbers, incomplete connections (SYN floods), or so will not be passed to the other side. This protects fragile TCP stacks from protocol attacks, and also allows to optimize the connection parameters with the client without having to modify the servers' TCP stack settings.")]),e._v(" "),n("p",[e._v("HTTP normalizer:")]),e._v(" "),n("p",[e._v("protects against a lot of protocol-based attacks")]),e._v(" "),n("p",[e._v("HTTP fixing tool:")]),e._v(" "),n("p",[e._v("fixing interoperability issues in complex environments.")]),e._v(" "),n("p",[e._v("content-based switch:")]),e._v(" "),n("p",[e._v("it can consider any element from the request to decide what server to pass the request or connection to. Thus it is possible to handle multiple protocols over a same port (e.g. HTTP, HTTPS, SSH).")]),e._v(" "),n("p",[e._v("server load balancer:")]),e._v(" "),n("p",[e._v("it can load balance TCP connections and HTTP requests. In TCP mode, load balancing decisions are taken for the whole connection. In HTTP mode, decisions are taken per request")]),e._v(" "),n("p",[e._v("traffic regulator:")]),e._v(" "),n("p",[e._v("it can apply some rate limiting at various points, protect the servers against overloading, adjust traffic priorities based on the contents, and even pass such information to lower layers and outer network components by marking packets.")]),e._v(" "),n("p",[e._v("protection against DDoS and service abuse:")]),e._v(" "),n("p",[e._v("it can maintain a wide number of statistics per IP address, URL, cookie, etc and detect when an abuse is happening, then take action (slow down the offenders, block them, send them to outdated contents, etc)")]),e._v(" "),n("p",[e._v("observation point for network troubleshooting:")]),e._v(" "),n("p",[e._v("due to the precision of the information reported in logs, it is often used to narrow down some network-related issues.")]),e._v(" "),n("p",[e._v("HTTP compression offloader:")]),e._v(" "),n("p",[e._v("it can compress responses which were not compressed by the server, thus reducing the page load time for clients with poor connectivity or using high-latency, mobile networks.")]),e._v(" "),n("p",[e._v("caching proxy:")]),e._v(" "),n("p",[e._v("Please note that this caching feature is designed to be maintenance free and focuses solely on saving haproxy's precious resources and not on save the server's resources.")]),e._v(" "),n("p",[e._v("FastCGI gateway:")]),e._v(" "),n("p",[e._v("FastCGI can be seen as a different representation of HTTP")]),e._v(" "),n("ul",[n("li",[e._v("process incoming connections;")]),e._v(" "),n("li",[e._v("periodically check the servers' status (known as health checks);")]),e._v(" "),n("li",[e._v("exchange information with other haproxy nodes.")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('  - accept incoming connections from listening sockets that belong to a\n    configuration entity known as a "frontend", which references one or multiple\n    listening addresses;\n\n  - apply the frontend-specific processing rules to these connections that may\n    result in blocking them, modifying some headers, or intercepting them to\n    execute some internal applets such as the statistics page or the CLI;\n\n  - pass these incoming connections to another configuration entity representing\n    a server farm known as a "backend", which contains the list of servers and\n    the load balancing strategy for this server farm;\n\n  - apply the backend-specific processing rules to these connections;\n\n  - decide which server to forward the connection to according to the load\n    balancing strategy;\n\n  - apply the backend-specific processing rules to the response data;\n\n  - apply the frontend-specific processing rules to the response data;\n\n  - emit a log to report what happened in fine details;\n\n  - in HTTP, loop back to the second step to wait for a new request, otherwise\n    close the connection.\n')])])]),n("h2",{attrs:{id:"_2-management"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-management"}},[e._v("#")]),e._v(" 2. management")]),e._v(" "),n("p",[e._v("https://cbonte.github.io/haproxy-dconv/2.3/management.html")]),e._v(" "),n("p",[e._v("how to start haproxy, how to manage it at runtime, how to manage it on multiple nodes, and how to proceed with seamless upgrades")]),e._v(" "),n("h3",{attrs:{id:"_2-1-install"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-install"}},[e._v("#")]),e._v(" 2.1 install")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("-------------------------------------------------------------\n--- step 1: dependencies::\n-------------------------------------------------------------\nyum install openssl-devel pcre-devel zlib-devel\n\n-------------------------------------------------------------\n--- step 2: make install\n-------------------------------------------------------------\nwget https://www.haproxy.org/download/2.2/src/haproxy-2.2.1.tar.gz\ntar zxvf haproxy-2.2.1.tar.gz\n\ncd haproxy-2.2.1\n# uname -r\n# 3.10.0-327.el7.x86_64\n# make TARGET=linux2628 USE_PCRE=1 USE_OPENSSL=1 USE_ZLIB=1 USE_LIBCRYPT=1\nmake target=linux31 failed!\nmake TARGET=linux2628 removed from haproxy\nmake TARGET=linux-glibc\n\n/*\nmake install\ncp -R /usr/local/sbin/haproxy /usr/sbin\nmake install PREFIX=/usr/local/haproxy\n*/\n\n$make install\t#默认会安装到 /usr/local/sbin下面\n‘haproxy’ -> ‘/usr/local/sbin/haproxy’\n‘doc/haproxy.1’ -> ‘/usr/local/share/man/man1/haproxy.1’\ninstall: creating directory ‘/usr/local/doc’\ninstall: creating directory ‘/usr/local/doc/haproxy’\n‘doc/configuration.txt’ -> ‘/usr/local/doc/haproxy/configuration.txt’\n‘doc/management.txt’ -> ‘/usr/local/doc/haproxy/management.txt’\n‘doc/seamless_reload.txt’ -> ‘/usr/local/doc/haproxy/seamless_reload.txt’\n‘doc/architecture.txt’ -> ‘/usr/local/doc/haproxy/architecture.txt’\n‘doc/peers-v2.0.txt’ -> ‘/usr/local/doc/haproxy/peers-v2.0.txt’\n‘doc/regression-testing.txt’ -> ‘/usr/local/doc/haproxy/regression-testing.txt’\n‘doc/cookie-options.txt’ -> ‘/usr/local/doc/haproxy/cookie-options.txt’\n‘doc/lua.txt’ -> ‘/usr/local/doc/haproxy/lua.txt’\n‘doc/WURFL-device-detection.txt’ -> ‘/usr/local/doc/haproxy/WURFL-device-detection.txt’\n‘doc/proxy-protocol.txt’ -> ‘/usr/local/doc/haproxy/proxy-protocol.txt’\n‘doc/linux-syn-cookies.txt’ -> ‘/usr/local/doc/haproxy/linux-syn-cookies.txt’\n‘doc/SOCKS4.protocol.txt’ -> ‘/usr/local/doc/haproxy/SOCKS4.protocol.txt’\n‘doc/network-namespaces.txt’ -> ‘/usr/local/doc/haproxy/network-namespaces.txt’\n‘doc/DeviceAtlas-device-detection.txt’ -> ‘/usr/local/doc/haproxy/DeviceAtlas-device-detection.txt’\n‘doc/51Degrees-device-detection.txt’ -> ‘/usr/local/doc/haproxy/51Degrees-device-detection.txt’\n‘doc/netscaler-client-ip-insertion-protocol.txt’ -> ‘/usr/local/doc/haproxy/netscaler-client-ip-insertion-protocol.txt’\n‘doc/peers.txt’ -> ‘/usr/local/doc/haproxy/peers.txt’\n‘doc/close-options.txt’ -> ‘/usr/local/doc/haproxy/close-options.txt’\n‘doc/SPOE.txt’ -> ‘/usr/local/doc/haproxy/SPOE.txt’\n‘doc/intro.txt’ -> ‘/usr/local/doc/haproxy/intro.txt’\n\n-------------------------------------------------------------\n--- step 3: Configuraiton\n-------------------------------------------------------------\nmkdir -p /etc/haproxy\ncp -R examples/option-http_proxy.cfg /etc/haproxy/haproxy.cfg\nvim /etc/haproxy/haproxy.cfg\n\tglobal\n        maxconn         20000\n        ulimit-n        16384\n        log             127.0.0.1 local0\n        uid             99\n        gid             99\n        chroot          /var/empty\n        nbproc          4\n        daemon\n    listen test_nginx\n        bind    0.0.0.0:82\n        mode    http\n        server A 127.0.0.1:80\n\tlisten stats\n        bind    0.0.0.0:1080\n        mode    http\n        maxconn 10\n        stats refresh 30s\n        stats uri /stats\n\t\nfrontend http-in\n bind *:80\n default_backend appZ-backend\nbackend appZ-backend\n balance roundrobin\n server appZ_01 IP_OF_MACHINE_01:8080 check\n server appZ_02 IP_OF_MACHINE_02:8080 check\n \n\n-------------------------------------------------------------\n--- step 4: 配置脚本启动与关闭haproxy\n-------------------------------------------------------------\ncp -R examples/haproxy.init /etc/init.d/haproxy\nchmod +x /etc/init.d/haproxy\nchkconfig --add haproxy ！刚开始我漏了这一步，所以造成后面的问题\nvi /etc/rc.d/init.d/haproxy  #这里需要把BIN的值替换为BIN=haproxy安装目录/sbin/$BASENAME\n\tBIN=/usr/local/sbin/$BASENAME\n\n启动 service haproxy start\n关闭 service haproxy stop\n重启 service haproxy restart\n\n● haproxy.service - SYSV: HA-Proxy is a TCP/HTTP reverse proxy which is particularly suited for high availability environments.\n   Loaded: loaded (/etc/rc.d/init.d/haproxy)\n   Active: failed (Result: exit-code) since Tue 2020-07-28 19:52:56 SGT; 13min ago\n     Docs: man:systemd-sysv-generator(8)\n\nJul 28 19:52:56 vm2-devclr-v08 haproxy[13682]: Errors found in configuration file, check it with 'haproxy check'.\nJul 28 19:52:56 vm2-devclr-v08 systemd[1]: haproxy.service: control process exited, code=exited status=1\nJul 28 19:52:56 vm2-devclr-v08 systemd[1]: Failed to start SYSV: HA-Proxy is a TCP/HTTP reverse proxy which is particularly suited for high availability environments..\nJul 28 19:52:56 vm2-devclr-v08 systemd[1]: Unit haproxy.service entered failed state.\nJul 28 19:52:56 vm2-devclr-v08 systemd[1]: haproxy.service failed.\n\n/usr/local/sbin/haproxy -c -- /etc/haproxy/haproxy.cfg\n检查无问题\n/usr/local/sbin/haproxy -- /etc/haproxy/haproxy.cfg\n试着启动无问题，测试也无问题，但是无法用systemctl控制启动停止\n killall haproxy\n \n发现需要 \nchkconfig --add haproxy\n就可以通过systemctl启动和停止\n\n启动后可通过http://ip:1080/stats页面查看\n\n$find / -name \"haproxy\"\n/run/lock/subsys/haproxy\n/var/log/haproxy\n/etc/rc.d/init.d/haproxy\n/etc/haproxy\n/usr/local/sbin/haproxy\n/usr/local/doc/haproxy\n/opt/haproxy-2.2.1/include/haproxy\n/opt/haproxy-2.2.1/haproxy\n\nhttps://blog.csdn.net/demon7639/article/details/76234306\nhttps://blog.csdn.net/qq_28710983/article/details/82194404\n")])])]),n("p",[e._v("haproxy集群技巧")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(' $ cat site1.env\n  LISTEN=192.168.1.1\n  CACHE_PFX=192.168.11\n  SERVER_PFX=192.168.22\n  LOGGER=192.168.33.1\n  STATSLP=admin:pa$$w0rd\n  ABUSERS=/etc/haproxy/abuse.lst\n  TIMEOUT=10s\n\n  $ cat haproxy.cfg\n  global\n      log "${LOGGER}:514" local0\n\n  defaults\n      mode http\n      timeout client "${TIMEOUT}"\n      timeout server "${TIMEOUT}"\n      timeout connect 5s\n\n  frontend public\n      bind "${LISTEN}:80"\n      http-request reject if { src -f "${ABUSERS}" }\n      stats uri /stats\n      stats auth "${STATSLP}"\n      use_backend cache if { path_end .jpg .css .ico }\n      default_backend server\n\n  backend cache\n      server cache1 "${CACHE_PFX}.1:18080" check\n      server cache2 "${CACHE_PFX}.2:18080" check\n\n  backend server\n      server cache1 "${SERVER_PFX}.1:8080" check\n      server cache2 "${SERVER_PFX}.2:8080" check\n')])])]),n("h3",{attrs:{id:"_2-2-logging"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-logging"}},[e._v("#")]),e._v(" 2.2 Logging")]),e._v(" "),n("p",[e._v("https://cbonte.github.io/haproxy-dconv/2.3/management.html#8")]),e._v(" "),n("p",[e._v("首先 为什么haproxy不能自己写log，要通过udp发送给linux系统自带的rsyslog，是因为安全考虑，haproxy的jail模式无法访问文件系统")]),e._v(" "),n("p",[e._v("/etc下面没有找到syslog或sysklogd，找到了rsyslog，而且确实看到有这个rsyslog在运行：")]),e._v(" "),n("p",[e._v("systemctl status rsyslog，根据文档修改配置（注意并没有给UDPServerAddress *）")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('mkdir -p /var/log/haproxy\nchmod a+w /var/log/haproxy\n\n#对于本机来说不需要设置，如果是作为中央日志服务器则需要！\nvim /etc/sysconfig/rsyslog \nSYSLOGD_OPTIONS="-r -m 0 -c 2"\t# “-r”选项以允许接受外来日志消息,-m 0表示给日志添加-- MARK --标记，0表示关闭标记。举例，-m 240，表示每隔240分钟（每天6次）在日志文件里增加一行时间戳消息。日志文件里的“--MARK--”消息可以让你知道中央日志服务器上的syslog守护进程没有停工偷懒。\n\nvim /etc/rsyslog.conf\n$ModLoad imudp\n$UDPServerRun 514\n....\n#save haproxy log\nlocal0.*                                                /var/log/haproxy/haproxy.log\n\n对应到前面/etc/haproxy/haproxy.cfg配置的global：\nlog             127.0.0.1 local0\n其他地方直接用log global引用即可\n\n$systemctl restart rsyslog\n')])])]),n("p",[e._v("haproxy提供了一个小工具halog，需要单独安装")]),e._v(" "),n("p",[e._v("https://www.haproxy.com/support/technical-notes/an-0054-en-how-to-analyze-haproxy-logs-with-halog-tool/")]),e._v(" "),n("h3",{attrs:{id:"_2-3-utilities-调试工具"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-utilities-调试工具"}},[e._v("#")]),e._v(" 2.3 utilities 调试工具")]),e._v(" "),n("p",[e._v('Most of the time it runs as a single process, so the output of "ps aux" on a system will report only one "haproxy" process, unless a soft reload is in progress and an older process is finishing its job in parallel to the new one. It is thus always easy to trace its activity using the strace utility.')]),e._v(" "),n("h4",{attrs:{id:"_2-3-1-socat管理haproxy以及haproxy调优"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-1-socat管理haproxy以及haproxy调优"}},[e._v("#")]),e._v(" 2.3.1 socat管理haproxy以及haproxy调优")]),e._v(" "),n("p",[e._v("https://cbonte.github.io/haproxy-dconv/2.3/management.html#9.3")]),e._v(" "),n("p",[e._v("https://www.cnblogs.com/nmap/p/6498224.html")]),e._v(" "),n("h5",{attrs:{id:"unix-socket-socat"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#unix-socket-socat"}},[e._v("#")]),e._v(" Unix socket & socat")]),e._v(" "),n("blockquote",[n("p",[e._v("socat是一个多功能的网络工具，名字来由是“Socket CAT”，可以看作是netcat的N倍加强版，socat的官方网站：http://www.dest-unreach.org/socat/ 。\nsocat是一个两个独立数据通道之间的双向数据传输的继电器。\n这些数据通道包含文件、管道、设备（终端或调制解调器等）、插座（Unix，IP4，IP6 - raw，UDP，TCP）、SSL、SOCKS4客户端或代理CONNECT。\nsocat支持广播和多播、抽象Unix sockets、Linux tun/tap、GNU readline和PTY。\n它提供了分叉、记录和进程间通信的不同模式。多个选项可用于调整socat和其渠道，Socat可以作为TCP中继（一次性或守护进程），作为一个守护进程基于socksifier，\n作为一个shell Unix套接字接口，作为IP6的继电器，或面向TCP的程序重定向到一个串行线。\nsocat的主要特点就是在两个数据流之间建立通道；且支持众多协议和链接方式：ip, tcp, udp, ipv6, pipe,exec,system,open,proxy,openssl,socket等。")]),e._v(" "),n("p",[e._v("https://www.cnblogs.com/nmap/p/6498224.html")])]),e._v(" "),n("p",[e._v("使用socat可以查看和设置HAProxy状态，首先得让HAProxy产生出一个sock出来(hatop ，socat都是基于这个的，没这个什么都做不了)。\n设置配置文件开启unix socket\n在global 下面 加一行：\nstats socket /usr/local/haproxy/stats #路径和名字随意\n然后重启服务就可以了。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('\n\nglobal\n        stats socket /var/run/haproxy.sock mode 600 level admin\n        stats timeout 2m\n        \n查看有没有生成socket\nls /var/lib/haproxy/\n\n\nTo access the socket, an external utility such as "socat" is required. Socat is\na swiss-army knife to connect anything to anything. We use it to connect\nterminals to the socket, or a couple of stdin/stdout pipes to it for scripts.\nThe two main syntaxes we\'ll use are the following :\n\n    # socat /var/run/haproxy.sock stdio\n    # socat /var/run/haproxy.sock readline\n\nThe first one is used with scripts. It is possible to send the output of a\nscript to haproxy, and pass haproxy\'s output to another script. That\'s useful\nfor retrieving counters or attack traces for example.\n\nThe second one is only useful for issuing commands by hand. It has the benefit\nthat the terminal is handled by the readline library which supports line\nediting and history, which is very convenient when issuing repeated commands\n(eg: watch a counter).\n\nwhen debugging by hand, it\'s quite common to start with the\n"prompt" command :\n\n   # socat /var/run/haproxy readline\n   prompt\n   > show info\n   \n通过socat和socket通信，它是cocket cat的缩写，安装\n yum install -y socat\n利用管道查看帮助命令\necho "help" | socat stdio /var/lib/haproxy/haproxy.sock\necho "show info" | socat stdio /var/lib/haproxy/haproxy.sock\n\n通过disable或者enable可以关闭或者启动某台主机\necho "disable server http_back/linux-node2" | socat stdio /var/lib/haproxy/haproxy.sock\necho "enable server http_back/linux-node2" | socat stdio /var/lib/haproxy/haproxy.sock\n\nhaproxy调优的地方\n1、不设置进程，默认就是1，单进程\n2、网卡可能跑慢，换成万兆网卡，或者拆业务，拆成不同集群\n3、haproxy的端口可能被用光，因为linux提供端口最多65535。\n\n改local的端口范围。\ncat /proc/sys/net/ipv4/ip_local_port_range\n改tcp的tw端口的复用，启用reuse，禁用recycle，改成1　\ncat /proc/sys/net/ipv4/tcp_tw_reuse\n可以缩短tw的时间，默认是60秒。\ncat /proc/sys/net/ipv4/tcp_fin_timeout\n使用多个IP\n')])])]),n("h5",{attrs:{id:"master-cli"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#master-cli"}},[e._v("#")]),e._v(" Master CLI")]),e._v(" "),n("p",[e._v("The master CLI is a socket bound to the master process in master-worker mode. This CLI gives access to the unix socket commands in every running or leaving processes and allows a basic supervision of those processes.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("# haproxy -W -S 127.0.0.1:1234 -f test1.cfg\n# haproxy -Ws -S /tmp/master-socket,uid,1000,gid,1000,mode,600 -f test1.cfg\n# haproxy -W -S /tmp/master-socket,level,user -f test1.cfg\n\necho &#x27;show proc' | socat /var/run/haproxy-master.sock -\n\nsocat /var/run/haproxy-master.sock readline\nprompt\nmaster> @1 show info; @2 show info\nmaster> @1\n1271> show info\n[...]\n1271> show stat\n[...]\n")])])]),n("h4",{attrs:{id:"_2-3-2-tcpdump-strace"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-2-tcpdump-strace"}},[e._v("#")]),e._v(" 2.3.2 tcpdump & strace")]),e._v(" "),n("p",[e._v("https://cbonte.github.io/haproxy-dconv/2.3/management.html#12")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('tcpdump sample:\nrun tcpdump to watch for port 514, for example on the loopback interface if\n    the traffic is being sent locally : "tcpdump -As0 -ni lo port 514". If the\n    packets are seen there, it\'s the proof they\'re sent then the syslogd daemon\n    needs to be troubleshooted.\n\nstrace sample:\nrun "strace -tt -s100 -etrace=sendmsg -p <haproxy\'s pid>" \n\nWhen debugging some latency issues, it is important to use both strace and\ntcpdump on the local machine, and another tcpdump on the remote system. The\nreason for this is that there are delays everywhere in the processing chain and\nit is important to know which one is causing latency to know where to act. In\npractice, the local tcpdump will indicate when the input data come in. Strace\nwill indicate when haproxy receives these data (using recv/recvfrom). Warning,\nopenssl uses read()/write() syscalls instead of recv()/send(). Strace will also\nshow when haproxy sends the data, and tcpdump will show when the system sends\nthese data to the interface. Then the external tcpdump will show when the data\nsent are really received (since the local one only shows when the packets are\nqueued). The benefit of sniffing on the local system is that strace and tcpdump\nwill use the same reference clock. Strace should be used with "-tts200" to get\ncomplete timestamps and report large enough chunks of data to read them.\nTcpdump should be used with "-nvvttSs0" to report full packets, real sequence\nnumbers and complete timestamps.\n\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('haproxy -vv\n\nhaproxy -f /etc/haproxy.cfg \\\n           -D -p /var/run/haproxy.pid -sf $(cat /var/run/haproxy.pid)\n           \nstrace -tt -s100 -etrace=sendmsg -p <haproxy\'s pid>\n\necho "show info" | socat - /var/run/haproxy.sock | grep ^Idle\n')])])]),n("h2",{attrs:{id:"_3-configuration"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-configuration"}},[e._v("#")]),e._v(" 3. configuration")]),e._v(" "),n("p",[e._v("https://cbonte.github.io/haproxy-dconv/2.3/configuration.html")]),e._v(" "),n("h3",{attrs:{id:"安全设置"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#安全设置"}},[e._v("#")]),e._v(" 安全设置")]),e._v(" "),n("p",[e._v("涉及到linux的chroot：修改haproxy的工作目录至指定的目录并在放弃权限之前执行chroot()操作,可以提升haproxy的安全级别，不过需要注意的是要确保指定的目录为空目录且任何用户均不能有写权限")]),e._v(" "),n("blockquote",[n("p",[e._v("HAProxy is designed to run with very limited privileges. The standard way to use it is to isolate it into a chroot jail and to drop its privileges to a non-root user without any permissions inside this jail so that if any future vulnerability were to be discovered, its compromise would not affect the rest of the system.")])]),e._v(" "),n("blockquote",[n("p",[e._v("In order to perform a chroot, it first needs to be started as a root user. It is pointless to build hand-made chroots to start the process there, these ones are painful to build, are never properly maintained and always contain way more bugs than the main file-system. And in case of compromise, the intruder can use the purposely built file-system. "),n("strong",[e._v('Unfortunately many administrators confuse "start as root" and "run as root", resulting in the uid change to be done prior to starting haproxy, and reducing the effective security restrictions.')]),e._v(" ？？这段话没有搞懂")])]),e._v(" "),n("p",[e._v("https://stackoverflow.com/questions/63150374/please-help-explain-the-haproxy-statment-unfortunately-many-administrators-conf")]),e._v(" "),n("p",[e._v("但是细品下面接着的两段话")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("HAProxy will need to be started as root in order to :\n  - adjust the file descriptor limits\n  - bind to privileged port numbers\n  - bind to a specific network interface\n  - transparently listen to a foreign address\n  - isolate itself inside the chroot jail\n  - drop to another non-privileged UID\n\nHAProxy may require to be run as root in order to :\n  - bind to an interface for outgoing connections\n  - bind to privileged source ports for outgoing connections\n  - transparently bind to a foreign address for outgoing connections\n")])])]),n("p",[e._v("可以看到start as root应该就是我们在Configuration里面指定好uid比如99 nobody，然后用root用户启动sytemctl start haproxy或者")]),e._v(" "),n("p",[e._v("/usr/sbin/haproxy -D -f /etc/haproxy/haproxy.cfg，然后haproxy程序就会做下面一系列事情，比如：")]),e._v(" "),n("p",[e._v("bind to privileged port numbers 绑定低于1024的端口。。。。进一步将其放入监狱jail，即根据chroot配置调用chroot，直到drop to another non-privileged UID就是降级我们指定的99 nobody，降级的原理就是根据配置的uid，然后系统调用setuid，最后就会看到haproxy的owner就是nobody这个用户；")]),e._v(" "),n("p",[e._v("而run as root有什么用呢，首先bind to privileged source ports for outgoing connections 这个就是鸡肋，意思是当haproxy连接后台服务的时候，其作为客户端的源端口可以使用低于1024的端口，但是实际情况下，我们都不会关心一个客户端使用什么端口，我们写代码也只关心destination或者服务器的端口，至于其他两个，看起来也貌似没有用")]),e._v(" "),n("p",[e._v("至于resulting in the uid change to be done prior to starting haproxy，首先start as root前面说了是root启动，然后降级成普通用户，所以是'uid change' after starting haproxy, 而run as root，不去配置uid，则不会降级，也不会有uid change，怎么又会prior to starting haproxy？这个暂时不深究")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('A safe configuration will have :\n\n  - a chroot statement pointing to an empty location without any access\n    permissions. This can be prepared this way on the UNIX command line :\n\n      # mkdir /var/empty && chmod 0 /var/empty || echo "Failed"\n\n    and referenced like this in the HAProxy configuration\'s global section :\n\n      chroot /var/empty\n\n  - both a uid/user and gid/group statements in the global section :\n\n      user haproxy\n      group haproxy\n\n  - a stats socket whose mode, uid and gid are set to match the user and/or\n    group allowed to access the CLI so that nobody may access it :\n\n      stats socket /var/run/haproxy.stat uid hatop gid hatop mode 600\n      \n前面的配置中我们用了默认的linux nobody用户(id nobody)\nuid 99\ngid 99\n当然也可以根据这里的建议创建haproxy用户\nuseradd haproxy -r -s /sbin/nologin \ngetent passwd  haproxy\nid haproxy\n注意配置可以用uid gid也可以用user group\n\n')])])]),n("blockquote",[n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('insecure-setuid-wanted\nHAProxy doesn\'t need to call executables at run time (except when using\nexternal checks which are strongly recommended against), and is even expected\nto isolate itself into an empty chroot. As such, there basically is no valid\nreason to allow a setuid executable to be called without the user being fully\naware of the risks. In a situation where haproxy would need to call external\nchecks and/or disable chroot, exploiting a vulnerability in a library or in\nhaproxy itself could lead to the execution of an external program. On Linux\nit is possible to lock the process so that any setuid bit present on such an\nexecutable is ignored. This significantly reduces the risk of privilege\nescalation in such a situation. This is what haproxy does by default. In case\nthis causes a problem to an external check (for example one which would need\nthe "ping" command), then it is possible to disable this protection by\nexplicitly adding this directive in the global section. If enabled, it is\npossible to turn it back off by prefixing it with the "no" keyword.\n')])])]),n("p",[e._v("https://cbonte.github.io/haproxy-dconv/2.2/configuration.html#insecure-setuid-wanted")])]),e._v(" "),n("blockquote",[n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("BEFORE THE PATCH:\n=================\n\n# rpm -q haproxy\nhaproxy-1.4.22-3.el6.x86_64\n\n# service haproxy start\nStarting haproxy: [  OK  ]\n\n# ps axf -o pid,user,group,command | grep hapr\n 4661 root     root              \\_ grep hapr\n 4602 haproxy  haproxy  /usr/sbin/haproxy -D -f /etc/haproxy/haproxy.cfg -p /var/run/haproxy.pid\n# grep Group /proc/4602/status \nGroups: 0 \n\n\nAFTER THE PATCH:\n================\n\n# rpm -q haproxy\nhaproxy-1.4.24-2.el6.x86_64\n\n# service haproxy start\nStarting haproxy: [  OK  ]\n\n# ps a -o pid,user,group,command | grep haproxy\n 1196 root     root     grep hapr\n31712 haproxy  haproxy  haproxy -f /etc/haproxy/haproxy.cfg -d -V\n\n# grep Group /proc/31712/status\nGroups:\n")])])]),n("p",[e._v("https://bugzilla.redhat.com/show_bug.cgi?id=903303")])]),e._v(" "),n("blockquote",[n("p",[e._v("chroot happens after bind, you need to:\nbind to "),n("code",[e._v("/var/emtpy/var/run/haproxy.sock")])]),e._v(" "),n("p",[e._v("https://discourse.haproxy.org/t/trying-to-run-haproxy-as-non-root-not-working/3906/3")])]),e._v(" "),n("p",[e._v("http://www.dscentral.in/2012/11/04/installing-haproxy-on-pfsense/")]),e._v(" "),n("h2",{attrs:{id:"coding-style"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#coding-style"}},[e._v("#")]),e._v(" coding-style")]),e._v(" "),n("h2",{attrs:{id:"proxy-protocol"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#proxy-protocol"}},[e._v("#")]),e._v(" proxy-protocol")]),e._v(" "),n("h2",{attrs:{id:"一些问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一些问题"}},[e._v("#")]),e._v(" 一些问题")]),e._v(" "),n("p",[e._v("session问题：")]),e._v(" "),n("p",[e._v("https://blog.csdn.net/weixin_45537987/article/details/106759391")]),e._v(" "),n("p",[e._v("Gitlab behind Haproxy(SSL)")]),e._v(" "),n("p",[e._v("https://serverfault.com/questions/820114/gitlab-behind-haproxyssl")]),e._v(" "),n("h2",{attrs:{id:"国内是如何使用的"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#国内是如何使用的"}},[e._v("#")]),e._v(" 国内是如何使用的")]),e._v(" "),n("p",[e._v("https://www.cnblogs.com/hanshanxiaoheshang/p/10285962.html")]),e._v(" "),n("disqus")],1)}),[],!1,null,null,null);t.default=a.exports}}]);