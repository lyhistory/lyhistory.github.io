(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{283:function(e,t,n){"use strict";n.r(t);var s=n(0),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("圣杯与银弹 · 没用的设计模式\nhttps://draveness.me/holy-grail-design-pattern/")]),e._v(" "),n("p",[e._v('Procedural Programming, Functional Programming, OO and AO Programming, we have so many programming methodology, what we discuss here is all based on OO Programming.\nWhen we say OO design and design pattern, we must mention \'GOF book\',as introduced in wiki:\nThe name of the book ("Design Patterns: Elements of Reusable Object-Oriented Software") is too long for e-mail, so "book by the gang of four" became a shorthand name for it. After all, it isn\'t the ONLY book on patterns. That got shortened to "GOF book", which is pretty cryptic the first time you hear it.')]),e._v(" "),n("h2",{attrs:{id:"_1-principle"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-principle"}},[e._v("#")]),e._v(" 1.Principle")]),e._v(" "),n("p",[n("strong",[e._v("Single Responsibility Principle")]),e._v("\nMotivation\nIn this context a responsibility is considered to be one reason to change. This principle states that if we have 2 reasons to change for a class, we have to split the functionality in two classes. Each class will handle only one responsibility and on future if we need to make one change we are going to make it in the class which handle it. When we need to make a change in a class having more responsibilities the change might affect the other functionality of the classes.\nThe Single Responsibility Principle is a simple and intuitive principle, but in practice it is sometimes hard to get it right.\nIntent\nA class should have only one reason to change.")]),e._v(" "),n("p",[n("strong",[e._v("Open-Closed Principle")]),e._v("\nMotivation\nA clever application design and the code writing part should take care of the frequent changes that are done during the development and the maintaining phase of an application. Usually, many changes are involved when a new functionality is added to an application. Those changes in the existing code should be minimized, since it's assumed that the existing code is already unit tested and changes in already written code might affect the existing functionality in an unwanted manner.\nThe Open Close Principle states that the design and writing of the code should be done in a way that new functionality should be added with minimum changes in the existing code. The design should be done in a way to allow the adding of new functionality as new classes, keeping as much as possible existing code unchanged.\nIntent\nSoftware entities like classes, modules and functions should be open for extension but closed for modifications.")]),e._v(" "),n("p",[n("strong",[e._v("Liskov Substitution Principle")]),e._v("\nMotivation\nAll the time we design a program module and we create some class hierarchies. Then we extend some classes creating some derived classes.\nWe must make sure that the new derived classes just extend without replacing the functionality of old classes. Otherwise the new classes can produce undesired effects when they are used in existing program modules.\nLikov's Substitution Principle states that if a program module is using a Base class, then the reference to the Base class can be replaced with a Derived class without affecting the functionality of the program module.\nIntent\nDerived types must be completely substitutable for their base types.")]),e._v(" "),n("p",[n("strong",[e._v("Interface Segregation Principle")]),e._v("\nMotivation\nWhen we design an application we should take care how we are going to make abstract a module which contains several submodules. Considering the module implemented by a class, we can have an abstraction of the system done in an interface. But if we want to extend our application adding another module that contains only some of the submodules of the original system, we are forced to implement the full interface and to write some dummy methods. Such an interface is named fat interface or polluted interface. Having an interface pollution is not a good solution and might induce inappropriate behavior in the system.\nThe Interface Segregation Principle states that clients should not be forced to implement interfaces they don't use. Instead of one fat interface many small interfaces are preferred based on groups of methods, each one serving one submodule.\nIntent\nClients should not be forced to depend upon interfaces that they don't use.")]),e._v(" "),n("p",[n("strong",[e._v("Dependency Inversion Principle-IOC")]),e._v("\nMotivation\nWhen we design software applications we can consider the low level classes the classes which implement basic and primary operations(disk access, network protocols,...) and high level classes the classes which encapsulate complex logic(business flows, ...). The last ones rely on the low level classes. A natural way of implementing such structures would be to write low level classes and once we have them to write the complex high level classes. Since high level classes are defined in terms of others this seems the logical way to do it. But this is not a flexible design. What happens if we need to replace a low level class?\nLet's take the classical example of a copy module which reads characters from the keyboard and writes them to the printer device. The high level class containing the logic is the Copy class. The low level classes are KeyboardReader and PrinterWriter.\nIn a bad design the high level class uses directly and depends heavily on the low level classes. In such a case if we want to change the design to direct the output to a new FileWriter class we have to make changes in the Copy class. (Let's assume that it is a very complex class, with a lot of logic and really hard to test).\nIn order to avoid such problems we can introduce an abstraction layer between high level classes and low level classes. Since the high level modules contain the complex logic they should not depend on the low level modules so the new abstraction layer should not be created based on low level modules. Low level modules are to be created based on the abstraction layer.\nAccording to this principle the way of designing a class structure is to start from high level modules to the low level modules:\nHigh Level Classes --\x3e Abstraction Layer --\x3e Low Level Classes")]),e._v(" "),n("p",[e._v("Intent\nHigh-level modules should not depend on low-level modules. Both should depend on abstractions.\nAbstractions should not depend on details. Details should depend on abstractions.")]),e._v(" "),n("p",[e._v("<<Dependency Injection in .NET(2011)>>\n<<Manning.Dependency.Injection.In.Dot.NET.Sep.2011.ISBN.1935182501>>")]),e._v(" "),n("p",[e._v("From the book, understand more than IOC but other patterns: the Null Object pattern, Decorator pattern, Composite pattern,Adapter pattern")]),e._v(" "),n("p",[n("img",{attrs:{src:"/docs/docs_image/software/designpattern/designpattern00.png",alt:""}})]),e._v(" "),n("p",[e._v("“Programming to an interface instead of an implementation” ENABLES “Loose couple”, “loose couple” MAKES CODE “extensible”, “extensibility” MAKES IT “maintainable”")]),e._v(" "),n("p",[e._v("Benefits gained from “loose couple”")]),e._v(" "),n("p",[n("img",{attrs:{src:"/docs/docs_image/software/designpattern/designpattern01.png",alt:""}})]),e._v(" "),n("p",[e._v("As a class relinquishes control of DEPENDENCIES, it gives up more than the decision to select particular implementations. However, as developers, we gain some advantages.As developers, we gain control by removing that control from the classes that consume DEPENDENCIES. This is an application of the SINGLE RESPONSIBILITY\nPRINCIPLE: these classes should only deal with their given area of responsibility, without concerning themselves with how DEPENDENCIES are created.\nDI gives us an opportunity to manage DEPENDENCIES in a uniform way. When consumers directly create and set up instances of DEPENDENCIES, each may do so in its own way, which may be inconsistent with how other consumers do it. We have no way to centrally manage DEPENDENCIES, and no easy way to address CROSS-CUTTING CONCERNS. With DI, we gain the ability to intercept each DEPENDENCY instance and act upon it before it’s passed to the consumer. With DI, we can compose applications while intercepting dependencies and controlling their lifetimes. OBJECT COMPOSITION, INTERCEPTION, and LIFETIME MANAGEMENT are three dimensions of DI.")]),e._v(" "),n("h2",{attrs:{id:"_2-design-patterns-in-software-process"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-design-patterns-in-software-process"}},[e._v("#")]),e._v(" 2.design patterns in software process")]),e._v(" "),n("p",[e._v("URS(functional requirements) --\x3e Requirements Modeling --\x3e Use Case Model---\x3eAnalysis Modeling--\x3eAnalysis Model---\x3eDesign Modeling--\x3eDesign Model")]),e._v(" "),n("p",[e._v("Software Architecture\nFunctional requirements are structured as use cases.Dependencies among functional requirements are identified as relationships between use cases.The operation flows of each use case is described.\nAnalysis objects are identified along with their state(attributes) and responsibilities(operations) without considerations for implementation.\nDesign strategies are devised for the operating environment to fulfill the quality requirements.\nAnalysis objects are adapted according to the design strategies to become design objects with full class details.")]),e._v(" "),n("p",[e._v("Incremental and Iterative Model\nAgile Model")]),e._v(" "),n("p",[e._v("Design problems surface during design activities, they may be solved by applying design patterns,\nIn OOAD, design patterns are applicable when:\n1.Devising/Refining the design strategies.\n2.Transitioning from analysis model to design model.\n3.Iterating within design Model.")]),e._v(" "),n("h2",{attrs:{id:"_3-appreciate-the-intent-of-design-patterns"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-appreciate-the-intent-of-design-patterns"}},[e._v("#")]),e._v(" 3.Appreciate the intent of design patterns")]),e._v(" "),n("p",[e._v("Design patterns capture the intent behind a design by identifying objects and classes, their collaborations, and the distribution of their roles and responsibilities.\nImportance:\nPatterns are a rational reconstruction of existing design practices\nPatterns identify key assumptions that govern the design decisions.\nValue of a pattern is determined by the quality of exposition.")]),e._v(" "),n("h3",{attrs:{id:"_3-1-behavior"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-behavior"}},[e._v("#")]),e._v(" 3.1 Behavior")]),e._v(" "),n("p",[n("strong",[e._v("Template pattern:")]),e._v("\nIn Template pattern, an abstract class exposes defined way(s)/template(s) to execute its methods. Its subclasses can override the method implementation as per need but the invocation is to be in the same way as defined by an abstract class. This pattern comes under behavior pattern category.\nhttps://baijiahao.baidu.com/s?id=1619116206359982963&wfr=spider&for=pc\nhttps://www.tutorialspoint.com/design_pattern/template_pattern.htm")]),e._v(" "),n("p",[n("img",{attrs:{src:"/docs/docs_image/software/designpattern/designpattern02.png",alt:""}})]),e._v(" "),n("p",[n("strong",[e._v("Observation pattern")]),e._v("\nproblem:\nwhen a change in the object requires change in the others, and you don't know how many of them need changes.\nIntent:\nDefine a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.")]),e._v(" "),n("p",[e._v("ApplicationContext PublishEvent EventListener\nhttps://springframework.guru/gang-of-four-design-patterns/observer-pattern/\npublisher(subject), subscriber(observer)")]),e._v(" "),n("p",[n("strong",[e._v("Strategy :")]),e._v(" Client context Strategy ConcreteStrategy, algorithm related,\nproblem: context has to handle different occasions\nIntent: defines an interface for a family of algorithms.\n1.improve maintainability & extensibility by capturing algorithms in classes.\n2.improve extensibility by abstracting the algorithm classes - polymorphism - treating all the algorithms uniformly.")]),e._v(" "),n("p",[e._v("**Iterator: ** Client Aggregate ConcreteAggregate Iterator ConcreteIterator\nproblem: traverse aggregate in a structured manner, robust to modify traverse algorithm in future.\nIntent: defines an interface for accessing and traversing aggregate without exposing the latter's internal representation.\nImplementation issues and choices:\nThe iteration through the selected aggregate items can be controlled externally, or internally from within the iterator,modify on aggregate items during iteration.\nit there are multi iterator in aggregator, aggregator")]),e._v(" "),n("p",[n("strong",[e._v("Memento:")]),e._v(" Caretaker Originator Memento\nproblem:capture snapshots of required subset of state, not burden originator  with undo and possibly redo functions.\nIntent:\nMemento stores internal state of originator and allows access only by originator,\nOriginator creates and restores from Memento,\nCareTaker safe keeps memento and does not access the content of Memento.\nImplementation issues and choices:\nProgramming languages support is required to support the wide and narrow interfaces of memento: Java:inner class C#:nested class C++:friend class\nStoring incremental changes in memento is feasible if mementos are restored in a predictable sequence")]),e._v(" "),n("p",[n("strong",[e._v("Command:")]),e._v(" Client ConcreteCommand Invoker Receiver\n"),n("strong",[e._v("Visitor:")]),e._v(" double dispatch vs visitor pattern\nhttp://www.cnblogs.com/significantfrank/archive/2012/10/31/4875836.html")]),e._v(" "),n("h3",{attrs:{id:"_3-2-structural"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-structural"}},[e._v("#")]),e._v(" 3.2 Structural")]),e._v(" "),n("p",[n("strong",[e._v("Bridge:")]),e._v(" Client Abstraction RefinedAbstraction Implementor ConcreteImplementor\nproblem:\navoid permanent binding between an abstraction and an implementation, vary or replace the implementation without changing the client code.\nIntent:\nseparate a class's interface from its implementation / decouple abstraction from implementation so that the two can vary independently.\nplace abstraction and implementation into separate hierarchies.")]),e._v(" "),n("p",[e._v("**Composite:**Client Component Composite(keep components collection, addComponent()/removeComponent())\nproblem:\nrepresent complex objects that comprises other simple objects,\nclients should be able to treat complex objects in the same way as other simple objects.\nIntent:\ncompose object into tree structures to represent part-whole hierarchies.\ncomposite lets clients treat individual objects and compositions of objects uniformly.")]),e._v(" "),n("p",[n("strong",[e._v("Decorator:")]),e._v("\nproblem:\nadd responsibility(states or operations, can be withdrawn) to individual objects dynamically and transparently when extension by sub-classing is not possible.\nIntent:\nprovide a flexible alternative to sub-classing for extending functionality, attach additional responsibilities to an object dynamically.\nPlease be aware of operation sequence in ConcreteDecorator(decide should you call base.Operation() before or after AddedBehavior()), that will make great difference when drawing sequence diagram.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// Abstract decorator class - note that it extends Coffee abstract class\npublic abstract class CoffeeDecorator extends Coffee {\nprotected final Coffee decoratedCoffee;\npublic CoffeeDecorator(Coffee c) {\nthis.decoratedCoffee = c;\n}\npublic double getCost() { // Implementing methods of the abstract class\nreturn decoratedCoffee.getCost();\n}\npublic String getIngredients() {\nreturn decoratedCoffee.getIngredients();\n}\n}\n// Decorator WithMilk mixes milk into coffee.\n// Note it extends CoffeeDecorator.\nclass WithMilk extends CoffeeDecorator {\npublic WithMilk(Coffee c) {\nsuper(c);\n}\npublic double getCost() { // Overriding methods defined in the abstract superclass\nreturn super.getCost() + 0.5;\n}\npublic String getIngredients() {\nreturn super.getIngredients() + ", Milk";\n}\n}\n// Decorator WithSprinkles mixes sprinkles onto coffee.\n// Note it extends CoffeeDecorator.\nclass WithSprinkles extends CoffeeDecorator {\npublic WithSprinkles(Coffee c) {\nsuper(c);\n}\npublic double getCost() {\nreturn super.getCost() + 0.2;\n}\npublic String getIngredients() {\nreturn super.getIngredients() + ", Sprinkles";\n}\n}\npublic class Main {\npublic static void printInfo(Coffee c) {\nSystem.out.println("Cost: " + c.getCost() + "; Ingredients: " + c.getIngredients());\n}\npublic static void main(String[] args) {\nCoffee c = new SimpleCoffee();\nprintInfo(c);\nc = new WithMilk(c);\nprintInfo(c);\nc = new WithSprinkles(c);\nprintInfo(c);\n}\n}\nCost: 1.0; Ingredients: Coffee\nCost: 1.5; Ingredients: Coffee, Milk\nCost: 1.7; Ingredients: Coffee, Milk, Sprinkles\n\n')])])]),n("h3",{attrs:{id:"_3-3-creation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-creation"}},[e._v("#")]),e._v(" 3.3 creation")]),e._v(" "),n("p",[n("strong",[e._v("Factory Method:")]),e._v(" product concreteProduct creator concreteCreator,\nproblem: polymorphism applies only to the use of objects, not to their creation. Object creation could become very cumbersome especially if the num of subclasses increases.\nIntent:")]),e._v(" "),n("ol",[n("li",[e._v("client cannot anticipate the class of objects it must create.")]),e._v(" "),n("li",[e._v("Localise : Hide from the client the knowledge of where and how to create whichever subclass you desire.\nfuthermore: Factory Method Pattern VS Abstract Factory Pattern\nFactory Method intent to insulate the creation of object from their usage. Parameterizing the desired concrete subclasses.")])]),e._v(" "),n("p",[n("strong",[e._v("Abstract Factory")]),e._v(" provide a way to encapsulate a group of factories without specifying their concrete classes.\nImplementation issues and choices: How to create factories ? normally we would put creation of factories in Client using simple factory method, more elegant way is using reflection.")]),e._v(" "),n("p",[n("strong",[e._v("Builder:")]),e._v(" Client Director ConcreteBuilder\nproblem: creating complex products\nIntent:\nSeparate the construction of a complex object from its representation, so that the same construction process can create different representations.")]),e._v(" "),n("p",[n("strong",[e._v("Singleton:")]),e._v(" Clients access a Singleton instance solely through Singleton's getInstance() operation\nproblem:\nwhen multiple copies are floated in the system, it is difficult to ensure control over the updates.\nIntent:\nEnsuring controlled updates of data\nImplementation issues and choices:use a registry of singletons, the registry maps between key and singleton, when getInstance needs a singleton, it consults the registry, asking for the singleton by name, the registry looks up the corresponding singleton.")]),e._v(" "),n("p",[e._v("Static vs singleton\nAbout Singleton:\n"),n("img",{attrs:{src:"/docs/docs_image/software/designpattern/designpattern03.png",alt:""}}),e._v("\nAbout double-checked lock\nhttps://en.wikipedia.org/wiki/Double-checked_locking")]),e._v(" "),n("p",[e._v("Refer to “Static and thread safe”=>“Class-load time”, use private static instance = new Object(), initial at class-load time, not run time to avoid multthread issue.")]),e._v(" "),n("p",[e._v("Difference between static class and singleton pattern? https://stackoverflow.com/questions/519520/difference-between-static-class-and-singleton-pattern?page=2&tab=votes#tab-top")]),e._v(" "),n("p",[e._v("Why singleton is bad?\nhttps://medium.com/@sinethneranjana/5-ways-to-write-a-singleton-and-why-you-shouldnt-1cf078562376")]),e._v(" "),n("h2",{attrs:{id:"_4-在应用层思考设计模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-在应用层思考设计模式"}},[e._v("#")]),e._v(" 4. 在应用层思考设计模式")]),e._v(" "),n("p",[e._v("design pattern status machine")]),e._v(" "),n("p",[e._v("Recommended practice is to code frontends in a state-machine style that will accept any message type at any time that it could make sense, rather than wiring in assumptions about the exact sequence of messages. https://www.postgresql.org/docs/11/static/protocol-flow.html")]),e._v(" "),n("p",[e._v("Producer-consumer pattern\nhttps://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem\nPub-sub pattern\nHtml5 - server sent event")]),e._v(" "),n("p",[e._v("address resolver / service locator")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("ref:")]),e._v(" "),n("p",[n("a",{attrs:{href:"http://www.php5dp.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("PHP design pattern"),n("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=a.exports}}]);