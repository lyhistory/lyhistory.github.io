(window.webpackJsonp=window.webpackJsonp||[]).push([[157],{578:function(e,t,o){"use strict";o.r(t);var a=o(65),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("p",[o("a",{attrs:{href:"https://kafka.apache.org/23/javadoc/index.html?org/apache/kafka/clients/consumer/KafkaConsumer.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Apache KafkaConsumer"),o("OutboundLink")],1)]),e._v(" "),o("h2",{attrs:{id:"_1-关键api及源码解读"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-关键api及源码解读"}},[e._v("#")]),e._v(" 1.关键API及源码解读")]),e._v(" "),o("p",[e._v("keyword: heartbeat，rebalance")]),e._v(" "),o("h3",{attrs:{id:"offsets"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#offsets"}},[e._v("#")]),e._v(" offsets")]),e._v(" "),o("p",[o("img",{attrs:{src:"/docs/docs_image/software/buildingblock/kafka/kafka_offsets-1.png",alt:""}})]),e._v(" "),o("p",[e._v('图中last committed log是指consumer消费完之后，自动提交的offset（"then each '),o("strong",[e._v("later rebalance")]),e._v(' will reset the position to the last committed offset"）')]),e._v(" "),o("p",[e._v("high waterMark和log end offset是上游producer发布的消息offset，其中high watermark是代表全部replicate结束+1，所以consumer最多能读取到high watermark位置-1，")]),e._v(" "),o("ul",[o("li",[o("p",[e._v("HWM high watermark\nthe offset of the last successfully replicated message plus one)")])]),e._v(" "),o("li",[o("p",[e._v("LEO Log End Offset\n当前日志文件中下一条待写入消息的offset。分区ISR集合中的每个副本都会维护自身的LEO，而ISR集合中最小的LEO即为分区的HWM。\n这个offset未必在硬盘中，可能目前只在内存中还没有被flush到硬盘。")])]),e._v(" "),o("li",[o("p",[e._v("LWM Low Watermark的\n代表AR集合(分区中的所有副本统称为 Assigned Replicas)中最小的logStartOffset值。\n一般情况下，日志文件的起始偏移量 logStartOffset 等于第一个日志分段的 baseOffset，但这并不是绝对的，旧日志的清理和消息删除都有可能促使LW的增长。")])]),e._v(" "),o("li",[o("p",[e._v("LSO Last Stable Offset，\n它与kafka 事务Transactional produer有关。对于未完成的事务而言，LSO的值等于事务中的第一条消息所在的位置（firstUnstableOffset）；对于已经完成的事务而言，它的值等同于HWM相同。")]),e._v(" "),o("p",[e._v("Kafka的一个消费端的参数——isolation.level，这个参数用来配置消费者的事务隔离级别。字符串类型，有效值为“read_uncommitted”和 “read_committed”，表示消费者所消费到的位置，如果设置为“read_committed”，那么消费者就会忽略事务未提交的消息，即只能消费到 LSO(LastStableOffset)的位置，默认情况下为 “read_uncommitted”，即可以消费到 HWM(High Watermark)处的位置。注意：follower副本的事务隔离级别也为“read_uncommitted”，并且不可修改。")]),e._v(" "),o("p",[e._v("这个LSO还会影响Kafka消费滞后量（也就是Kafka Lag，很多时候也会被称之为消息堆积量）的计算：")]),e._v(" "),o("p",[e._v("a) 如果没有事务 Lag=HWM – ConsumerOffset:\n"),o("img",{attrs:{src:"/docs/docs_image/software/buildingblock/kafka/kafka_offsets-2.png",alt:""}})]),e._v(" "),o("p",[e._v("b) 如果为消息引入了事务:")]),e._v(" "),o("ul",[o("li",[e._v("如果消费者客户端的 isolation.level 参数配置为“read_uncommitted”(默认)，那么 Lag的计算方式不受影响 Lag=HWM – ConsumerOffset")]),e._v(" "),o("li",[e._v("如果这个参数配置为“read_committed”，那么 Lag = LSO – ConsumerOffset :\ni) 对未完成的事务而言，LSO 的值等于事务中第一条消息的位置 firstUnstableOffset\n"),o("img",{attrs:{src:"/docs/docs_image/software/buildingblock/kafka/kafka_offsets-3.png",alt:""}}),e._v("\nii) 对已完成的事务而言，它的值同 HWM 相同\n"),o("img",{attrs:{src:"/docs/docs_image/software/buildingblock/kafka/kafka_offsets-4.png",alt:""}})])])])]),e._v(" "),o("p",[e._v("查看：")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("./kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list xxxx --time -1 --topic xxx\n")])])]),o("p",[o("strong",[e._v("why offsets increment by 2 instead of 1?")]),e._v("\n对于 Transactional producer来说，除了写入msg之外，还会写入 abort/commit marker\n[Finally writes the COMMITTED (or ABORTED) message to transaction log](/software/buildingblock/kafka_producer.md#### Fence机制实例)\n大家的吐槽：\n"),o("a",{attrs:{href:"https://github.com/Parsely/pykafka/issues/494",target:"_blank",rel:"noopener noreferrer"}},[e._v("For this reason, I realize that latest_available_offset is a misleading name. The function should probably return an offset one less than what it currently returns."),o("OutboundLink")],1),e._v(" "),o("a",{attrs:{href:"https://stackoverflow.com/questions/54636524/kafka-streams-does-not-increment-offset-by-1-when-producing-to-topic",target:"_blank",rel:"noopener noreferrer"}},[e._v('If you use transactions, each commit (or abort) of a transaction writes a commit (or abort) marker into the topic -- those transactional markers also "consume" one offset'),o("OutboundLink")],1),e._v(" "),o("a",{attrs:{href:"https://groups.google.com/g/confluent-platform/c/IQKd3BKgvYw",target:"_blank",rel:"noopener noreferrer"}},[e._v("Each time you commit or abort a transaction, a commit/abort marker is written into the corresponding partitions and requires one offset in the log."),o("OutboundLink")],1)]),e._v(" "),o("h3",{attrs:{id:"consumer-groups"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#consumer-groups"}},[e._v("#")]),e._v(" Consumer groups")]),e._v(" "),o("h4",{attrs:{id:"选择模式"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#选择模式"}},[e._v("#")]),e._v(" 选择模式：")]),e._v(" "),o("ol",[o("li",[o("p",[e._v("Having consumers as part of the same consumer group means providing the“competing consumers” pattern with whom the messages from topic partitions are spread across the members of the group.")])]),e._v(" "),o("li",[o("p",[e._v("Having consumers as part of different consumer groups means providing the “publish/subscribe” pattern where the messages from topic partitions are sent to all the consumers across the different groups.")])])]),e._v(" "),o("ul",[o("li",[o("a",{attrs:{href:"https://dzone.com/articles/dont-use-apache-kafka-consumer-groups-the-wrong-wa",target:"_blank",rel:"noopener noreferrer"}},[e._v("Don't Use Apache Kafka Consumer Groups the Wrong Way!"),o("OutboundLink")],1)])]),e._v(" "),o("h4",{attrs:{id:"线程安全"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#线程安全"}},[e._v("#")]),e._v(" 线程安全：")]),e._v(" "),o("p",[e._v("You can’t have multiple consumers that belong to the same group in one thread and you can’t have multiple threads safely use the same consumer. One consumer per thread is the rule. To run multiple consumers in the same group in one application, you will need to run each in its own thread. It is useful to wrap the consumer logic in its own object and then use Java’s ExecutorService to start multiple threads each with its own consumer:")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('public class ConsumerLoop implements Runnable {\n  private final KafkaConsumer<String, String> consumer;\n  private final List<String> topics;\n  private final int id;\n\n  public ConsumerLoop(int id,\n                      String groupId, \n                      List<String> topics) {\n    this.id = id;\n    this.topics = topics;\n    Properties props = new Properties();\n    props.put(“group.id”, groupId);\n    props.put(“key.deserializer”, StringDeserializer.class.getName());\n    props.put(“value.deserializer”, StringDeserializer.class.getName());\n    this.consumer = new KafkaConsumer<>(props);\n  }\n  \n  @Override\n  public void run() {\n    try {\n      consumer.subscribe(topics);\n\n      while (true) {\n        ConsumerRecords<String, String> records = consumer.poll(Long.MAX_VALUE);\n        for (ConsumerRecord<String, String> record : records) {\n          Map<String, Object> data = new HashMap<>();\n          data.put("partition", record.partition());\n          data.put("offset", record.offset());\n          data.put("value", record.value());\n          System.out.println(this.id + ": " + data);\n        }\n      }\n    } catch (WakeupException e) {\n      // ignore for shutdown \n    } finally {\n      consumer.close();\n    }\n  }\n\n  public void shutdown() {\n    consumer.wakeup();\n  }\n}\n\npublic static void main(String[] args) {  \n  int numConsumers = 3;\n  String groupId = "consumer-tutorial-group"\n  List<String> topics = Arrays.asList("consumer-tutorial");\n  ExecutorService executor = Executors.newFixedThreadPool(numConsumers);\n\n  final List<ConsumerLoop> consumers = new ArrayList<>();\n  for (int i = 0; i < numConsumers; i++) {\n    ConsumerLoop consumer = new ConsumerLoop(i, topics);\n    consumers.add(consumer);\n    executor.submit(consumer);\n  }\n\n  Runtime.getRuntime().addShutdownHook(new Thread() {\n    @Override\n    public void run() {\n      for (ConsumerLoop consumer : consumers) {\n        consumer.shutdown();\n      }\n    }\n  });\n}\n-- https://www.confluent.io/blog/tutorial-getting-started-with-the-new-apache-kafka-0-9-consumer-client/\n')])])]),o("h4",{attrs:{id:"consumer-groupcoordinator"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#consumer-groupcoordinator"}},[e._v("#")]),e._v(" Consumer GroupCoordinator")]),e._v(" "),o("blockquote",[o("p",[e._v("The way consumers maintain membership in a consumer group and ownership of the partitions assigned to them is by sending "),o("em",[e._v("heartbeats")]),e._v(" to a Kafka broker designated as the "),o("em",[e._v("group coordinator")]),e._v(" (this broker can be different for different consumer groups). As long as the consumer is sending heartbeats at regular intervals, it is assumed to be alive, well, and processing messages from its partitions. "),o("s",[e._v("Heartbeats are sent when the consumer polls (i.e., retrieves records) and when it commits records it has consumed.")]),e._v("\nhttps://www.oreilly.com/library/view/kafka-the-definitive/9781491936153/ch04.html")])]),e._v(" "),o("p",[e._v("确定一个 Consumer Group 的 GroupCoordinator 的位置：")]),e._v(" "),o("ol",[o("li",[e._v("abs (GroupId.hashCode) % NumPartition，NumPartition 就是__consumer_offsets 的分区数")]),e._v(" "),o("li",[e._v("计算结果表示了__consumer_offsets 的一个 partition比如"),o("code",[e._v("__consumer_offsets-10")])]),e._v(" "),o("li",[e._v("找到该"),o("code",[e._v("__consumer_offsets-10")]),e._v(" 的 leader 所在的 broker如broker id=3，即该consumer group的 GroupCoordinator，")]),e._v(" "),o("li",[e._v("当该consumer group的GroupCoordinator挂掉时，也就是这个broker挂掉后，其他borkers（保存有"),o("code",[e._v("__consumer_offsets-10")]),e._v("的replica的节点）会选一个broker如broker id=1作为新的"),o("code",[e._v("__consumer_offsets-10")]),e._v("的leader，然后该broker会load 本机保存的"),o("code",[e._v("__consumer_offsets-10")]),e._v("replica到内存中，完成后，Client端就会discover该broker作为新的GroupCoordinator")]),e._v(" "),o("li",[e._v("当broker id=3恢复正常后，会抢回broker id=1之前接管的"),o("code",[e._v("__consumer_offsets-10")]),e._v("，重新作为该topic的leader，然后client端就重新discover broker id=3作为group coordinator，这种抢回的方式可以保证kafka节点任务均衡（注意，broker id=3恢复之后，通过kafka-topics.sh --list 查看，"),o("code",[e._v("__consumer_offsets-10")]),e._v("的leader仍然会是broker id 1，需要等到再接收一条新的kafka消息后，leader才会切换成broker id 3，外部topic也是如此，"),o("code",[e._v("__transaction_state")]),e._v("也是类似，可能是生产一条消息时更新）")])]),e._v(" "),o("h3",{attrs:{id:"关键api"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#关键api"}},[e._v("#")]),e._v(" 关键API")]),e._v(" "),o("h4",{attrs:{id:"poll"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#poll"}},[e._v("#")]),e._v(" POLL")]),e._v(" "),o("p",[o("a",{attrs:{href:"https://kafka.apache.org/10/javadoc/org/apache/kafka/clients/consumer/KafkaConsumer.html#poll-long-",target:"_blank",rel:"noopener noreferrer"}},[e._v("public ConsumerRecords<K,V> poll(long timeoutMs)"),o("OutboundLink")],1)]),e._v(" "),o("p",[e._v("The poll API returns fetched records based on the current position.")]),e._v(" "),o("blockquote",[o("p",[e._v("poll的行为：")])]),e._v(" "),o("p",[o("strong",[e._v("On each poll, consumer will try to use the last consumed offset as the starting offset and fetch sequentially")]),e._v(". The last consumed offset can be manually set through "),o("a",{attrs:{href:"https://kafka.apache.org/10/javadoc/org/apache/kafka/clients/consumer/KafkaConsumer.html#seek-org.apache.kafka.common.TopicPartition-long-",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("seek(TopicPartition, long)")]),o("OutboundLink")],1),e._v(" or automatically set as the last committed offset for the subscribed list of partitions 即如果不显示调用 seek来设置其位置，将会自动使用interal offset来定位其最后一次消费的位置。")]),e._v(" "),o("blockquote",[o("p",[e._v("更完整的：")])]),e._v(" "),o("p",[e._v("When the group is "),o("strong",[e._v("first created")]),e._v(", the position will be set according to the reset policy (which is typically either set to the earliest or latest offset for each partition defined by the auto.offset.reset). Once the consumer begins committing offsets, then each "),o("strong",[e._v("later rebalance")]),e._v(" will reset the position to the last committed offset. The parameter passed to poll controls the maximum amount of time that the consumer will block while it awaits records at the current position. The consumer returns immediately as soon as any records are available, but it will wait for the full timeout specified before returning if nothing is available.")]),e._v(" "),o("blockquote",[o("p",[e._v("具体的：")])]),e._v(" "),o("p",[o("em",[e._v("第一次（触发reblance）poll的行为：")])]),e._v(" "),o("p",[e._v("The poll loop does a lot more than just get data. The first time you call poll() with a new consumer, it is responsible for finding the GroupCoordinator, joining the consumer group, and receiving a partition assignment.[注意：只是subscribe topic并不能立即引发rebalance，可以在subscribe之后第一次poll，从而立即引发rebalance] If a rebalance is triggered, it will be handled inside the poll loop as well. "),o("s",[e._v("And of course the heartbeats that keep consumers alive are sent from within the poll loop. For this reason, we try to make sure that whatever processing we do between iterations is fast and efficient.")]),e._v("\nKIP-62, decouples heartbeats from calls to poll() via a background heartbeat thread, allowing for a longer processing time (ie, time between two consecutive poll()) than heartbeat interval.")]),e._v(" "),o("p",[o("em",[e._v("第二次之后poll的行为：")])]),e._v(" "),o("p",[e._v("从上一次的fetch positions继续往下拉取")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('private ConsumerRecords<K, V> poll(final Timer timer, final boolean includeMetadataInTimeout) {\n    acquireAndEnsureOpen();\n    try {\n        if (this.subscriptions.hasNoSubscriptionOrUserAssignment()) {\n            throw new IllegalStateException("Consumer is not subscribed to any topics or assigned any partitions");\n        }\n\n        do {\n            client.maybeTriggerWakeup();\n\n            if (includeMetadataInTimeout) {\n                if (!updateAssignmentMetadataIfNeeded(timer)) {\n                    return ConsumerRecords.empty();\n                }\n            } else {\n                while (!updateAssignmentMetadataIfNeeded(time.timer(Long.MAX_VALUE))) {\n                    log.warn("Still waiting for metadata");\n                }\n            }\n\n            final Map<TopicPartition, List<ConsumerRecord<K, V>>> records = pollForFetches(timer);\n            if (!records.isEmpty()) {\n                if (fetcher.sendFetches() > 0 || client.hasPendingRequests()) {\n                    client.pollNoWakeup();\n                }\n\n                return this.interceptors.onConsume(new ConsumerRecords<>(records));\n            }\n        } while (timer.notExpired());\n\n        return ConsumerRecords.empty();\n    } finally {\n        release();\n    }\n}\n\nboolean updateAssignmentMetadataIfNeeded(final Timer timer) {\n    if (coordinator != null && !coordinator.poll(timer)) {\n        return false;\n    }\n\n    return updateFetchPositions(timer);\n}\n\n1.Polling coordinator for updates — ensure we’re up-to-date with our group’s coordinator.\n2.Updating fetch positions — ensure every partition assigned to this consumer has a fetch position. If it is missing then consumer uses auto.offset.reset value to set it (set it to earliest, latest or throw exception).\n\n')])])]),o("p",[e._v("Kafka maintains a numerical offset for each record in a partition. This offset acts as a unique identifier of a record within that partition, and also denotes the position of the consumer in the partition. For example, a consumer which is at position 5 has consumed records with offsets 0 through 4 and will next receive the record with offset 5. There are actually two notions of position relevant to the user of the consumer:")]),e._v(" "),o("ul",[o("li",[o("p",[e._v("The position of the consumer gives "),o("strong",[e._v("the offset of the next record")]),e._v(" that will be given out. It will be one larger than the highest offset the consumer has seen in that partition. It automatically advances every time the consumer receives messages in a call to poll(Duration).\nThe position of the consumer == consumed position == current position")])]),e._v(" "),o("li",[o("p",[e._v("The committed position is the last offset that has been stored securely. Should the process fail and restart, this is the offset that the consumer will recover to. The consumer can either automatically commit offsets periodically; or it can choose to control this committed position manually by calling one of the commit APIs (e.g. commitSync and commitAsync).\nThe committed position == last committed offset")])])]),e._v(" "),o("p",[e._v("This distinction gives the consumer control over when a record is considered consumed.")]),e._v(" "),o("h4",{attrs:{id:"endoffsets"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#endoffsets"}},[e._v("#")]),e._v(" endoffsets")]),e._v(" "),o("ul",[o("li",[e._v("Get the end offsets for the given partitions. In the default {@code read_uncommitted} isolation level, the end\n"),o("ul",[o("li",[e._v("offset is the high watermark (that is, the offset of the last successfully replicated message plus one). For")]),e._v(" "),o("li",[e._v("{@code read_committed} consumers, the end offset is the last stable offset (LSO), which is the minimum of")]),e._v(" "),o("li",[e._v("the high watermark and the smallest offset of any open transaction. Finally, if the partition has never been")]),e._v(" "),o("li",[e._v("written to, the end offset is 0.")])])])]),e._v(" "),o("p",[o("strong",[e._v("How to get the msg of lastoffset?")])]),e._v(" "),o("p",[e._v("Solution: seek(endOffsets()-n) then poll, 对于普通的消息n=1，但是涉及到事务 transactional msg n=2")]),e._v(" "),o("h4",{attrs:{id:"consumerrebalancelistener"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#consumerrebalancelistener"}},[e._v("#")]),e._v(" ConsumerRebalanceListener")]),e._v(" "),o("p",[e._v("onPartitionsRevoked && onPartitionsAssigned")]),e._v(" "),o("blockquote",[o("p",[e._v("It is guaranteed that all the processes in a consumer group will execute their "),o("a",{attrs:{href:"https://kafka.apache.org/10/javadoc/org/apache/kafka/clients/consumer/ConsumerRebalanceListener.html#onPartitionsRevoked-java.util.Collection-",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("onPartitionsRevoked(Collection)")]),o("OutboundLink")],1),e._v(" callback before any instance executes its "),o("a",{attrs:{href:"https://kafka.apache.org/10/javadoc/org/apache/kafka/clients/consumer/ConsumerRebalanceListener.html#onPartitionsAssigned-java.util.Collection-",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("onPartitionsAssigned(Collection)")]),o("OutboundLink")],1),e._v(" callback.")])]),e._v(" "),o("p",[o("strong",[e._v("<=kafka2.3 Stop the World:")])]),e._v(" "),o("p",[e._v("发生rebalance时，kafka会保证所有之前的consumer无法继续消费消息（连heartbeat都停止了，提示消息 Attempt to heartbeat failed since group is rebalancing），然后会先通过 onPartitionsRevoked 回调所有的consumer，待所有consumer的onPartitionsRevoked完成之后，才会继续回调onPartitionsAssigned（笔者测试到一种情况，就是consumergroup有服务A和B，A因为网络问题，导致kafka集群决定将所有partition分配给B，所以kafka集群发送revoke给A和B，因为A有网络问题，B就没有等待A完成revoke，直接启动了，而过了两分钟，A才收到kafka集群的消息，后面exactly once笔者给出了场景图示）")]),e._v(" "),o("p",[o("strong",[e._v(">=kafka2.4 Incremental rebalance")])]),e._v(" "),o("h2",{attrs:{id:"_2-exactly-once-场景分析"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-exactly-once-场景分析"}},[e._v("#")]),e._v(" 2. Exactly-Once 场景分析")]),e._v(" "),o("p",[o("strong",[e._v("理解角度：")])]),e._v(" "),o("ul",[o("li",[o("p",[e._v("kafka本身的保证")]),e._v(" "),o("ul",[o("li",[e._v("nothing to guarantee")]),e._v(" "),o("li",[e._v("at-least-once Messages are never lost but may be redelivered.")]),e._v(" "),o("li",[e._v("at-most-once Messages may be lost but are never redelivered.")]),e._v(" "),o("li",[e._v("exactly-once This is what people actually want, each message is delivered once and only once.")])])]),e._v(" "),o("li",[o("p",[e._v("基于kafka的用户代码的保证\n业务处理逻辑和offset维护逻辑")])])]),e._v(" "),o("p",[o("strong",[e._v("具体场景：")])]),e._v(" "),o("p",[e._v("上游(consume topic 1-transform-produce to topic 2)->下游(consume topic 2....)")]),e._v(" "),o("p",[o("strong",[e._v("目标：")])]),e._v(" "),o("p",[e._v("对上游和下游都实现 atomic-read-process-write")]),e._v(" "),o("h3",{attrs:{id:"_2-1-上游-consume-topic-1-依赖consumer-internal-offset"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-上游-consume-topic-1-依赖consumer-internal-offset"}},[e._v("#")]),e._v(" 2.1 上游(consume topic 1) -依赖consumer internal offset")]),e._v(" "),o("p",[e._v("先来看比较简单的场景就是只有 consumer topic，不通过 seek来设置位置直接poll，自动使用interal offset来定位其最后一次消费的位置，注意下面的两个使用方法 at-least-once 至少一次当然可能会重复消费，"),o("strong",[e._v("但是也可能丢失信息")])]),e._v(" "),o("h4",{attrs:{id:"_2-1-1-自动提交offset-at-least-once"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-1-自动提交offset-at-least-once"}},[e._v("#")]),e._v(" 2.1.1 自动提交offset，at-least-once")]),e._v(" "),o("p",[e._v("Setting "),o("code",[e._v("enable.auto.commit")]),e._v(" "),o("strong",[e._v("means that offsets are committed automatically with a frequency controlled by")]),e._v(" the config "),o("code",[e._v("auto.commit.interval.ms")]),e._v(".")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('  Properties props = new Properties();\n     props.put("bootstrap.servers", "localhost:9092");\n     props.put("group.id", "test");\n     props.put("enable.auto.commit", "true");\n     props.put("auto.commit.interval.ms", "1000");\n     props.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");\n     props.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");\n     KafkaConsumer<String, String> consumer = new KafkaConsumer<>(props);\n     consumer.subscribe(Arrays.asList("foo", "bar"));\n     while (true) {\n         ConsumerRecords<String, String> records = consumer.poll(100);\n         for (ConsumerRecord<String, String> record : records)\n             System.out.printf("offset = %d, key = %s, value = %s%n", record.offset(), record.key(), record.value());\n     }\n')])])]),o("p",[e._v("When a partition gets reassigned to another consumer in the group, the initial position is set to the last committed offset. If the consumer in the example above suddenly crashed, then the group member taking over the partition would begin consumption from offset 1. In that case, it would have to reprocess the messages up to the crashed consumer’s position of 6.")]),e._v(" "),o("p",[e._v("The diagram also shows two other significant positions in the log. The log end offset is the offset of the last message written to the log. The high watermark is the offset of the last message that was successfully copied to all of the log’s replicas. From the perspective of the consumer, the main thing to know is that you can only read up to the high watermark. This prevents the consumer from reading unreplicated data which could later be lost.")]),e._v(" "),o("h4",{attrs:{id:"_2-1-2-手动提交offset-at-least-once"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-2-手动提交offset-at-least-once"}},[e._v("#")]),e._v(" 2.1.2 手动提交offset，at-least-once")]),e._v(" "),o("p",[e._v("Instead of relying on the consumer to periodically commit consumed  offsets, users can also control when records should be considered as consumed and hence commit their offsets. This is useful when the consumption of the messages is coupled with some processing logic and hence a message should not be considered as consumed until it is completed processing.")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v(' Properties props = new Properties();\n     props.put("bootstrap.servers", "localhost:9092");\n     props.put("group.id", "test");\n     props.put("enable.auto.commit", "false");\n     props.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");\n     props.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");\n     KafkaConsumer<String, String> consumer = new KafkaConsumer<>(props);\n     consumer.subscribe(Arrays.asList("foo", "bar"));\n     final int minBatchSize = 200;\n     List<ConsumerRecord<String, String>> buffer = new ArrayList<>();\n     while (true) {\n         ConsumerRecords<String, String> records = consumer.poll(100);\n         for (ConsumerRecord<String, String> record : records) {\n             buffer.add(record);\n         }\n         if (buffer.size() >= minBatchSize) {\n             insertIntoDb(buffer);\n             consumer.commitSync();\n             buffer.clear();\n         }\n     }\n')])])]),o("p",[e._v("In this example we will consume a batch of records and batch them up in memory. When we have enough records batched, we will insert them into a database. If we allowed offsets to auto commit as in the previous example, records would be considered consumed after they were returned to the user in "),o("a",{attrs:{href:"https://kafka.apache.org/10/javadoc/org/apache/kafka/clients/consumer/KafkaConsumer.html#poll-long-",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("poll")]),o("OutboundLink")],1),e._v(". It would then be possible for our process to fail after batching the records, but before they had been inserted into the database.")]),e._v(" "),o("p",[e._v('To avoid this, we will manually commit the offsets only after the corresponding records have been inserted into the database. This gives us exact control of when a record is considered consumed. This raises the opposite possibility: the process could fail in the interval after the insert into the database but before the commit (even though this would likely just be a few milliseconds, it is a possibility). In this case the process that took over consumption would consume from last committed offset and would repeat the insert of the last batch of data. Used in this way Kafka provides what is often called "at-least-once" delivery guarantees, as each record will likely be delivered one time but in failure cases could be duplicated.')]),e._v(" "),o("p",[o("strong",[e._v("上面at-least-once 也不是绝对的，也可能丢数据(nothing to guarantee)：")])]),e._v(" "),o("p",[o("strong",[e._v('Note: Using automatic offset commits can also give you "at-least-once" delivery, but the requirement is that you must consume all data returned from each call to '),o("a",{attrs:{href:"https://kafka.apache.org/10/javadoc/org/apache/kafka/clients/consumer/KafkaConsumer.html#poll-long-",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("poll(long)")]),o("OutboundLink")],1),e._v(" before any subsequent calls, or before "),o("a",{attrs:{href:"https://kafka.apache.org/10/javadoc/org/apache/kafka/clients/consumer/KafkaConsumer.html#close--",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("closing")]),o("OutboundLink")],1),e._v(' the consumer. If you fail to do either of these, it is possible for the committed offset to get ahead of the consumed position, which results in missing records. The advantage of using manual offset control is that you have direct control over when a record is considered "consumed."')])]),e._v(" "),o("p",[e._v("The above example uses "),o("a",{attrs:{href:"https://kafka.apache.org/10/javadoc/org/apache/kafka/clients/consumer/KafkaConsumer.html#commitSync--",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("commitSync")]),o("OutboundLink")],1),e._v(" to mark all received records as committed. In some cases you may wish to have even finer control over which records have been committed by specifying an offset explicitly. In the example below we commit offset after we finish handling the records in each partition.")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('     try {\n         while(running) {\n             ConsumerRecords<String, String> records = consumer.poll(Long.MAX_VALUE);\n             for (TopicPartition partition : records.partitions()) {\n                 List<ConsumerRecord<String, String>> partitionRecords = records.records(partition);\n                 for (ConsumerRecord<String, String> record : partitionRecords) {\n                     System.out.println(record.offset() + ": " + record.value());\n                 }\n                 long lastOffset = partitionRecords.get(partitionRecords.size() - 1).offset();\n                 consumer.commitSync(Collections.singletonMap(partition, new OffsetAndMetadata(lastOffset + 1)));\n             }\n         }\n     } finally {\n       consumer.close();\n     }\nNote: The committed offset should always be the offset of the next message that your application will read. Thus, when calling commitSync(offsets) you should add one to the offset of the last message processed. \n')])])]),o("h3",{attrs:{id:"_2-2-上游-consume-topic-1-transform-produce-to-topic-2-手动提交-producer提交-at-most-once"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-上游-consume-topic-1-transform-produce-to-topic-2-手动提交-producer提交-at-most-once"}},[e._v("#")]),e._v(" 2.2 上游(consume topic 1-transform-produce to topic 2) - 手动提交/producer提交 at-most-once")]),e._v(" "),o("p",[o("strong",[e._v("idempotent producer:")])]),e._v(" "),o("p",[e._v("Prior to 0.11.0.0, if a producer failed to receive a response indicating that a message was committed, it had little choice but to resend the message. This provides at-least-once delivery semantics since the message may be written to the log again during resending if the original request had in fact succeeded. Since 0.11.0.0, the Kafka producer also supports an idempotent delivery option which guarantees that resending will not result in duplicate entries in the log. To achieve this, the broker assigns each producer an ID and deduplicates messages using a sequence number that is sent by the producer along with every message.")]),e._v(" "),o("h3",{attrs:{id:"_2-3-上游-consume-topic-1-transform-produce-to-topic-2-手动提交-producer提交-exactly-once"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-上游-consume-topic-1-transform-produce-to-topic-2-手动提交-producer提交-exactly-once"}},[e._v("#")]),e._v(" 2.3 上游(consume topic 1-transform-produce to topic 2) - 手动提交/producer提交 exactly-once")]),e._v(" "),o("p",[e._v("Also beginning with 0.11.0.0, the producer supports the ability to send messages to multiple topic partitions using transaction-like semantics: i.e. either all messages are successfully written or none of them are. The main use case for this is exactly-once processing between Kafka topics")]),e._v(" "),o("p",[e._v("接着看上游比较完整的 consumer-transform-produce 场景")]),e._v(" "),o("h4",{attrs:{id:"_2-3-1-依赖-interal-offset-exactly-once"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-1-依赖-interal-offset-exactly-once"}},[e._v("#")]),e._v(" 2.3.1 依赖 interal offset,exactly-once")]),e._v(" "),o("p",[o("strong",[e._v("重点：")]),e._v(" "),o("a",{attrs:{href:"#1-%E4%B8%8A%E6%B8%B8consume-topic-1--%E4%BE%9D%E8%B5%96internal-offset"}},[e._v('前面的"上游(consume topic 1) -依赖internal offset"')]),e._v(" 是依赖 consumer提交offset，而对于atomic-read-process-write需要Producer提交offset，"),o("a",{attrs:{href:"https://stackoverflow.com/questions/45195010/meaning-of-sendoffsetstotransaction-in-kafka-0-11",target:"_blank",rel:"noopener noreferrer"}},[e._v("Producer#sendOffsetsToTransaction"),o("OutboundLink")],1)]),e._v(" "),o("p",[e._v("参考"),o("a",{attrs:{href:"/docs/software/buildingblock/kafka"}},[e._v("深入Exactly-Once解析")])]),e._v(" "),o("p",[e._v("example 1：")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("public class KafkaTransactionsExample {\n  \n  public static void main(String args[]) {\n    KafkaConsumer<String, String> consumer = new KafkaConsumer<>(consumerConfig);\n \n \n    // Note that the ‘transactional.id’ configuration _must_ be specified in the\n    // producer config in order to use transactions.\n    KafkaProducer<String, String> producer = new KafkaProducer<>(producerConfig);\n \n    // We need to initialize transactions once per producer instance. To use transactions,\n    // it is assumed that the application id is specified in the config with the key\n    // transactional.id.\n    //\n    // This method will recover or abort transactions initiated by previous instances of a\n    // producer with the same app id. Any other transactional messages will report an error\n    // if initialization was not performed.\n    //\n    // The response indicates success or failure. Some failures are irrecoverable and will\n    // require a new producer  instance. See the documentation for TransactionMetadata for a\n    // list of error codes.\n    producer.initTransactions();\n     \n    while(true) {\n      ConsumerRecords<String, String> records = consumer.poll(CONSUMER_POLL_TIMEOUT);\n      if (!records.isEmpty()) {\n        // Start a new transaction. This will begin the process of batching the consumed\n        // records as well\n        // as an records produced as a result of processing the input records.\n        //\n        // We need to check the response to make sure that this producer is able to initiate\n        // a new transaction.\n        producer.beginTransaction();\n         \n        // Process the input records and send them to the output topic(s).\n        List<ProducerRecord<String, String>> outputRecords = processRecords(records);\n        for (ProducerRecord<String, String> outputRecord : outputRecords) {\n          producer.send(outputRecord);\n        }\n         \n        // To ensure that the consumed and produced messages are batched, we need to commit\n        // the offsets through\n        // the producer and not the consumer.\n        //\n        // If this returns an error, we should abort the transaction.\n         \n        sendOffsetsResult = producer.sendOffsetsToTransaction(getUncommittedOffsets());\n         \n      \n        // Now that we have consumed, processed, and produced a batch of messages, let's\n        // commit the results.\n        // If this does not report success, then the transaction will be rolled back.\n        producer.endTransaction();\n      }\n    }\n  }\n}\n")])])]),o("p",[e._v("example 2：")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('KafkaProducer producer = createKafkaProducer(\n  “bootstrap.servers”, “localhost:9092”,\n  “transactional.id”, “my-transactional-id”);\n\nproducer.initTransactions();\n\nKafkaConsumer consumer = createKafkaConsumer(\n  “bootstrap.servers”, “localhost:9092”,\n  “group.id”, “my-group-id”,\n  "isolation.level", "read_committed");\n\nconsumer.subscribe(singleton(“inputTopic”));\n\nwhile (true) {\n  ConsumerRecords records = consumer.poll(Long.MAX_VALUE);\n  producer.beginTransaction();\n  for (ConsumerRecord record : records)\n    producer.send(producerRecord(“outputTopic”, record));\n  producer.sendOffsetsToTransaction(currentOffsets(consumer), group);  \n  producer.commitTransaction();\n}\n')])])]),o("h4",{attrs:{id:"_2-3-2-不依赖interal-offset-自己维护offset-exactly-once"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-2-不依赖interal-offset-自己维护offset-exactly-once"}},[e._v("#")]),e._v(" 2.3.2 不依赖interal offset，自己维护offset exactly-once")]),e._v(" "),o("p",[e._v("The consumer application need not use Kafka's built-in offset storage, it can store offsets in a store of its own choosing, example usage:")]),e._v(" "),o("ul",[o("li",[e._v("If the results of the consumption are being stored in a relational database, storing the offset in the database as well can allow committing both the results and offset in a single transaction. Thus either the transaction will succeed and the offset will be updated based on what was consumed or the result will not be stored and the offset won't be updated.")]),e._v(" "),o("li",[e._v("If the results are being stored in a local store it may be possible to store the offset there as well. For example a search index could be built by subscribing to a particular partition and storing both the offset and the indexed data together. If this is done in a way that is atomic, it is often possible to have it be the case that even if a crash occurs that causes unsync'd data to be lost, whatever is left has the corresponding offset stored as well. This means that in this case the indexing process that comes back having lost recent updates just resumes indexing from what it has ensuring that no updates are lost.")])]),e._v(" "),o("p",[e._v("比如存储offset到自己维护的一个topic T-SNP 作为增量数据主题")]),e._v(" "),o("p",[e._v("消费时：")]),e._v(" "),o("p",[e._v("Configure "),o("code",[e._v("enable.auto.commit=false")])]),e._v(" "),o("p",[e._v("因为每条record 都携带其offset信息根据模型\n"),o("img",{attrs:{src:"/docs/docs_image/software/buildingblock/kafka/kafka_exactly_once01.png",alt:"atomic-read-process-write"}}),e._v("，将write和mark read（Use the offset provided with each "),o("a",{attrs:{href:"https://kafka.apache.org/10/javadoc/org/apache/kafka/clients/consumer/ConsumerRecord.html",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("ConsumerRecord")]),o("OutboundLink")],1),e._v(" to save your position）作为一个transaction提交；")]),e._v(" "),o("p",[e._v("启动或“重启”时：")]),e._v(" "),o("p",[e._v("则找到最后一个消息，即存储的最后一个offset，方法:")]),e._v(" "),o("p",[e._v("endOffsets（返回the offset of the upcoming message, i.e. the offset of the last available message + 1. 所以-1就是到了last available message的位置，还要再-1才能再后面poll到这条消息） --\x3e assign ---\x3e seek（不能用seekToEnd，用了则poll不到任何消息，只能等待新消息） ---\x3e poll")]),e._v(" "),o("p",[e._v("，然后通过获取的offset定位恢复restore到上一次这个topic的position处理位置 "),o("a",{attrs:{href:"https://kafka.apache.org/10/javadoc/org/apache/kafka/clients/consumer/KafkaConsumer.html#seek-org.apache.kafka.common.TopicPartition-long-",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("seek(TopicPartition, long)")]),o("OutboundLink")],1),e._v("，然后再poll")]),e._v(" "),o("p",[e._v("注意：")]),e._v(" "),o("ul",[o("li",[e._v("如果想要zombie fence生效，除了用对transaction.id，这个顺序也很重要，要先去initTransaction注册 transaction.id（形象的说就是争取到合法身份先），然后才是去restore（读取增量快照做恢复），否则，如果你先去restore，再去注册（创建Transactional Producer并initTransactions），有可能restore的时候读取到增量快照是 1000，旧的Producer仍然可以继续写入kafka：\n"),o("ul",[o("li",[e._v("case 1：遇到过一次disruptor ringbuffer在rebalance之后继续工作重复落库的事情，解决办法：onrevoke的时候关闭producer")]),e._v(" "),o("li",[e._v("case 2：case 1只适用于单实例模式，如果是多活模式，在网络抖动的时间窗内，仍然有机会产生该问题\n，因此等到 去注册（争取合法身份）的时候，增量快照可能已经到了2000，然后因为你先做的restore，你会定位到1000，将1001开始的都当做新消息：")])])])]),e._v(" "),o("p",[e._v("每个consumer group中的服务rebalance的正确启动顺序应该是：")]),e._v(" "),o("ol",[o("li",[e._v("先根据 kafka分配的partition创建好worker（主要是Transactional Producer），这个做完后，会立即让fence生效，不用再担心 其他服务上仍在等待shutdown的disruptorWorker继续消费ringbuffer的缓存消息")]),e._v(" "),o("li",[e._v("读取增量快照进行restore，由于第1步做完，我们完全相信kafka可以履行zombie fence，所以这里可以100%确定可以拿到准确的 last offset，从而准确的恢复")])]),e._v(" "),o("ul",[o("li",[o("p",[e._v("有一个缺点是，虽然我们启动时可以判断，比如[0,1000]是之前处理过的，1001开始是新的数据，但是为了使内存恢复到之前的状态，仍然需要对[0,1000]这个区间的数据进行计算（只不过不进行任何事务处理比如落数据库，只是单纯为了restore memory），所以一个改进策略就是，增加全量快照，系统停止之前或定期将内存序列化存起来，注意存的时候同时存下当时的offset，比如1000，然后在增量快照中记录下这个全量快照的位置（当然还有我们要保存的offset）即可，由于为了记录下全量快照的kafka位置，需要等待kafka send的回调，所以记录到增量快照没有办法跟保存全量快照作为一个事务处理，不过没关系：")]),e._v(" "),o("p",[e._v("比如主题T-TARGET ，现在处理到了offset=1000，决定做一次全量快照，此时全量快照中保存下内存状态和start offset=1000，kafka send全量快照到 T-QuanLiang中，然后在callback时，可以获取到全量快照在T-QuanLiang的 quanliang offset比如=0，T-TARGET进来新的消息（或者之前做全量快照的指令本身就是条消息），继续事务性的记录增量快照 T-ZengLiang，此时最新记录的增量消息的内容是 quanliang offset=0&&end offset=1001")]),e._v(" "),o("p",[e._v("恢复的时候，先 找到T-ZengLiang最后一个消息 ，获取到quanliang offset=0&&end offset=1001，然后通过quanliang offset=0去seek(T-QuanLiang, 0) 拿到 start offset=1000和当时的内存数据，从而恢复内存数据，然后从1000开始(1000,1001],只需要重新计算下1001这条数据更新下内存即可，从1002开始往后都是新的消息")])])]),e._v(" "),o("h3",{attrs:{id:"_2-4-上游-produce-to-topic-2-下游-consume-topic-2-isolation-level"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-上游-produce-to-topic-2-下游-consume-topic-2-isolation-level"}},[e._v("#")]),e._v(" 2.4 上游(produce to topic 2)->下游(consume topic 2) - isolation.level")]),e._v(" "),o("p",[o("strong",[e._v("we can indicate with *isolation.level* that we should wait to read transactional messages until the associated transaction has been committed")]),e._v(":")]),e._v(" "),o("div",{staticClass:"language-java extra-class"},[o("pre",{pre:!0,attrs:{class:"language-java"}},[o("code",[e._v("consumerProps"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),o("span",{pre:!0,attrs:{class:"token function"}},[e._v("put")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),o("span",{pre:!0,attrs:{class:"token string"}},[e._v('"isolation.level"')]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token string"}},[e._v('"read_committed"')]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),o("p",[e._v("在消费端有一个参数isolation.level，设置为“read_committed”，表示消费端应用不可以看到尚未提交的事务内的消息。如果生产者开启事务并向某个分区值发送3条消息 msg1、msg2 和 msg3，在执行 commitTransaction() 或 abortTransaction()  方法前，设置为“read_committed”的消费端应用是消费不到这些消息的，不过在 KafkaConsumer  内部会缓存这些消息，直到生产者执行 commitTransaction() 方法之后它才能将这些消息推送给消费端应用。反之，如果生产者执行了  abortTransaction() 方法，那么 KafkaConsumer 会将这些缓存的消息丢弃而不推送给消费端应用。")]),e._v(" "),o("p",[o("a",{attrs:{href:"https://stackoverflow.com/questions/56047968/kafka-isolation-level-implications",target:"_blank",rel:"noopener noreferrer"}},[e._v("kafka isolation level implications"),o("OutboundLink")],1)]),e._v(" "),o("hr"),e._v(" "),o("p",[o("a",{attrs:{href:"https://cwiki.apache.org/confluence/display/KAFKA/KIP-568%3A+Explicit+rebalance+triggering+on+the+Consumer",target:"_blank",rel:"noopener noreferrer"}},[e._v("KIP-568: Explicit rebalance triggering on the Consumer"),o("OutboundLink")],1)]),e._v(" "),o("p",[o("a",{attrs:{href:"http://javierholguera.com/2018/01/01/timeouts-in-kafka-clients-and-kafka-streams/",target:"_blank",rel:"noopener noreferrer"}},[e._v("TIMEOUTS IN KAFKA CLIENTS AND KAFKA STREAMS"),o("OutboundLink")],1)]),e._v(" "),o("p",[o("a",{attrs:{href:"https://kafka.apache.org/documentation/#design",target:"_blank",rel:"noopener noreferrer"}},[e._v("nothing to guarantee=>at-most-once | at-least-once => exactly-once"),o("OutboundLink")],1)]),e._v(" "),o("p",[o("a",{attrs:{href:"https://kafka.apache.org/documentation/#semantics",target:"_blank",rel:"noopener noreferrer"}},[e._v("Message Delivery Semantics"),o("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=r.exports}}]);