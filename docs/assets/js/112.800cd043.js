(window.webpackJsonp=window.webpackJsonp||[]).push([[112],{562:function(e,n,t){"use strict";t.r(n);var a=t(65),r=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("druid")]),e._v(" "),t("p",[e._v("spring boot druid starter: druid-spring-boot-starter")]),e._v(" "),t("p",[e._v("如果直接使用druid是不会自动装配的，要自己写好配置类")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\n@Configuration\npublic class DruidConfig {\n\n    /*\n       将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建\n       绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效\n       @ConfigurationProperties(prefix = "spring.datasource")：作用就是将 全局配置文件中\n       前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中\n     */\n    @ConfigurationProperties(prefix = "spring.datasource")\n    @Bean\n    public DataSource druidDataSource() {\n        return new DruidDataSource();\n    }\n\n}\n\n\nspring.datasource.url=jdbc:mysql://XXXXX:3306/clear?useCursorFetch=true&defaultFetchSize=100&rewriteBatchedStatements=true&useServerPrepStmts=false&cachePrepStmts=true&useCompression=true&autoReconnect=true&useUnicode=true&characterEncoding=utf-8&connectionCollation=utf8_general_ci&useSSL=false&serverTimezone=Asia/Shanghai\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\nspring.datasource.type=com.alibaba.druid.pool.DruidDataSource\nspring.datasource.username=test_dbuser\nspring.datasource.password=PASSWORD\nspring.datasource.initialSize=10\nspring.datasource.minIdle=100\nspring.datasource.maxActive=500\nspring.datasource.maxWait=60000\nspring.datasource.timeBetweenEvictionRunsMillis=60000\nspring.datasource.minEvictableIdleTimeMillis=300000\nspring.datasource.maxPoolPreparedStatementPerConnectionSize=500\n\nOR\n\n@ConfigurationProperties(prefix = "spring.datasource.druid")\npublic class DruidProperties {\n    private int initialSize = 0;\n    private int maxActive = 8;\n    private int minIdle = 0;\n    private long maxWait = -1;\n    private long timeBetweenEvictionRunsMillis = 60 * 1000L;\n    private long minEvictableIdleTimeMillis = 1000L * 60L * 30L;\n    private long maxEvictableIdleTimeMillis = 1000L * 60L * 60L * 7;\n    private String validationQuery;\n    private int validationQueryTimeout = -1;\n    private boolean testOnBorrow = false;\n    private boolean testOnReturn = false;\n    private boolean testWhileIdle = true;\n    private boolean poolPreparedStatements = false;\n    private int maxOpenPreparedStatements = -1;\n    private boolean sharePreparedStatements = false;\n    private Properties connectionProperties;\n    private String filters = "stat,wall";\n    private int maxPoolPreparedStatementPerConnectionSize = 20;\n    private boolean  useGlobalDataSourceStat = true;\n    .....\n }\n spring:\n  ##Druid DataSource数据库访问配置\n  datasource:\n    is-dynamic-datasource: true\n    type: com.alibaba.druid.pool.DruidDataSource\n    url: jdbc:mysql://XXXXX/?characterEncoding=utf-8&autoReconnect=true&useSSL=false&serverTimezone=UTC\n    username: test_dbuser\n    password: PASSWORD\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    druid:\n      #连接池配置\n      #初始化时建立物理连接的个数\n      initialSize: 1\n      #最小连接池数量\n      minIdle: 0\n      #最大连接池数量\n      maxActive: 5\n      #获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，\n      #如果需要可以通过配置useUnfairLock属性为true使用非公平锁。\n      maxWait: 60000\n      #配置相隔多久进行一次检测(检测可以关闭的空闲连接),此处设置为1分钟检测一次。\n      timeBetweenEvictionRunsMillis: 60000\n      #一个连接在池中最小生存的时间(ms),此处设置为半小时。\n      minEvictableIdleTimeMillis: 1800000\n      #一个连接在池中最大生存的时间(ms),此处设置为7天。\n      maxEvictableIdleTimeMillis: 25200000\n      #用来检测连接是否有效的sql; 如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会启作用。\n      validationQuery: SELECT 1 FROM DUAL\n      #检测连接是否有效的超时时间,默认-1(单位:秒).\n      validationQueryTimeout: 5\n      #建议配置为true，不影响性能，并且保证安全性，申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，\n      #执行validationQuery检测连接是否有效。\n      testWhileIdle: true\n      #申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n      testOnBorrow: false\n      #归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能\n      testOnReturn: false\n      #是否缓存preparedStatement，也就是PSCache;PSCache对支持游标的数据库性能提升巨大，比如说oracle;\n      #在mysql5.5以下的版本中没有PSCache功能，建议关闭掉。\n      poolPreparedStatements: true\n      #打开PSCache，并且指定每个连接上PSCache的大小\n      maxPoolPreparedStatementPerConnectionSize: 20\n      sharePreparedStatements: false\n      # 通过connectProperties属性来打开mergeSql功能；慢SQL记录\n      #connectionProperties: druid.stat.mergeSql=true;druid.stat.logSlowSql=true;druid.stat.slowSqlMillis=5000\n      # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，\'wall\'用于防火墙\n      filters: stat,wall,log4j2\n      #要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。\n      #在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100\n      #此处默认为-1\n      maxOpenPreparedStatements: 10\n      #合并多个DruidDataSource的监控数据\n      useGlobalDataSourceStat: true\n')])])]),t("p",[e._v("https://segmentfault.com/a/1190000039005979")]),e._v(" "),t("disqus")],1)}),[],!1,null,null,null);n.default=r.exports}}]);