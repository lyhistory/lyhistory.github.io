<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>计算机基础教程</title>
    <meta name="description" content="软件开发教程，渗透测试入门教程，区块链入门教程，物联网，大数据">
    
    
    <link rel="preload" href="/docs/assets/css/0.styles.89d6372f.css" as="style"><link rel="preload" href="/docs/assets/js/app.ee9227dc.js" as="script"><link rel="preload" href="/docs/assets/js/2.5d2fca3b.js" as="script"><link rel="preload" href="/docs/assets/js/19.16387e1f.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.721f26cd.js"><link rel="prefetch" href="/docs/assets/js/11.d423cff2.js"><link rel="prefetch" href="/docs/assets/js/12.c896a5d2.js"><link rel="prefetch" href="/docs/assets/js/13.b5d43067.js"><link rel="prefetch" href="/docs/assets/js/14.d207c617.js"><link rel="prefetch" href="/docs/assets/js/15.5da13259.js"><link rel="prefetch" href="/docs/assets/js/16.8f343a37.js"><link rel="prefetch" href="/docs/assets/js/17.d2341118.js"><link rel="prefetch" href="/docs/assets/js/18.5a00c198.js"><link rel="prefetch" href="/docs/assets/js/20.bbc18f39.js"><link rel="prefetch" href="/docs/assets/js/3.861e9ad6.js"><link rel="prefetch" href="/docs/assets/js/4.6b1b1ab7.js"><link rel="prefetch" href="/docs/assets/js/5.15cc1684.js"><link rel="prefetch" href="/docs/assets/js/6.dc2d61b1.js"><link rel="prefetch" href="/docs/assets/js/7.2674f001.js"><link rel="prefetch" href="/docs/assets/js/8.162adf02.js"><link rel="prefetch" href="/docs/assets/js/9.2f2e60aa.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.89d6372f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><!----> <span class="site-name">计算机基础教程</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/docs/" class="nav-link">机器指令</a></div><div class="nav-item"><a href="/docs/software/" class="nav-link router-link-active">软件基础</a></div><div class="nav-item"><a href="/docs/coder2hacker/" class="nav-link">渗透测试</a></div><div class="nav-item"><a href="/docs/blockchain/" class="nav-link">区块链</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/docs/" class="nav-link">机器指令</a></div><div class="nav-item"><a href="/docs/software/" class="nav-link router-link-active">软件基础</a></div><div class="nav-item"><a href="/docs/coder2hacker/" class="nav-link">渗透测试</a></div><div class="nav-item"><a href="/docs/blockchain/" class="nav-link">区块链</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/software/zookeeper.html#install-usage" class="sidebar-link">Install &amp; usage</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/docs/software/zookeeper.html#编译源码" class="sidebar-link">编译源码</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/docs/software/zookeeper.html#源码解读" class="sidebar-link">源码解读</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/software/zookeeper.html#server端代码" class="sidebar-link">server端代码</a></li><li class="sidebar-sub-header"><a href="/docs/software/zookeeper.html#zookeeper-client端代码" class="sidebar-link">Zookeeper client端代码</a></li><li class="sidebar-sub-header"><a href="/docs/software/zookeeper.html#curator-api封装代码" class="sidebar-link">Curator api封装代码</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p><a href="/docs/software">回目录</a>  《分布式框架zookeeper》</p> <h1 id="quickstart"><a href="#quickstart" class="header-anchor">#</a> QuickStart:</h1> <h2 id="install-usage"><a href="#install-usage" class="header-anchor">#</a> Install &amp; usage</h2> <p>https://cwiki.apache.org/confluence/display/ZOOKEEPER/Index
https://zookeeper.apache.org/doc/current/index.html</p> <p>？Failed to start and no log
Resolved: yum install glibc.i686
./bin/zkServer.sh start-foreground
$ java -version
bash: /apex/apps/dependency/java-se-8u40-ri/bin/java: /lib/ld-linux.so.2: bad ELF interpreter: No such file or directory
[clear@sgkc2-devclr-v08 dependency]$ /lib/ld-linux.so.2: bad ELF interpreter: No such file or directory</p> <p>https://zookeeper.apache.org/doc/r3.3.3/zookeeperStarted.html</p> <p>bin/zkCli.sh -server 127.0.0.1:2181
help
ls /
get /test
ls /test mywatcher
delete /test</p> <h2 id="编译源码"><a href="#编译源码" class="header-anchor">#</a> 编译源码</h2> <p>https://www.cnblogs.com/MangoCai/p/10846187.html</p> <p>安装ant，设置%ANT_HOME%\bin
Copy ivy.jar到ant lib
根节点 ant eclipse
Eclipse导入普通java project，修改build path jdk和compliance
通过VerGen.java生成Info.java（/org/apache/zookeeper/version）
<img src="/docs/docs_image/software/zookeeper/zookeeper01.png" alt="">
Copy到VerGen.java的上一层package里面</p> <p>然后两种方式生成jar，
命令行和eclipse导出
根目录下执行
ant jar compile-test
或者
<img src="/docs/docs_image/software/zookeeper/zookeeper02.png" alt=""></p> <p>Copy conf/zoo.cfg修改
dataDir=C:\Workspace\Repository\zookeeper-release-3.5.6\dataDir</p> <p>把jar放到根目录下，
运行
<code>/bin/zkServer.cmd /bin/zkCli.cmd</code></p> <h1 id="monitor-troubleshooting"><a href="#monitor-troubleshooting" class="header-anchor">#</a> monitor&amp;troubleshooting</h1> <p>Admin
https://zookeeper.apache.org/doc/current/zookeeperAdmin.html</p> <p>troubleshooting
https://cwiki.apache.org/confluence/display/ZOOKEEPER/Troubleshooting</p> <p>somoktest latency
https://cwiki.apache.org/confluence/display/ZOOKEEPER/ServiceLatencyOverview</p> <p>Jmx
https://zookeeper.apache.org/doc/current/zookeeperJMX.html#</p> <div class="language- extra-class"><pre class="language-text"><code>vim bin/zkServer.sh
找到ZOODAMIN=&quot;&quot;  添加 -Djava.rmi.server.hostname=$JMXHOSTNAME

到conf下面添加java.env:
JMXHOSTNAME=''
JMXPORT=2182
</code></pre></div><p>?Failed to resolve hostname, malformed url
edit /etc/hosts,add 127.0.0.1 <hostname></hostname></p> <p>jconsole
Four letter words
https://zookeeper.apache.org/doc/r3.4.13/zookeeperAdmin.html#sc_zkCommands</p> <p>Baseline
https://cwiki.apache.org/confluence/display/ZOOKEEPER/ServiceLatencyOverview</p> <h1 id="programming"><a href="#programming" class="header-anchor">#</a> programming</h1> <p>https://cwiki.apache.org/confluence/display/ZOOKEEPER/ErrorHandling
https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html</p> <h1 id="原理解读"><a href="#原理解读" class="header-anchor">#</a> 原理解读</h1> <p><img src="/docs/docs_image/software/zookeeper/zookeeper03.png" alt=""> <img src="/docs/docs_image/software/zookeeper/zookeeper04.png" alt=""> <img src="/docs/docs_image/software/zookeeper/zookeeper05.png" alt="">
Semaphores 
Queues 
Leader election
Group  membership 
Barriers 
Configuration</p> <p>ZooKeeper has a built-in sanity check of 1M, to prevent it from being used as a large data store, but in general it is used to store much smaller pieces of data.
zxid (ZooKeeper Transaction Id). Each update will have a unique zxid
分布式协调，通过观察者模式，rpc通知客户端节点变化，默认的客户端有：
自带的zkCli.sh以及org.apache.zookeeper 客户端lib jar包
还有curator高级开发API
zookeeper事件触发是通过推拉的方式，先通知watcher客户端节点变动，然后客户端再去pull下来新增或变化的节点信息；
Watcher机制/观察者模式
https://www.jianshu.com/p/4c071e963f18</p> <h2 id="源码解读"><a href="#源码解读" class="header-anchor">#</a> 源码解读</h2> <p>Apache ZooKeeper Watcher 机制源码解释 https://www.ibm.com/developerworks/cn/opensource/os-cn-apache-zookeeper-watcher/index.html
Zookeeper源码分析之客户端源码解密 https://www.jianshu.com/p/06e859181cc0
Zookeeper源码分析之curator客户端 https://www.jianshu.com/p/bc5e24e4f614</p> <p><img src="/docs/docs_image/software/zookeeper/zookeeper10.png" alt=""></p> <h3 id="server端代码"><a href="#server端代码" class="header-anchor">#</a> server端代码</h3> <p>server下面的FinalRequestProcessor是终极请求处理类，所有server收到的请求最终都是流向这里，下面看看如果triggerWatcher的流程：
<img src="/docs/docs_image/software/zookeeper/zookeeper11.png" alt="">
然后进去看watcher 的process</p> <p>可以看到zookeeper server“调用客户端”的watch通知是通过跟客户端的socket连接直接返回response，然后客户端收到请求后会反序列化调用自己实现的watch接口方法
zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/NIOServerCnxn.java
这里的NIOServerCnxn间接继承自Watcherzookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/ServerCnxn.java
public abstract class ServerCnxn implements Stats, Watcher {
记住这里的ServerCnxn，后面会讲解client端对应的ClientCnxn</p> <h3 id="zookeeper-client端代码"><a href="#zookeeper-client端代码" class="header-anchor">#</a> Zookeeper client端代码</h3> <p>Client由三个主要模块组成：Zookeeper, WatcherManager, ClientCnxn
Zookeeper是ZK Client端的接口，
WatcherManager，管理ZK Client绑定的所有Watcher。
ClientCnxn是管理所有网络IO的模块，所有和ZK Server交互的信息和数据都经过这个模块</p> <p>zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeper.java
clientWatchManager用于存储管理客户端连过来的watcher</p> <p>首先是zookeeper server自带的cli工具：
zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeperMain.java</p> <p>然后是zookeeper client端代码：
客户端收到消息后，会调用 ClientCnxn 的 SendThread.readResponse 方法来进行统一处理，如果响应头 replyHdr 中标识的 Xid 为 02，表示是 ping，如果为-4，表示是验证包，如果是-1，表示这是一个通知类型的响应，然后进行反序列化、处理 chrootPath、还原 WatchedEvent、回调 Watcher 等步骤，其中回调 Watcher 步骤将 WacthedEvent 对象交给 EventThread 线程，在下一个轮询周期中进行 Watcher 回调；
补充：ClientCnxnSocket会读取socket连接，发现connected信息也将交由SendThread的onconnected处理
zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java</p> <p>SendThread 接收到服务端的通知事件后，会通过调用 EventThread 类的 queueEvent 方法将事件传给 EventThread 线程，queueEvent 方法根据该通知事件，从 ZKWatchManager 中取出所有相关的 Watcher
客户端在识别出事件类型 EventType 之后，会从相应的 Watcher 存储中删除对应的 Watcher，获取到相关的 Watcher 之后，会将其放入 waitingEvents 队列，该队列从字面上就能理解是一个待处理队列，线程的 run 方法会不断对该该队列进行处理，这就是一种异步处理思维的实现</p> <h3 id="curator-api封装代码"><a href="#curator-api封装代码" class="header-anchor">#</a> Curator api封装代码</h3> <p>七张图彻底讲清楚ZooKeeper分布式锁的实现原理
https://juejin.im/post/5c01532ef265da61362232ed
Zookeeper使用之curator
https://leokongwq.github.io/2018/06/17/zookeeper-curator.html
Curator分布式锁
https://blog.csdn.net/xuefeng0707/article/details/80588855
Zookeeper Curator 事件监听 - 秒懂
https://www.cnblogs.com/crazymakercircle/p/10228385.html</p> <h4 id="curator-leader-election代码解析"><a href="#curator-leader-election代码解析" class="header-anchor">#</a> curator leader election代码解析</h4> <p><img src="/docs/docs_image/software/zookeeper/curator01.png" alt="">
图示上半部分为跟zookeeper断线之后的逻辑，</p> <p>断线处理很简单，LeaderSelectorListener继承了ConnectionStateListener，
然后这个listener注册到了CuratorFrameworkImpl维护的listener容器，
当断线时回调这个listener wrapper，wrapper再回调statechange，然后可以在statechange里面抛出异常从而触发
leaderSelector.interruptLeadership，其内部就是获取“执行takeleadership的doWorkLoop所在的线程executorService”这个task，然后调用其cancel（boolean java.util.concurrent.Future.cancel(boolean mayInterruptIfRunning)）方法中断操作</p> <p>额外指出，从架构设计上欣赏的curator的监听器管理，CuratorFrameworkImpl将这些ConnectionStateListener交由ConnectionStateManager来统一管理，当监测到状态变化，
ConnectionStateManager调用注册好的listener的StateChange来通知变化，这是典型的一个抽象出来的状态机管理实现；</p> <p>下半部分是选举的分布式锁机制，主要的逻辑基石就是zookeeper保证了sequence ephemeral节点的生成，然后后一个节点监听前一个节点，只有前一个节点删除后才会通过watcher去唤醒后面一个等待的节点</p> <p>curator封装的InterProcessMutex注释：
/**
* A re-entrant mutex that works across JVMs. Uses Zookeeper to hold the lock. All processes in all JVMs that
* use the same lock path will achieve an inter-process critical section. Further, this mutex is
* &quot;fair&quot; - each user will get the mutex in the order requested (from ZK's point of view)
*/
public class InterProcessMutex implements InterProcessLock, Revocable<InterProcessMutex>
所谓跨JMS mutex实际上就是：</InterProcessMutex></p> <ol><li>首先还是要考虑同一个application，即同一个jvm进程中多线程的竞争问题，所以引入了大量的synchronized方法和synchronized(this)方法块，</li> <li>跨JVMs主要就是利用了StandardLockInternalsDriver的getsTheLock，利用ephemeral sequential先获取当前leader下面注册了多少child，然后当前的node就去pathToWatch前面一个node（children.get(ourIndex - maxLeases)，maxLeases=1）</li></ol> <h4 id="pathchildrencache解析：-zookeeper推拉消息"><a href="#pathchildrencache解析：-zookeeper推拉消息" class="header-anchor">#</a> PathChildrenCache解析： zookeeper推拉消息</h4> <p>如果我们直接使用zookeeper client开发，只能自定义各种watcher，然后向zookeeper也就是zookeeper client端接口注册，然后最终注册到zookeeper服务端，
然后服务端的变化通知watcher，由于watcher是一次性的，所以每次getChildren或getData时都要设置参数项watcher为true，才可以继续监听zknode变化。</p> <p>而使用Curator封装好的NodeCache PathChildrenCache等类，我们只需要创建实现一个继承了curator相关listener接口的listener，即可实现‘实时’监听zknode变化，不需要再写繁杂的watcher代码；</p> <p>看看封装好的这个PathChildrenCache，
<img src="/docs/docs_image/software/zookeeper/curator02.png" alt=""></p> <p>我们自定义了listener，并向PathChildrenCache提供的listenerContainer注册，然后启动start</p> <p>启动后，实际上PathChildrenCache并没有将我们自定义的listener注册到curatorFramework client（实际类为CuratorFrameworkImpl），而是自己注册了一个自己的ConnectionStateListener，
不过这个主要是管理跟zookeeper服务端的连接情况，
然后OfferOperation会调用refresh(),
先向curatorFramework注册一个childWatcher，然后第一次比如节点创建后回调callback方法processResult调用processChildren，然后调用getDataAndStat，
这里又会注册一个dataWatcher，
当然这两个watcher都是最终是层层转接注册到前面说的zookeeper服务端的，下面我们就先看看到底是怎么层层转到zookeeper client接口的；</p> <p>上面说了watcher的注册，watcher的作用就是接收zookeeper服务端zknode节点及数据变化，接收的参数WatchedEvent，只是会知道变化的类型：
public enum EventType {
None (-1),
NodeCreated (1),
NodeDeleted (2),
NodeDataChanged (3),
NodeChildrenChanged (4);
然后具体变化还要主动去拉取，
所以粗略的逻辑是，curatorFramework把收到的watcher注册请求都注册给zookeeper，zookeeper服务端通知客户端watcher，然后curator在PathChildrenCache的watcher再去拉取数据；</p> <p>这两个watcher注册的地方都是创建者模式builder pattern的fluent API流畅连写：
client.getChildren().usingWatcher(childrenWatcher).inBackground(callback).forPath(path);
client.getData().usingWatcher(dataWatcher).inBackground(callback).forPath(fullPath);</p> <p>下面就以dataWatcher这个来说明：</p> <p>注意这里的getData()是调用的curatorFramework的，所以实际是拿到dataBuilder，对应的实现类是getDataBuilderImpl，然后最后是落脚在forPath，实际就是调用了
getDataBuilderImpl的forPath方法，我们就看下这个的forPath方法：</p> <p>可以看到，有前台和后台执行两种模式，前台执行很直接，调用zookeeper的getdata，
继续看后台执行的模式，而后台跑则调用curatorFramework的processBackgroundOperation：
此时CuratorEvent==null，则isInitialExecution==true,所以只会调用performBackgroundOperation，然后最终是调用接口BackgroundOperation.performBackgroundOperation,
即最终调用回该接口的引用getDataBuilderImpl的performBackgroundOperation，</p> <div class="language- extra-class"><pre class="language-text"><code> if ( watching.isWatched() )
{
	client.getZooKeeper().getData(operationAndData.getData(), true, callback, backgrounding.getContext());
}
else
{
	client.getZooKeeper().getData(operationAndData.getData(), watching.getWatcher(), callback, backgrounding.getContext());
}
</code></pre></div><p>真香，可以看到最终肯定还是调用zookeeper client的getdata，然后注意到其定义的callback里面组装了一个CuratorEvent</p> <div class="language- extra-class"><pre class="language-text"><code>CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.GET_DATA, rc, path, null, ctx, stat, data, null, null, null);
                    client.processBackgroundOperation(operationAndData, event);
</code></pre></div><p>然后看到其callback里面再次调用curatorFramework的processBackgroundOperation，这一次event！=null了，所以走到下面的</p> <div class="language- extra-class"><pre class="language-text"><code>if ( operationAndData.getCallback() != null )
{
	sendToBackgroundCallback(operationAndData, event);
	break;
}

processEvent(event);
</code></pre></div><p>这个callback是啥，回过头查一下就知道这个是一开始在PathChildrenCache里面注册的:</p> <div class="language- extra-class"><pre class="language-text"><code>void getDataAndStat(final String fullPath) throws Exception
    {
        BackgroundCallback callback = new BackgroundCallback()
        {
            @Override
            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
            {
                applyNewData(fullPath, event.getResultCode(), event.getStat(), cacheData ? event.getData() : null);
            }
        };

        if ( USE_EXISTS &amp;&amp; !cacheData )
        {
            client.checkExists().usingWatcher(dataWatcher).inBackground(callback).forPath(fullPath);
        }
        else
        {
            // always use getData() instead of exists() to avoid leaving unneeded watchers which is a type of resource leak
            if ( dataIsCompressed &amp;&amp; cacheData )
            {
                client.getData().decompressed().usingWatcher(dataWatcher).inBackground(callback).forPath(fullPath);
            }
            else
            {
                client.getData().usingWatcher(dataWatcher).inBackground(callback).forPath(fullPath);
            }
        }
    }
</code></pre></div><p>回到前面，所以整个意思是调用zookeeper client接口获取的data要封装成curatorEvent再调用回PathChildrenCache的callback，callback调用applyNewData：</p> <div class="language- extra-class"><pre class="language-text"><code>if ( previousData == null ) // i.e. new
{
	offerOperation(new EventOperation(this, new PathChildrenCacheEvent(PathChildrenCacheEvent.Type.CHILD_ADDED, data)));
}
else if ( previousData.getStat().getVersion() != stat.getVersion() )
{
	offerOperation(new EventOperation(this, new PathChildrenCacheEvent(PathChildrenCacheEvent.Type.CHILD_UPDATED, data)));
}
</code></pre></div><p>可以看到这里封装了PathChidrenCacheEvent，再最终回调一开始开头注册好的监听方法
listener.childEvent(client, event);
然后看到前面CuratorFramework还调用了processEvent，继续查到里面是调用CuratorListener，
我们事先并没有注册任何CuratorListener，而是调用的PathChildrenCacheListener，所以这个processEvent这里没有起到任何作用；</p> <h1 id="深入解读"><a href="#深入解读" class="header-anchor">#</a> 深入解读</h1> <p>https://cwiki.apache.org/confluence/display/ZOOKEEPER/ZooKeeperPresentations
Sometimes developers mistakenly assume one other guarantee that ZooKeeper does not in fact make. This is: * Simultaneously Consistent Cross-Client Views* : ZooKeeper does not guarantee that at every instance in time, two different clients will have identical views of ZooKeeper data. Due to factors like network delays, one client may perform an update before another client gets notified of the change. Consider the scenario of two clients, A and B. If client A sets the value of a znode /a from 0 to 1, then tells client B to read /a, client B may read the old value of 0, depending on which server it is connected to. If it is important that Client A and Client B read the same value, Client B should should call the sync() method from the ZooKeeper API method before it performs its read. So, ZooKeeper by itself doesn't guarantee that changes occur synchronously across all servers, but ZooKeeper primitives can be used to construct higher level functions that provide useful client synchronization. (For more information, see the ZooKeeper Recipes. [tbd:..]).</p> <p>CAP理论，zookeeper是CP模型，保证<a href="https://stackoverflow.com/questions/37399722/why-is-this-output-wrong-sequential-consistency" target="_blank" rel="noopener noreferrer">sequential consistency<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，
比eventual consistency强一些，但是不是strong consistency，因为我们前面说了，zookeeper是采用推拉模式，
所以每个客户端看的的view都可能由于网络的原因不一样，
<a href="https://stackoverflow.com/questions/35387774/is-zookeeper-always-consistent-in-terms-of-cap-theorem" target="_blank" rel="noopener noreferrer">Zookeeper is not A, and can't drop P. So it's called CP apparently. In terms of CAP theorem, &quot;C&quot; actually means linearizability.But, Zookeeper has Sequential Consistency - Updates from a client will be applied in the order that they were sent.<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>然后又由于zookeeper是基于CP模型，所以有人提出：
zookeeper 的 CP 模型不适合注册中心
https://segmentfault.com/a/1190000021356988</p> <p>丢失watcher的原因：</p> <p>//连续修改会‘丢失’nodeChanged event的原因是，每次获取到nodechanged之后curator的nodecache实际上还要再次重设watch，因为watch是一次性的；
//客户端set 111 , 服务端处理set
//客户端注册watch，服务端注册watch
//客户端set 222， 服务端处理set，服务端刚才的watch刚注册好
//客户端注册watch，服务端通知client端变化
//客户端set 333， 服务端处理set
//客户端收到变化通知打印，然后还要去服务端拉取，此时最新值是333
//但是实际上setDAta应该都是成功的，因为zookeeper是顺序处理
client.setData().forPath(nodePath, &quot;111&quot;.getBytes());
client.setData().forPath(nodePath, &quot;222&quot;.getBytes());</p> <p>所以要用对zookeeper还是要学习下其他产品，比如：
<a href="https://mp.weixin.qq.com/s?__biz=MzA4Nzc4MjI4MQ==&amp;mid=2652403267&amp;idx=1&amp;sn=9c79bde74e86cf10ac85ec7d4b53a4dc&amp;chksm=8bd8f0a5bcaf79b3026777f9d7a564df56ef5086b13f502410204592ad45022682fba326682f&amp;token=1143895172&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">kafka 中 zookeeper 具体是做什么的？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>ref：
https://www.cnblogs.com/duanxz/p/3783266.html</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/docs/assets/js/app.ee9227dc.js" defer></script><script src="/docs/assets/js/2.5d2fca3b.js" defer></script><script src="/docs/assets/js/19.16387e1f.js" defer></script>
  </body>
</html>
