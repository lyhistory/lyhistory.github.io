(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{287:function(e,t,n){"use strict";n.r(t);var o=n(0),i=Object(o.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"oauth2-using-dotnetopenauth"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#oauth2-using-dotnetopenauth"}},[e._v("#")]),e._v(" OAuth2 using DotNetOpenAuth")]),e._v(" "),n("p",[e._v("Start by Example of Communication through RSA")]),e._v(" "),n("p",[e._v("Client/Hacker1: HI\nServer/Hacker2: Hi,I am server,( server send digital certificate)\nClient: (Action:Validate the certificate and got the public key[2048Bits],confirmed and then send random string *** to Server,Hacker2 failed)\n//Hacker1: (Action: send a simple string to server like 123456)\nServer: (Action: Calculated hash of the string,encrypt with private key, send message to Client/Hacker1)\nClient: (Action: decrypt message with public key and equal to hash(***), confirmed, Hacker1 failed)\n{ok, let's communicate with my Symmetric-key algorithm.}\n(Send the algorithm and key encrypt with public key)\nServer: <Symmetric-key&algorithm>{Ok,what I can do for you}\nClient: <Symmetric-key&algorithm>{I wanna check my bank balance}\n..................\n上面描述了HTTPS通信握手的过程，简短描述就是：\n1.浏览器发出https请求\n2.服务器回应发送包含公钥的证书（由CA颁发）\n3.浏览器生成随机密钥，并用公钥加密，发送给服务器\n4.服务器用私钥解密获取随机密钥\nBrowser connects to a web server (website) secured with SSL (https). Browser requests that the server identify itself.\nServer sends a copy of its SSL Certificate, including the server’s public key.\nBrowser checks the certificate root against a list of trusted CAs and that the certificate is unexpired, unrevoked, and that its common name is valid for the website that it is connecting to. If the browser trusts the certificate, it creates, encrypts, and sends back a symmetric session key using the server’s public key.\nServer decrypts the symmetric session key using its private key and sends back an acknowledgement encrypted with the session key to start the encrypted session.\nServer and Browser now encrypt all transmitted data with the session key.\nOAUTH2 flow")]),e._v(" "),n("p",[n("img",{attrs:{src:"/docs/docs_image/software/programming/auth01.png",alt:""}})]),e._v(" "),n("p",[e._v("What Is SSL (Secure Sockets Layer) and What Are SSL Certificates?\nhttps://www.digicert.com/ssl.htm")]),e._v(" "),n("h3",{attrs:{id:"_1-1-install-certificates"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-install-certificates"}},[e._v("#")]),e._v(" 1.1 install certificates")]),e._v(" "),n("p",[e._v("open visual studio developer command prompt, and run command\nmakecert.exe -sr LocalMachine -ss My -a sha1 -n CN=AuthSrv -sky exchange -pe\nmakecert.exe -sr LocalMachine -ss My -a sha1 -n CN=ResSrv -sky exchange -pe")]),e._v(" "),n("p",[e._v("Attention:\nhere this two digital certification is not for https or SSL, is only for OAuth2 token encryption,\nfor https https://sg.godaddy.com/help/request-an-ssl-certificate-562\nrelation between Oauth2 and https:\nSecurity considerations")]),e._v(" "),n("p",[e._v("The OAuth2 protocol does not guarantee confidentiality and integrity of communications. That means you must protect HTTP communications using an additional layer. One possible solution is the usage of SSL/TLS (HTTPS) to encrypt the communication channel from the client to the server.\nThe first version of OAuth (OAuth1) supported an authentication mechanism based on the HMAC algorithm to guarantee confidentiality and integrity; OAuth2 does not (although a Draft proposal exists to support MAC tokens). The lack of message hashing is the primary concern raised regarding the security of OAuth2, and the one most developers complain about (e.g. this blog post by Eran Hammer, the ex-lead of the OAuth specifications).\nIn a nutshell, always use HTTPS for OAuth2, as it's the only way to guarantee message confidentiality and integrity with this protocol!")]),e._v(" "),n("p",[n("img",{attrs:{src:"/docs/docs_image/software/programming/auth02.png",alt:""}})]),e._v(" "),n("h3",{attrs:{id:"_1-2-grant-full-control-of-certificates-to-iis-iusrs"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-grant-full-control-of-certificates-to-iis-iusrs"}},[e._v("#")]),e._v(" 1.2.grant full control of certificates to iis_iusrs")]),e._v(" "),n("p",[n("img",{attrs:{src:"/docs/docs_image/software/programming/auth03.png",alt:""}})]),e._v(" "),n("p",[e._v("then right click, select All Tasks/Manage Private Keys/Add/Advanced/Find Now,select IIS_IUSRS(if you can not find,look up and confirm your Locations, make sure it's under your own PC)\nBe aware, this is to demonstrate oauth2 on iis, in practice, Auth Server holds Auth Key pair(public&private key)+ResSrv(public key), Res Server holds Res Key pair(public&private key)+AuthSrv(public key), that's\nmake it RSA, but actually this two server don't communicate with each other directly, Client will request access token from Auth Server, and then send request to Resource Server,Resource Server decrypt user info by authsrv public key.")]),e._v(" "),n("p",[e._v("assumption : user agent(browser), client web site cl.com and Client app, oauth server web site srv.com, api web site: api.com,in this scenario,api web site is actually the resource server\nuser visit client site and  oauth login on srv.com, client site server can get access api site to retrieve data\noauth server code:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('oauth2.class\n[CustomizeAuthorize, HttpGet]\n[HttpHeader("X-Frame-Options", "SAMEORIGIN")]\npublic ActionResult Index(){//Authorize Page 授权页面\nvar pendingRequest = AuthorizationServer.ReadAuthorizationRequest(); //generate Code\npendingRequest.ExtraData["User"] = this.User.Identity.Name;\nif (((OAuthServerHost)this.authorizationServer.AuthorizationServerServices).CanBeAutoApproved(pendingRequest))\n{\nvar approval = this.authorizationServer.PrepareApproveAuthorizationRequest(pendingRequest, this.User.Identity.Name);\nvar response = this.authorizationServer.Channel.PrepareResponse(approval);\nreturn response.AsActionResult();\n}\nvar client = DB.Instance.GetClient(pendingRequest.ClientIdentifier);\nvar model = new OAuthViewModel\n{\nAppKey = pendingRequest.ClientIdentifier,\nAppName = client.Name,\nScope = pendingRequest.Scope,\nResponseType = pendingRequest.ResponseType == EndUserAuthorizationResponseType.AccessToken ? "token" : "code",\nRedirect = pendingRequest.Callback.AbsoluteUri,\nState = pendingRequest.ClientState\n};\nreturn View(model);\n}\n[CustomAuthorize, HttpPost]\n\npublic ActionResult Index(bool approve)\n{\nvar pendingRequest = this.authorizationServer.ReadAuthorizationRequest(); //will use Code and models\nIProtocolMessage responseMessage = null;\nif (approve)\n{\nDB.Instance.AddAuthorization(new ClientAuthorization\n{\nClientIdentifier = pendingRequest.ClientIdentifier,\nScope = pendingRequest.Scope,\nOpenId = this.User.Identity.Name,\nIssueDate = DateTime.UtcNow\n});\nresponseMessage = this.authorizationServer.PrepareApproveAuthorizationRequest(pendingRequest, this.User.Identity.Name, pendingRequest.Scope); // change response to 302 redirect,redirect url is in pendingRequest\n}\nelse\n{\nresponseMessage = this.authorizationServer.PrepareRejectAuthorizationRequest(pendingRequest);\n}\nvar response = this.authorizationServer.Channel.PrepareResponse(responseMessage);\nreturn response.AsActionResult();\n}\n[AcceptVerbs(HttpVerbs.Get | HttpVerbs.Post)]\npublic ActionResult Token()\n{\nreturn this.authorizationServer.HandleTokenRequest(this.Request).AsActionResult();\n}\nCustomizeAuthorize.class :AuthorizeAttribute\noverride bool AuthorizeCore(HttpContextBase httpContext){\n//check HttpContext.Request.IsAuthenticated\n//sometimes can check session also(set identity if session exists)\n}\noverride void HandleUnauthorizedRequest(AuthorizationContext filterContext)\n\n')])])]),n("p",[e._v("according to The OAuth 2.0 Authorization Framework\nAuthorization Grant ........................................8\n1.3.1. Authorization Code ..................................8\n1.3.2. Implicit ............................................8\n1.3.3. Resource Owner Password Credentials .................9\n1.3.4. Client Credentials ..................................9")]),e._v(" "),n("h2",{attrs:{id:"type-1-authorization-code"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#type-1-authorization-code"}},[e._v("#")]),e._v(" Type 1: Authorization Code:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('client Code:\nprivate readonly WebServerClient client;\nprivate readonly static AuthorizationServerDescription authServerDesc = new AuthorizationServerDescription()\n{\nTokenEndpoint = new Uri(TOKEN_ENDPOINT),\nAuthorizationEndpoint = new Uri(AUTHZ_ENDPOINT),\nProtocolVersion = ProtocolVersion.V20\n};\nclient = new WebServerClient(authServerDesc, clientId);\n[HttpGet]\npublic ActionResult Index()\n{\nclient.RequestUserAuthorization(new[] { "" }, new Uri(Url.Action("login", "home", null, this.Request.Url.Scheme)));\nreturn new EmptyResult();\n}\n[HttpGet]\npublic async Task Login()\n{\nclient.ClientCredentialApplicator = ClientCredentialApplicator.PostParameter(clientSecret);\nvar authorization = client.ProcessUserAuthorization();//wait for token generated by oauthServer\nif (authorization != null)\n{\nif (authorization.AccessTokenExpirationUtc.HasValue)\n{\nclient.RefreshAuthorization(authorization, TimeSpan.FromSeconds(30));\n}\nstring token = authorization.AccessToken;\nstring scope = "user_name,nick_name,avatar_url";\nusing (var httpClient = new ApiHttpClient(token))\n{\nvar content = new StringContent(JsonConvert.SerializeObject(new { user_scope = scope }), Encoding.UTF8, "application/json");\n//// setting for https only\n//System.Net.ServicePointManager.ServerCertificateValidationCallback += (sender, certificate, chain, errors) => true;\nvar apiResponse = await httpClient.PostAsync(ApiEndPoint, content);\nif (apiResponse.IsSuccessStatusCode)\n{\nreturn new WrapperHttpResponseMessageResult(apiResponse);\n}\nreturn Content("call api failed");\n}\n}\nreturn Content("authorize failed");\n}\npublic class ApiHttpClient : HttpClient\n{\npublic ApiHttpClient(string accessToken)\n: base(new ApiMessageHandler(accessToken))\n{ }\nclass ApiMessageHandler : MessageProcessingHandler\n{\nstring accessToken;\npublic ApiMessageHandler(string accessToken)\n: base(new HttpClientHandler())\n{\nthis.accessToken = accessToken;\n}\nprotected override HttpRequestMessage ProcessRequest(HttpRequestMessage request, CancellationToken cancellationToken)\n{\nrequest.Headers.Authorization = new AuthenticationHeaderValue("Bearer", this.accessToken);\nreturn request;\n}\nprotected override HttpResponseMessage ProcessResponse(HttpResponseMessage response, CancellationToken cancellationToken)\n{\nreturn response;\n}\n}\n}\n\n')])])]),n("h2",{attrs:{id:"request-capturing-analysis"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#request-capturing-analysis"}},[e._v("#")]),e._v(" Request capturing analysis")]),e._v(" "),n("p",[e._v('1.cl.com/home/login\n2.srv.com/oauth2?response_type=code&client_id=123456&redirect_uri=http:%2F%2Fcl.com%2Fhome%2Flogin&scope=\nrun CustomizeAuthorize, if not login yet(AuthorizeCore) will kick to (HandleUnauthorizedRequest)\n3.srv.com/home/login?customizeReturnUrl=%2Foauth2%3Fresponse_type%3Dcode%26client_id%3D123456%26redirect_uri%3Dhttp%3A%252F%252Fcl.com%252Fhome%252Flogin%26scope%3D\nat this point, you need to log return url for later redirection after successfully login.\nthen post to login, success then redirect to customizeReturnUrl,\nrun CustomizeAuthorize again,then enter action Index continue previous request\n4.srv.com/oauth2?response_type=code&client_id=123456&redirect_uri=http:%2F%2Fcl.com%2Fhome%2Flogin&scope=\nfirst time will show Authorization Page(render with\n@using (Html.BeginForm())\n{\n@Html.Hidden("client_id", this.Model.AppKey)\n@Html.Hidden("redirect_uri", this.Model.Redirect)\n@Html.Hidden("state", this.Model.State)\n@Html.Hidden("scope", DotNetOpenAuth.OAuth2.OAuthUtilities.JoinScopes(this.Model.Scope))\n@Html.Hidden("response_type", this.Model.ResponseType)\n@Html.Hidden("approve", true)\n'),n("button",{staticClass:"btn1",attrs:{type:"submit"}},[e._v("Authorize Now")]),e._v("\n}\n) , when you click button 'Authorize Now',will post data back to oauth2/index?approve=true,after this redirect to original url:\n5.cl.com/home/login?code=*******\nnow, client side start to post Client Secrect\nclient.ClientCredentialApplicator = ClientCredentialApplicator.PostParameter(clientSecret);\nvar authorization = client.ProcessUserAuthorization();[server side will check secrect and create token]\nsuccessfully!!!")]),e._v(" "),n("h2",{attrs:{id:"way-2-client-credentials-app-level-oauth"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#way-2-client-credentials-app-level-oauth"}},[e._v("#")]),e._v(" Way 2: Client Credentials: app level oauth")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('public async Task AppClient()\n{\nvar token = await GetToken();\nstring result = String.Empty;\nusing (var apiHttpClient = new ApiHttpClient(token))\n{\n//// setting for https only\n//System.Net.ServicePointManager.ServerCertificateValidationCallback += (sender, certificate, chain, errors) => true;\nvar content = new StringContent("{\\"param_key\\":\\"param_value\\"}", Encoding.UTF8, "application/json");\nvar apiResponse = apiHttpClient.PostAsync(APIEndPoint, content).Result;\nif (apiResponse.IsSuccessStatusCode)\n{\nresult = apiResponse.Content.ReadAsStringAsync().Result;\nreturn Content(result);\n}\nreturn Content("failed: " + apiResponse.StatusCode.ToString());\n}\n}\nprivate async Task GetToken()\n{\nusing (var httpClient = new OAuthHttpClient(clientId, clientSecret))\n{\nvar content = new FormUrlEncodedContent(new Dictionary<string, string>\n{\n{"grant_type", "client_credentials"}\n});\nvar response = await httpClient.PostAsync(TOKEN_ENDPOINT, content);\nvar responseContent = await response.Content.ReadAsStringAsync();\nif (response.StatusCode == System.Net.HttpStatusCode.OK)\n{\nreturn JObject.Parse(responseContent)["access_token"].ToString();\n}\nreturn responseContent.ToString();\n}\n}\n\n')])])]),n("p",[e._v("Case Study:\noauth2 server implementation interactive with third party oauth login")]),e._v(" "),n("p",[n("img",{attrs:{src:"/docs/docs_image/software/programming/auth04.png",alt:""}})]),e._v(" "),n("p",[e._v("协议：")]),e._v(" "),n("p",[e._v("The OAuth 2.0 Authorization Framework\nhttp://tools.ietf.org/html/rfc6749")]),e._v(" "),n("p",[e._v("参考书籍：\nPro ASP.NET Web API Security.pdf\nASP.NET Identity\n参考阅读：\nhttp://bitoftech.net/2014/09/24/decouple-owin-authorization-server-resource-server-oauth-2-0-web-api/")]),e._v(" "),n("p",[e._v("Security and cryptography\nhttp://dotnetcodr.com/security-and-cryptography/")]),e._v(" "),n("p",[e._v("Makecert.exe（证书创建工具）\nhttp://msdn.microsoft.com/zh-cn/library/bfsktky3(v=vs.110).aspx")]),e._v(" "),n("p",[e._v("IIS中的SSL Certificate 证书配置\nhttp://www.cnblogs.com/chyspace/archive/2011/02/17/1957326.html")]),e._v(" "),n("p",[e._v("DotNetOpenAuth\nhttp://www.cnblogs.com/chyspace/archive/2011/02/17/1957326.html")]),e._v(" "),n("p",[e._v("Real World OAuth using ASP.NET MVC\nhttp://www.dotnetcurry.com/showarticle.aspx?ID=907")]),e._v(" "),n("p",[e._v("ASP.NET MVC 中实现真实世界中的 OAuth 身份认证\nhttp://www.oschina.net/translate/real-world-oauth-using-aspnet-mvc?cmp&p=2")]),e._v(" "),n("p",[e._v("用DotNetOpenAuth实现基于OAuth 2.0的web api授权\nhttp://www.cnblogs.com/fengwenit/p/3542566.html")]),e._v(" "),n("p",[e._v("使用DotNetOpenAuth搭建OAuth2.0授权框架\nhttp://www.cnblogs.com/newton/p/3409984.html")]),e._v(" "),n("p",[e._v("各种语言实现的oauth认证\nhttp://www.supesoft.com/News_Disp.asp?ID=4926")]),e._v(" "),n("p",[e._v("Asp.Net MVC 4 Web API 中的安全认证-使用OAuth\nhttp://www.supesoft.com/News_Disp.asp?ID=4926")]),e._v(" "),n("p",[e._v("[OAuth]基于DotNetOpenAuth实现Client Credentials Grant\nhttp://www.cnblogs.com/dudu/p/oauth-dotnetopenauth-client-credentials-grant.html")]),e._v(" "),n("p",[e._v("扩展阅读：")]),e._v(" "),n("p",[e._v("数字证书原理\nhttp://www.cnblogs.com/jeffreysun/archive/2010/06/24/1627247.html\n网上银行安全证书工作原理\nhttp://lordecho.wordpress.com/2009/02/17/%E7%BD%91%E4%B8%8A%E9%93%B6%E8%A1%8C%E5%AE%89%E5%85%A8%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/")]),e._v(" "),n("p",[e._v("WCF开发框架之证书加密使用说明书\nhttp://www.cnblogs.com/wuhuacong/archive/2012/07/09/2582297.html")]),e._v(" "),n("p",[e._v("OAuth 2.0 (without Signatures) is Bad for the Web\nhttp://hueniverse.com/2010/09/15/oauth-2-0-without-signatures-is-bad-for-the-web/")]),e._v(" "),n("h2",{attrs:{id:"auth-flow"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#auth-flow"}},[e._v("#")]),e._v(" AUTH flow:")]),e._v(" "),n("p",[e._v("https://b.zmxy.com.cn/technology/openDoc.htm?relInfo=zhima.auth.info.authorize@1.0@1.3\nhttp://open.taobao.com/docs/doc.htm?articleId=102635&docType=1&treeId=1\nhttp://open.taobao.com/docs/doc.htm?spm=a219a.7629140.0.0.4PMVGd&treeId=12&articleId=105590&docType=1\nhttp://www.junge85.com/post/859.html\n淘宝OAuth2.0服务 http://www.ganzhishi.com/txt.asp?id=1305\nOAuth2.0 用户验证授权标准 理解 www.cnblogs.com/hilow/p/3826425.html")]),e._v(" "),n("p",[e._v("todo:")]),e._v(" "),n("p",[e._v('https://tools.ietf.org/html/rfc2617\nDigest access authentication\nhttps://www.quora.com/What-is-the-difference-between-Basic-Auth-Digest-Auth-oAuth1-0-and-oAuth2-0-What-is-an-example-of-each-in-core-PHP\nconsideration: grant type? store?\nfull flow (username password ): http://bitoftech.net/2014/07/16/enable-oauth-refresh-tokens-angularjs-app-using-asp-net-web-api-2-owin/\n一个很重要的坑！Oauth2 with Angular: The right way https://jeremymarc.github.io/2014/08/14/oauth2-with-angular-the-right-way\nEnable OAuth Refresh Tokens in AngularJS App using ASP .NET Web API 2, and Owin  bitoftech.net/2014/07/16/enable-oauth-refresh-tokens-angularjs-app-using-asp-net-web-api-2-owin/\nsso, oauth2, identity\nhttps://tools.ietf.org/pdf/rfc6749.pdf  and  http://self-issued.info/docs/draft-ietf-oauth-v2-bearer.html\nhttp://bchavez.bitarmory.com/archive/2015/07/19/asp-net-identity-oauth-2-social-login-web-api-2.aspx\noatuh -- openid http://softwareas.com/oauth-openid-youre-barking-up-the-wrong-tree-if-you-think-theyre-the-same-thing/\nrefresh token - https://github.com/openid/AppAuth-Android/issues/178\nOAuth 2.0 is an Authorization protocol. The idea behind OAuth is that you (the resource owner) can delegate access privileges to a third-party. An example is a Web app being able to post on your Facebook wall for you. Again, in very simplistic terms, this materializes by sending a 302 redirect to the user when she accesses a protected resource. That 302 redirects the user, for example to Facebook\'s oauth login page (https://www.facebook.com/dialog/oauth?client_id=...&redirect_url=[yourwebapp]&scope=[permissionsrequiredfromuser]). After you login to facebook, accept the permission request, facebook will send a 302 redirect to the redirect_url you provided with an access_token that you can then use to send requests on behalf of the user that provided the credentials. For example, to get information about the user you\'d perform a request to https://graph.facebook.com/me?access_token=[access_token]. There are variations for this workflow. They are all explained in the links at the end of the answer.\nOpenDotNetAuth\nhttps://github.com/DotNetOpenAuth/DotNetOpenAuth\nhttps://github.com/DotNetOpenAuth/DotNetOpenAuth/wiki/Security-scenarios\nhttps://gitter.im/DotNetOpenAuth/DotNetOpenAuth\nhttps://geektalk.info/question/16855131/dotnetopenauth-openid-flow-w-own-auth-server\nASP.NET Identity has nothing to do with ASP.NET. Talk about poor naming... It provides functionality to save and retrieve user\'s data from a data source. It also provides you with the ability to associate claims and roles to the users, other "login providers" (that would be the case when you "login with facebook" and your user_id from facebook gets associated with your local user id, this information is stored in the AspNetUserLogins table).The way you see it being used in the MVC project template is in the Account controller and the CookieAuthenticationMiddleware.\nForm Authenciation -> Membership -> Identity (ASP.NET https://docs.microsoft.com/en-us/aspnet/identity/overview/getting-started/introduction-to-aspnet-identity)\nhttp://www.techstrikers.com/Articles/understanding-asp.net-identity.php\nhttps://forums.asp.net/t/2014967.aspx?What+is+the+difference+between+form+authentication+Membership+API+and+newly+introduce+Identity\nhttp://jlabusch.github.io/oauth2-server/\nhttps://brockallen.com/2013/10/20/the-good-the-bad-and-the-ugly-of-asp-net-identity/#missingdata\nScenario :\nhttp://www.nakov.com/blog/2014/12/22/webapi-owin-identity-custom-login-service/')]),e._v(" "),n("p",[e._v('Terminology:\nToken Based vs Cookie Based:\nAuthentication: Cookies vs JWTs and why you’re doing it wrong https://www.slideshare.net/derekperkins/authentication-cookies-vs-jwts-and-why-youre-doing-it-wrong\nhttps://docs.google.com/drawings/d/1wtiF_UK2e4sZVorvfBUZh2UCaZq9sTCGoaDojSdwp7I/edit\nhttps://auth0.com/blog/cookies-vs-tokens-definitive-guide/\nClaim based: http://stackoverflow.com/questions/6786887/explain-claims-based-authentication-to-a-5-year-old\nToken authentication\nRequest to server is signed by "token" - usually it means setting specific http header, however they can be send in any part of http request (POST body, etc.)\nPros:\nYou can authorize only the request you wish to authorize (cookies - even the authorization cookie are send for every single request)\nImmune to XSRF (short example of XSRF - I\'ll send you a link in email that will look like '),n("img",{attrs:{src:"http://bank.com?withdraw=1000&to=myself"}}),e._v(" and if you're logged in via cookie authentication to bank.com and bank.com doesn't have any means of XSRF protection I'll withdraw money from your account simply by the fact that your browser will trigger authorized get request to that url). Note there are anti forgery measure you can do with cookie-based authentication - but you have to implement those.\nCookies are bound to single domain. Cookie created on domain foo.com can't be read by domain bar.com, while you can send token to any domain you like. This is especially useful for single page applications that are consuming multiple services that are requiring authorization - so I can have web app on domain myapp.com that can make authorized client-side requests to myservice1.com and to myservice2.com.\nCons:\nYou have to store token somewhere; while cookies are stored \"out of the box\", the location that comes to mind is localStorage (con: the token is persisted even after you close browser window), sessionStorage (pro: the token is discarded after you close browser window, con: opening new tab (ctrl+click) will render that tab anonymous) and cookies (pro: the token is discarded after you close browser window (that is if you'll use session cookie), you will be authenticated in tab opened by ctrl+click, you're immune to XSRF since you're ignoring cookie for authentication, you just use it as token storage, con: cookies are send out for every single request, if this cookie is not marked as https only you're open to man in the middle attack)\nIt is slightly easier to do XSS attack against token based authentication (i.e. if I'm able to run injected script on your site I can stole your token; however cookie based authentication is not a silver bullet either - while cookies marked as http-only can't be read by client, client can still make request on your behalf that will automatically include the authorization cookie)\nRequest for download a file, that is supposed to work only for authorized users requires you to use File API, the same request works out of the box for cookie-based authentication\nCookie authentication\nRequest to server is always signed in by authorization cookie\nPros:\nCookie can be marked as \"http-only\" which makes them impossible to be read on client side, this is better for XSS-attack protection\nCame out of the box - you don't have to implement any code on client side\nCons:\nBound to single domain (so if you have single page application that makes requests to multiple services you can end up doing crazy stuff like reverse proxy)\nVulnerable to XSRF, you have to implement extra measures to make your site protected against cross site request forgery\nAre send out for every single request (even for request that doesn't require authentication)\nOverall I'd say tokens give you better flexibility (you're not bound to single domain), downside is you have to do quite some coding by yourself.\n--http://stackoverflow.com/questions/17000835/token-authentication-vs-cookies")]),e._v(" "),n("p",[e._v("jwt https://jwt.io/")])])}),[],!1,null,null,null);t.default=i.exports}}]);