(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{214:function(e,r,o){"use strict";o.r(r);var t=o(0),a=Object(t.a)({},(function(){var e=this,r=e.$createElement,o=e._self._c||r;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h2",{attrs:{id:"_1-关于一致性"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-关于一致性"}},[e._v("#")]),e._v(" 1.关于一致性")]),e._v(" "),o("p",[e._v("基本可以分为两大类：")]),e._v(" "),o("blockquote",[o("p",[e._v("最终一致性 eventual consistent，代表协议如gossip/multicast protocols，redis集群就是采用gossip")])]),e._v(" "),o("blockquote",[o("p",[e._v("共识算法一致性 consensus protocols，代表协议有 PBFT, RAFT, 经典的比特币共识算法nakamoto consensus等")])]),e._v(" "),o("p",[e._v("The former includes things like epidemic broadcast trees, bimodal multicast, SWIM, HyParView, and NeEM. These tend to be eventually consistent and/or stochastic.\nThe latter, which I’ve described in more detail here, includes 2PC/3PC, Paxos, Raft, Zab, and chain replication. These tend to favor strong consistency over availability.\nhttps://bravenewgeek.com/tag/leader-election/")]),e._v(" "),o("h2",{attrs:{id:"_2-从中心化到去中心化"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-从中心化到去中心化"}},[e._v("#")]),e._v(" 2.从中心化到去中心化")]),e._v(" "),o("p",[e._v("中心化系统有单点故障的风险，所以引入多个节点，但是多个节点之间如何保持数据同步，基于一致性算法有两种思路：")]),e._v(" "),o("blockquote",[o("p",[e._v("1.最直接的办法是动态选出一个leader，只由leader单节点负责管理竞争资源，然后其他节点作为follower保存副本，当leader发生故障，重新从follower中选举新的leader，从而既避免了单点故障又保持了数据一致")])]),e._v(" "),o("blockquote",[o("p",[e._v("2.节点之间通过共识算法保持数据同步，这是个经典的拜占庭将军问题，经典的共识算法是BFT拜占庭共识算法")])]),e._v(" "),o("h3",{attrs:{id:"_1-1-分布式产品和zookeeper"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-分布式产品和zookeeper"}},[e._v("#")]),e._v(" 1.1.分布式产品和zookeeper")]),e._v(" "),o("blockquote",[o("p",[e._v("分布式产品")])]),e._v(" "),o("blockquote",[o("p",[e._v("分布式服务框架 zookeeper的ZAP协议")])]),e._v(" "),o("blockquote",[o("p",[e._v("分布式消息队列集群Kafka")])]),e._v(" "),o("blockquote",[o("p",[e._v("分布式实时计算storm以及Hadoop mapreduce2.0")])]),e._v(" "),o("blockquote",[o("p",[e._v("分布式存储系统：hbase基于zookeeper, 而ETCD采用RAFT协议 https://raft.github.io/")])]),e._v(" "),o("blockquote",[o("p",[e._v("分布式任务调度")])]),e._v(" "),o("p",[e._v("可以看几个产品的架构图\n"),o("img",{attrs:{src:"/docs_image/software/distrubuted_system1.png",alt:"Kafka"}}),e._v(" "),o("img",{attrs:{src:"/docs_image/software/distrubuted_system2.png",alt:"HDFS"}}),e._v(" "),o("img",{attrs:{src:"/docs_image/software/distrubuted_system3.png",alt:"HADOOP"}})]),e._v(" "),o("p",[e._v("Since Hadoop 2.0, ZooKeeper has become an essential service for Hadoop clusters, providing a mechanism for enabling high-availability of former single points of failure, specifically the HDFS NameNode and YARN ResourceManager.\nhttps://www.datadoghq.com/blog/hadoop-architecture-overview/")]),e._v(" "),o("p",[e._v("观察可以发现一个问题，为啥大部分都需要依赖分布式框架zookeeper？？")]),e._v(" "),o("p",[e._v("简单来说，不要重复造轮子，zookeeper可以用于集群管理，只不过有些可以脱离zookeeper单机部署，有些则是只支持集群模式，跟zookeeper耦合紧密，当然我们谈的是分布式系统，所以这里不讨论单机版本")]),e._v(" "),o("p",[e._v("举一个例子：")]),e._v(" "),o("p",[o("img",{attrs:{src:"/docs_image/software/distrubuted_system4.png",alt:"分布式管理例子"}}),e._v("\n中央就是zookeeper，本身是集群，政治协商，一个挂掉还会迅速选一个，中央的主要工作是做集群管理，具体的生产生活还要交由Apache/Storm这些地方政府节点来做，\n地方节点之间也是一个集群，比如分布式商务系统集群（商务部是集群的leader，向中央注册），分布式农业系统集群等")]),e._v(" "),o("p",[e._v("Zookeeper适用的场景：\nhttps://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/index.html")]),e._v(" "),o("blockquote",[o("p",[e._v("统一命名服务（Name Service）")])]),e._v(" "),o("blockquote",[o("p",[e._v("配置管理（Configuration Management）")])]),e._v(" "),o("blockquote",[o("p",[e._v("集群管理（Group Membership）")])]),e._v(" "),o("blockquote",[o("p",[e._v("共享锁（Locks）：共享锁在同一个进程中很容易实现，但是在跨进程或者在不同 Server 之间就不好实现了")])]),e._v(" "),o("h3",{attrs:{id:"_1-2-build-distributed-system-from-scratch"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-build-distributed-system-from-scratch"}},[e._v("#")]),e._v(" 1.2.Build distributed system from scratch")]),e._v(" "),o("p",[e._v("假设我们需要创建一个分布式任务调度，当然是从零开始，不采用市面上的分布式任务调度产品，假设这些任务存在数据库")]),e._v(" "),o("p",[e._v("首先我们肯定需要一些干活的workers，负责执行具体任务，想象一下我们创建了一个java程序执行具体的任务逻辑；")]),e._v(" "),o("p",[e._v("由于正常情况下一般除非是定制了class loader否则一个java程序是跑在一个单独的jvm实例当中，\n所以分布式部署的情况下，每个worker都在一个独立的jvm实例中，部署在多台机器上，多个互相独立的jvm实例之间需要协商分配这些任务，\n同时去读写数据库的任务列表很容易造成冲突，显然如果我们不采用共识算法，处理起来会毫无头绪，\n最直接简单的想法就是从中找一个特别的worker作为leader来做这个分配，这里就引入了zookeeper，\n你可能会说不引入zookeeper，自己写一个单独的leader程序不行吗，确实可以，不过leader程序也要做成集群式的，不可以引入单点故障，\n所以为了简单，直接让这些workers都注册zookeeper，不同的java程序微服务之间通过zookeeper的observer监听模式实现同步节点信息，\n这样每个worker都可以保存一份同步的worker list，怎么从worker list中选出一个leader呢，两个思路：")]),e._v(" "),o("blockquote",[o("p",[e._v("可以简单设计一些规则来实现选举，比如通过配置文件定义好是否是leader候选人，然后选的时候就通过排序找到第一个活着的候选人即可；")])]),e._v(" "),o("blockquote",[o("p",[e._v("通过curator高级API利用zookeeper的共享锁机制自动做的leader选举，take leadership的方式，默认都是普通worker，在take leadership的时候激活为leader，\n不过这种方式有个缺点，其他普通的worker无法得知选举结果，所以在某些场景下，当worker需要向leader汇报情况的时候就做不了了，除非没有这种需求；")])]),e._v(" "),o("p",[e._v("现在还没有结束，现在有了动态选举的leader和一群worker，leader要怎么分发任务给worker，他们是互不想干的独立进程，可能部署在不同的机器上，通过zookeeper吗？\nzookeeper只支持最简单的推拉消息，每次节点注册时，只会通知各节点有nodechange事件，各节点自行去zookeeper pull拉取具体变化信息，\n所以我们无法通过zookeeper实现worker及leader节点之间的要求，这里就引入了rpc通信协议，相比较基于HTTP的web service，基于TCP的rpc性能更优，然后结合proxy代理模式对调用方法接口进行封装，\n可以让微服务在调用远程方法的时候就像调用自身方法一样透明。\n然后因为所有worker及leader节点都保存了一份节点列表，所以leader分发任务的时候就可以采取一定的策略，比如round robin或load balance方式rpc调用worker分发任务；\n至于worker节点，虽然也保存了一份节点列表但一般只需要跟leader通信，当然如果leader挂掉，worker变成leader还是要用这个列表的；")]),e._v(" "),o("p",[o("img",{attrs:{src:"/docs_image/software/distrubuted_system5.png",alt:"分布式任务调度"}})]),e._v(" "),o("p",[e._v("还需要思考的问题：")]),e._v(" "),o("blockquote",[o("p",[e._v("如何保证leader选举的唯一性，即保证不选出多个leader")])]),e._v(" "),o("blockquote",[o("p",[e._v("如何在leader宕机的瞬间保持数据不丢失，新leader如何恢复旧leader宕机之前的状态")])]),e._v(" "),o("h2",{attrs:{id:"_3-from-distributed-system-to-distributed-ledger"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_3-from-distributed-system-to-distributed-ledger"}},[e._v("#")]),e._v(" 3.From distributed system to distributed ledger")]),e._v(" "),o("p",[o("img",{attrs:{src:"/docs_image/software/distrubuted_system6.png",alt:"网络类型"}})]),e._v(" "),o("p",[e._v("我们前面谈到的分布式系统都不是不是真正的分布式，只能算是多中心的系统，zookeeper也不是真正的分布式框架，因为其本身集群也是有leader和follower的，\n所以基于zookeeper的分布式系统更会不是真的分布式，只有是基于共识算法实现的系统才有可能是真正的分布式系统；")]),e._v(" "),o("p",[e._v("谈到去中心化，分布式，最广为人知的就是区块链，区块链技术，又被称作DLT，Distributed Ledger Technology，区块链大致分为permissioned 和 non-permissioned blockchain，前者基本都是私有链和联盟链，后者是公链，\n目前来看，只有公链才算是真正意义的分布式系统，因为所有节点基本上都是公平的，可以随时加入退出，不影响公链的运行，大家遵循同一个规则来运行节点，维护网络，\n运行节点的目的以及维护网络的方式具体就是挖矿（打包区块），发布交易，验证交易等；")]),e._v(" "),o("p",[e._v("关于共识算法，参考我在巴比特上面的文章：\n"),o("a",{attrs:{href:"https://www.8btc.com/media/393154",target:"_blank",rel:"noopener noreferrer"}},[e._v("区块链基础：解密挖矿与共识的误解"),o("OutboundLink")],1)])])}),[],!1,null,null,null);r.default=a.exports}}]);