<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>1. 基本场景 | 计算机基础教程</title>
    <meta name="description" content="软件开发教程，白帽黑客入门教程，区块链入门教程，物联网，大数据">
    
    
    <link rel="preload" href="/docs/assets/css/0.styles.89d6372f.css" as="style"><link rel="preload" href="/docs/assets/js/app.a7a7691a.js" as="script"><link rel="preload" href="/docs/assets/js/2.dc5756d7.js" as="script"><link rel="preload" href="/docs/assets/js/57.bc28ee9c.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.2d7387f5.js"><link rel="prefetch" href="/docs/assets/js/100.26bd18f6.js"><link rel="prefetch" href="/docs/assets/js/101.3d13ec40.js"><link rel="prefetch" href="/docs/assets/js/102.56836def.js"><link rel="prefetch" href="/docs/assets/js/103.d8a6c44f.js"><link rel="prefetch" href="/docs/assets/js/104.f2e6b5ff.js"><link rel="prefetch" href="/docs/assets/js/105.722ee78b.js"><link rel="prefetch" href="/docs/assets/js/106.b4390161.js"><link rel="prefetch" href="/docs/assets/js/107.e814c14f.js"><link rel="prefetch" href="/docs/assets/js/108.98981317.js"><link rel="prefetch" href="/docs/assets/js/109.dd89ce2c.js"><link rel="prefetch" href="/docs/assets/js/11.1ffe7686.js"><link rel="prefetch" href="/docs/assets/js/110.7f7574e7.js"><link rel="prefetch" href="/docs/assets/js/111.d294631f.js"><link rel="prefetch" href="/docs/assets/js/112.277df4a9.js"><link rel="prefetch" href="/docs/assets/js/113.2ba54151.js"><link rel="prefetch" href="/docs/assets/js/114.6673ddc6.js"><link rel="prefetch" href="/docs/assets/js/115.10957352.js"><link rel="prefetch" href="/docs/assets/js/116.8574da79.js"><link rel="prefetch" href="/docs/assets/js/117.54ca4d6c.js"><link rel="prefetch" href="/docs/assets/js/118.a763f9ff.js"><link rel="prefetch" href="/docs/assets/js/12.bc2ad315.js"><link rel="prefetch" href="/docs/assets/js/13.248682a4.js"><link rel="prefetch" href="/docs/assets/js/14.5d393d7e.js"><link rel="prefetch" href="/docs/assets/js/15.02814607.js"><link rel="prefetch" href="/docs/assets/js/16.fb20a517.js"><link rel="prefetch" href="/docs/assets/js/17.f578ebfd.js"><link rel="prefetch" href="/docs/assets/js/18.95b82826.js"><link rel="prefetch" href="/docs/assets/js/19.0da2cf17.js"><link rel="prefetch" href="/docs/assets/js/20.bb584b89.js"><link rel="prefetch" href="/docs/assets/js/21.aed5d86e.js"><link rel="prefetch" href="/docs/assets/js/22.42b6a1fa.js"><link rel="prefetch" href="/docs/assets/js/23.2b527ccb.js"><link rel="prefetch" href="/docs/assets/js/24.538b7237.js"><link rel="prefetch" href="/docs/assets/js/25.1c131461.js"><link rel="prefetch" href="/docs/assets/js/26.16c188f0.js"><link rel="prefetch" href="/docs/assets/js/27.78f9cf7d.js"><link rel="prefetch" href="/docs/assets/js/28.0d9378a7.js"><link rel="prefetch" href="/docs/assets/js/29.30de41fd.js"><link rel="prefetch" href="/docs/assets/js/3.b56caad4.js"><link rel="prefetch" href="/docs/assets/js/30.ccdd5385.js"><link rel="prefetch" href="/docs/assets/js/31.977f5a73.js"><link rel="prefetch" href="/docs/assets/js/32.9c91c524.js"><link rel="prefetch" href="/docs/assets/js/33.cb3884fb.js"><link rel="prefetch" href="/docs/assets/js/34.97ce730c.js"><link rel="prefetch" href="/docs/assets/js/35.c23dda27.js"><link rel="prefetch" href="/docs/assets/js/36.58673bf5.js"><link rel="prefetch" href="/docs/assets/js/37.e2b0e088.js"><link rel="prefetch" href="/docs/assets/js/38.27dd35cc.js"><link rel="prefetch" href="/docs/assets/js/39.aedf8603.js"><link rel="prefetch" href="/docs/assets/js/4.7d1e56e0.js"><link rel="prefetch" href="/docs/assets/js/40.2b511e38.js"><link rel="prefetch" href="/docs/assets/js/41.39e1fb87.js"><link rel="prefetch" href="/docs/assets/js/42.d59af01c.js"><link rel="prefetch" href="/docs/assets/js/43.ceb8631f.js"><link rel="prefetch" href="/docs/assets/js/44.6e6d01a9.js"><link rel="prefetch" href="/docs/assets/js/45.829c4700.js"><link rel="prefetch" href="/docs/assets/js/46.969face5.js"><link rel="prefetch" href="/docs/assets/js/47.c5c7c98f.js"><link rel="prefetch" href="/docs/assets/js/48.8b0a6a2c.js"><link rel="prefetch" href="/docs/assets/js/49.9cf9d943.js"><link rel="prefetch" href="/docs/assets/js/5.540a7edc.js"><link rel="prefetch" href="/docs/assets/js/50.65210efa.js"><link rel="prefetch" href="/docs/assets/js/51.29787614.js"><link rel="prefetch" href="/docs/assets/js/52.09d8fa29.js"><link rel="prefetch" href="/docs/assets/js/53.1f00a67b.js"><link rel="prefetch" href="/docs/assets/js/54.2dfb4d2c.js"><link rel="prefetch" href="/docs/assets/js/55.5ac93c49.js"><link rel="prefetch" href="/docs/assets/js/56.9f047dbe.js"><link rel="prefetch" href="/docs/assets/js/58.64d9e2f5.js"><link rel="prefetch" href="/docs/assets/js/59.6a6086c0.js"><link rel="prefetch" href="/docs/assets/js/6.1b27be8a.js"><link rel="prefetch" href="/docs/assets/js/60.221a12f9.js"><link rel="prefetch" href="/docs/assets/js/61.4480a52f.js"><link rel="prefetch" href="/docs/assets/js/62.d62e66c2.js"><link rel="prefetch" href="/docs/assets/js/63.e77b8024.js"><link rel="prefetch" href="/docs/assets/js/64.f8f78160.js"><link rel="prefetch" href="/docs/assets/js/65.f217ee45.js"><link rel="prefetch" href="/docs/assets/js/66.5bc6c709.js"><link rel="prefetch" href="/docs/assets/js/67.d54ab555.js"><link rel="prefetch" href="/docs/assets/js/68.04dbc685.js"><link rel="prefetch" href="/docs/assets/js/69.cf542e1f.js"><link rel="prefetch" href="/docs/assets/js/7.e41d4d76.js"><link rel="prefetch" href="/docs/assets/js/70.f8a257bd.js"><link rel="prefetch" href="/docs/assets/js/71.48434bf4.js"><link rel="prefetch" href="/docs/assets/js/72.31c63303.js"><link rel="prefetch" href="/docs/assets/js/73.b8abbb9b.js"><link rel="prefetch" href="/docs/assets/js/74.9a02c217.js"><link rel="prefetch" href="/docs/assets/js/75.80fb9873.js"><link rel="prefetch" href="/docs/assets/js/76.c06b222d.js"><link rel="prefetch" href="/docs/assets/js/77.8fe99617.js"><link rel="prefetch" href="/docs/assets/js/78.09abbed1.js"><link rel="prefetch" href="/docs/assets/js/79.b50d79d8.js"><link rel="prefetch" href="/docs/assets/js/8.6487e249.js"><link rel="prefetch" href="/docs/assets/js/80.ca3781f1.js"><link rel="prefetch" href="/docs/assets/js/81.53f0277b.js"><link rel="prefetch" href="/docs/assets/js/82.463d64c2.js"><link rel="prefetch" href="/docs/assets/js/83.55f2fb5e.js"><link rel="prefetch" href="/docs/assets/js/84.5ccd75ce.js"><link rel="prefetch" href="/docs/assets/js/85.74c465ab.js"><link rel="prefetch" href="/docs/assets/js/86.0099c050.js"><link rel="prefetch" href="/docs/assets/js/87.3ccd28f0.js"><link rel="prefetch" href="/docs/assets/js/88.6d35b952.js"><link rel="prefetch" href="/docs/assets/js/89.518e8ed8.js"><link rel="prefetch" href="/docs/assets/js/9.465f1c60.js"><link rel="prefetch" href="/docs/assets/js/90.2f116084.js"><link rel="prefetch" href="/docs/assets/js/91.16b10827.js"><link rel="prefetch" href="/docs/assets/js/92.f8458cc0.js"><link rel="prefetch" href="/docs/assets/js/93.b580e08b.js"><link rel="prefetch" href="/docs/assets/js/94.18252c99.js"><link rel="prefetch" href="/docs/assets/js/95.37a8f4fc.js"><link rel="prefetch" href="/docs/assets/js/96.3e511dd7.js"><link rel="prefetch" href="/docs/assets/js/97.a7423b58.js"><link rel="prefetch" href="/docs/assets/js/98.1c7ea568.js"><link rel="prefetch" href="/docs/assets/js/99.2e3a3c24.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.89d6372f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><!----> <span class="site-name">计算机基础教程</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/docs/" class="nav-link">机器指令</a></div><div class="nav-item"><a href="/docs/software/" class="nav-link router-link-active">软件基础</a></div><div class="nav-item"><a href="/docs/coder2hacker/" class="nav-link">白帽黑客</a></div><div class="nav-item"><a href="/docs/blockchain/" class="nav-link">区块链</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/docs/" class="nav-link">机器指令</a></div><div class="nav-item"><a href="/docs/software/" class="nav-link router-link-active">软件基础</a></div><div class="nav-item"><a href="/docs/coder2hacker/" class="nav-link">白帽黑客</a></div><div class="nav-item"><a href="/docs/blockchain/" class="nav-link">区块链</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/docs/software/" class="sidebar-link">软件基础</a></li><li><a href="/docs/coder2hacker/" class="sidebar-link">黑客入门</a></li><li><a href="/docs/blockchain/" class="sidebar-link">区块链入门</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="_1-基本场景"><a href="#_1-基本场景" class="header-anchor">#</a> 1. 基本场景</h2> <p>用户登录或认证授权有几个基本场景：</p> <ul><li>普通登录：
用户+网站</li> <li>单点登录sso：
用户+企业各种网站+企业SSO服务器</li> <li>第三方登录3rd party：
用户+各种网站+某企业提供的SSO服务（第三方登录）</li> <li>无普通用户，只有application级别用户，这种一般是系统集成，需要系统之间的身份验证</li></ul> <p>注意这里的“第三方”由角度不同产生不同的叫法，比如：
我是某个网站主，想要集成google登录，那么用户和我网站就是两方，google登录就是第三方登录提供商；
如果我是某个登录提供商，比如我开发了一个登录系统，提供给外部网站集成我的登录方式，那外部网站就是我的Client或者叫第三方应用，用户和我的登录服务器就是两方；
场景不同读者自行脑补切换；</p> <p>以下oauth2.0就是围绕着这几个场景衍生出不同的规范</p> <p>首先第一种普通登录采用传统的登录方式是，
用户直接登录某个网站网页，然后登录信息传到网站服务端，服务端验证授权，然后生成cookie和session，session保存在服务端，cookie则通过response的set cookie返回到用户浏览器，
cookie一般包含sessionid，后面的请求携带sessionid，则可以从服务端的session表查询到用户信息，一般这个都是比如asp或php框架实现的；
可见sessionid一般不包含任何额外的信息；</p> <p>如果改造称为第二种单点登录，可以将session信息存到一个共享内存比如redis中，这样多个网站就可以通过读取redis来实现“单点登录”；</p> <p>但是如果有第三方合作网站可能想用我们的网站登录功能就会比较麻烦，通过下面的oauth2.0分析我们就会反向推导中为什么我说会很麻烦。</p> <p>下面开始讲解oath2.0；</p> <h2 id="_2-oauth2-0-framework-standard"><a href="#_2-oauth2-0-framework-standard" class="header-anchor">#</a> 2. oauth2.0 framework standard</h2> <p>协议： https://tools.ietf.org/html/rfc6749</p> <p>协议安全： https://tools.ietf.org/html/rfc6819</p> <p>基本概念：</p> <ul><li>Resource Owner：资源所有者。即用户。
An entity capable of granting access to a protected resource. When the resource owner is a person, it is referred to as an end-user.</li> <li>Client：客户端（第三方应用），代表资源所有者并且经过所有者授权去访问受保护的资源的应用程序，比如某个网站。
An application making protected resource requests on behalf of the resource owner and with its authorization.  The term &quot;client&quot; does not imply any particular implementation characteristics (e.g., whether the application executes on a server, a desktop, or other devices).</li> <li>HTTP service：HTTP服务提供商，简称服务提供商。这里是用来指第三方登录如github或者Google。</li> <li>User Agent：用户代理。本文中就是指浏览器。</li> <li>Authorization server：授权（认证）服务器。即服务提供商专门用来处理认证的服务器，在成功验证资源所有者并获得授权后向客户端发出访问令牌。
The server issuing access tokens to the client after successfully authenticating the resource owner and obtaining authorization.</li> <li>Resource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。
The server hosting the protected resources, capable of accepting and responding to protected resource requests using access tokens.</li> <li>Access Token：访问令牌。使用合法的访问令牌获取受保护的资源，一般存储在User Agent浏览器端。</li> <li>Refresh Token：用来更新获取Access Token，一般存储在服务器端（实际是指这里的Client第三方应用端）；</li></ul> <p>标准流程：
(A) The client requests authorization from the resource owner.
The authorization request can be made directly to the resource owner(as shown), or preferably indirectly via the authorization server as an intermediary.</p> <p>(B) The client receives an authorization grant, which is a credential representing the resource owner's authorization,
expressed using one of four grant types defined in this specification or using an extension grant type.
The authorization grant type depends on the method used by the client to request authorization and the types supported by the authorization server.</p> <p>(C) The client requests an access token by authenticating with the authorization server and presenting the authorization grant.</p> <p>(D) The authorization server authenticates the client and validates the authorization grant, and if valid, issues an access token.</p> <p>(E) The client requests the protected resource from the resource server and authenticates by presenting the access token.</p> <p>(F) The resource server validates the access token, and if valid,serves the request.</p> <p>根据<strong>Authorization Grant</strong>的方式授权类型分为四种：authorization code, implicit, resource owner password credentials, and client credentials</p> <p><strong>An authorization grant is a credential representing the resource owner's authorization (to access its protected resources) used by the client to obtain an access token.</strong> <strong>This specification defines four grant types -- authorization code, implicit, resource owner password credentials, and client credentials -- as well as an extensibility mechanism for defining additional types.</strong></p> <h3 id="_2-1-授权码模式（authorization-code）"><a href="#_2-1-授权码模式（authorization-code）" class="header-anchor">#</a> 2.1 授权码模式（authorization code）</h3> <pre><code> +----------+
 | Resource |
 |   Owner  |
 |          |
 +----------+
      ^
      |
     (B)
 +----|-----+          Client Identifier      +---------------+
 |         -+----(A)-- &amp; Redirection URI ----&gt;|               |
 |  User-   |                                 | Authorization |
 |  Agent  -+----(B)-- User authenticates ---&gt;|     Server    |
 |          |                                 |               |
 |         -+----(C)-- Authorization Code ---&lt;|               |
 +-|----|---+                                 +---------------+
   |    |                                         ^      v
  (A)  (C)                                        |      |
   |    |                                         |      |
   ^    v                                         |      |
 +---------+                                      |      |
 |         |&gt;---(D)-- Authorization Code ---------'      |
 |  Client |          &amp; Redirection URI                  |
 |         |                                             |
 |         |&lt;---(E)----- Access Token -------------------'
 +---------+       (w/ Optional Refresh Token)
</code></pre> <p>Note: The lines illustrating steps (A), (B), and (C) are broken into
two parts as they pass through the user-agent.</p> <pre><code>                 Figure 3: Authorization Code Flow
</code></pre> <p>(A)  客户端向资源所有者请求其授权
授权请求可以直接对资源所有者进行，或者通过授权服务器作为中介进行间接访问（首选方案）。
用户点击客户端网站的（第三方）登录按钮或者某个需要权限的操作：
如果是直接点击第三方登录，客户端直接向授权服务器发起请求，如果是用户直接访问了某个资源，客户端会向资源服务器发起请求，然后资源服务器发现没有Access token，则会转发到授权服务器，
总之授权服务器返回一个授权页面（如果用户已经登录了则返回一个授权页面，否则返回登录页面）；
(A)The client initiates the flow by directing the resource owner's user-agent to the authorization endpoint.<br>
The client includes its client identifier, requested scope, local state, and a redirection URI to which the authorization server will send the user-agent back once access is granted (or denied).</p> <p>(B)  客户端收到资源所有者的授权许可(用户点击允许或同意按钮)，返回凭证-授权码Code，这个授权许可是一个代表资源所有者授权的凭据
(B)The authorization server authenticates the resource owner (via the user-agent) and establishes whether the resource owner grants or denies the client's access request.</p> <pre><code>(C)Assuming the resource owner grants access, the authorization server redirects the user-agent back to the client using the redirection URI provided earlier (in the request or during client registration).  
The redirection URI includes an authorization code and any local state provided by the client earlier.
注意这个redirect URI一般是对应Client应用的服务器端，当然对于授权服务器来说这个就是一次URL跳转回client的url，然后client的服务器端收到这个请求后，拿到授权码，然后就可以从服务器端发起下面步骤的请求；
</code></pre> <p>(C)  客户端向授权服务器请求访问令牌，并出示授权许可-授权码code，请求访问令牌（access token）。
如果客户端访问的是第三方登录，则一般需要同时出示client secret，如果是内部系统，可能只是通过写死的自签名cert验证即可；</p> <pre><code>(D)The client requests an access token from the authorization server's token endpoint by including the authorization code received in the previous step.  
When making the request, the client authenticates with the authorization server.  
The client includes the redirection URI used to obtain the authorization code for verification.
</code></pre> <p>(D)  授权服务器对客户端身份进行认证，并校验授权许可，如果都是有效的，则发放访问令牌access token
这个是两部分：一个是对客户端本身的身份认证，通过前面client secret对应的id以及绑定的比如网站domain，如果是内部系统，则简单通过比如写死的加解密或者白名单即可；
另一个部分是验证授权码，如果资源服务器和认证服务器分开，则此时需要交互，或者访问一个共同的缓存或数据库；</p> <pre><code>(E)The authorization server authenticates the client, validates the authorization code, and ensures that the redirection URI received matches the URI used to redirect the client in step (C).  
If valid, the authorization server responds back with an access token and, optionally, a refresh token.
注意这里是说授权服务器“responds back”，不是redirect，应该就是服务器对服务器通信了，前两步client从服务器端接收到授权码后直接发起请求，所以此时第三方服务器端直接返回，
client的服务器端收到响应后，**可以将access token发送给自己的客户端，然后将refresh token留存在服务端（安全性考虑）**
</code></pre> <p>(E)  客户端向资源服务器请求受保护的资源，并出示访问令牌access token</p> <p>(F)  资源服务器校验访问令牌，如果令牌有效，则提供服务
如果资源服务器和认证服务器是分开的，则此时需要交互，或者访问一个共同的缓存或数据库，或者如果这个access token本身可以解密出用户的足够信息，则不需要交互；</p> <p>设计思想：</p> <p>为什么需要授权码，授权码是用户resource owner跟第三方登录网站的协商过程，不然第三方网站不知道这个行为本身是否得到了用户的授权，
你可能问为啥不直接给Access token呢，因为后面还需要验证这个网站即client id secret，当然如果都是公司内部网站或服务，不涉及三方，则不需要这一步，可以直接给Access token，即下面的Implicit方式</p> <p>The authorization code is obtained by using an authorization server as an intermediary between the client and resource owner.<br>
Instead of requesting authorization directly from the resource owner, the client directs the resource owner to an authorization server (via its user-agent as defined in [RFC2616]), which in turn directs the resource owner back to the client with the authorization code.</p> <p>Before directing the resource owner back to the client with the authorization code, the authorization server authenticates the resource owner and obtains authorization.<br>
Because the resource owner only authenticates with the authorization server, the resource owner's credentials are never shared with the client.</p> <p>The authorization code provides a few important security benefits, such as the ability to authenticate the client,
as well as the transmission of the access token directly to the client without passing it through the resource owner's user-agent and potentially exposing it to others,
including the resource owner.</p> <p><strong>实例:github验证授权例子</strong></p> <p>https://segmentfault.com/a/1190000013467122</p> <p>1）网站和Github之间的协商，注册获取，Github也给我发了两张门票，一张门票叫做Client Id，另一张门票叫做Client Secret。</p> <p>2）用户和Github(资源服务器）之间的协商</p> <p>用户进入我的网站，点击github登录按钮的时候，我的网站会将Github给我的Client Id交给用户，让他进入Github授权界面，如果此时用户没有登录，Github会提示登录（当然这不是OAuth2.0客户端部分应该关注的）。假设用户已经登录Github，那么Github看到用户手中的门票，就知道是我的网站让他过来的，于是就把我的网站获取的权限摆出来，并询问用户是否允许网站获取这些权限。</p> <div class="language- extra-class"><pre class="language-text"><code>// 用户登录 github，协商
GET //github.com/login/oauth/authorize
// 协商凭证
params = {
  client_id: &quot;xxxx&quot;,
  redirect_uri: &quot;http://my-website.com&quot;
}

如果用户同意，在授权页面点击了确认授权后，页面会跳转到我预先设定的 redirect_uri并附带一个盖了章的门票code。

// 协商成功后带着盖了章的 code
Location: http://my-website.com?code=xxx

这个时候，用户和 Github 之间的协商就已经完成，Github 也会在自己的系统中记录这次协商，表示该用户已经允许在我的网站访问上直接操作和使用他的部分资源。
</code></pre></div><p>3）告诉Github(授权服务器）我的网站要来访问</p> <p>第二步中，我们已经拿到了盖过章的门票code（资源服务器授权码），但这个code 只能表明，用户允许我的网站从github上获取该用户的数据，如果我直接拿这个code去github访问数据一定会被拒绝，因为任何人都可以持有code，github并不知道code持有方就是该网站“本人”。</p> <p>还记得之前申请应用的时候github给我的两张门票么，Client Id在上一步中已经用过了，接下来轮到另一张门票Client Secret。</p> <div class="language- extra-class"><pre class="language-text"><code>// 网站和 github 之间的协商
POST //github.com/login/oauth/access_token
// 协商凭证包括 github 给用户盖的章和 github 发给我的门票
params = {
  code: &quot;xxx&quot;,
  client_id: &quot;xxx&quot;,
  client_secret: &quot;xxx&quot;,
  redirect_uri: &quot;http://my-website.com&quot;
}
拿着用户盖过章的code和能够标识个人身份的client_id、client_secret去拜访 github，拿到最后的绿卡access_token。
// 拿到最后的绿卡
response = {
  access_token: &quot;e72e16c7e42f292c6912e7710c838347ae178b4a&quot;
  scope: &quot;user,gist&quot;
  token_type: &quot;bearer&quot;,
  refresh_token: &quot;xxxx&quot;
}
</code></pre></div><p>4）用户开始使用Github账号在我的网站上留言</p> <div class="language- extra-class"><pre class="language-text"><code>// 访问用户数据
GET //api.github.com/user?access_token=e72e16c7e42f292c6912e7710c838347ae178b4a

get中直接用access token是一种方式，还有一种方式是放在header中作为bearer token；

上一步github已经把最后的绿卡access_token给我了，通过github提供的 API 加绿卡就能够访问用户的信息了，能获取用户的哪些权限在response 中也给了明确的说明，scope为user和gist，也就是只能获取user组和gist组两个小组的权限，user组中就包含了用户的名字和邮箱等信息了。

// 告诉我用户的名字和邮箱
response = {
  username: &quot;barretlee&quot;,
  email: &quot;barret.china@gmail.com&quot;
}
</code></pre></div><p><strong>注意:</strong></p> <ul><li><p>用户端只需要获得access token即可，refresh token需要由网站在服务器端保存，否则客户端不安全，这也是为什么access token比较短命的原因</p></li> <li><p>还有一个细节上面没有提到，就是资源服务器如何知道这个access token所对应的用户权限scope等等，这个在上面标准中并未提到，这个是涉及到具体实现,
首先access token通过密码的方式一般都会把用户id放入里面，资源服务器通过跟授权服务器事先配置或者设计好加解密方法，可以解密出user id，然后其他信息呢，一般有如下方式:</p> <ul><li>self-encoded access tokens： verifying the tokens can be done entirely in the resource server without interacting with a database or external servers.
JSON Web Token (JWT) https://www.oauth.com/oauth2-servers/access-tokens/self-encoded-access-tokens/
github貌似是从token直接解密出来相关scope和权限，具体看https://spring.io/guides/tutorials/spring-boot-oauth2/，</li> <li>If your tokens are stored in a database, then verifying the token is simply a database lookup on the token table.</li> <li>use the Token Introspection spec to build an API to verify access tokens
这个可以放在单独的server或者直接扔到授权服务器上
https://www.oauth.com/oauth2-servers/token-introspection-endpoint/</li></ul></li></ul> <p>注意，spring security的oauth2.0貌似是采用了上面第三种方式，通过:</p> <blockquote><p>Spring security oauth exposes two endpoints for checking tokens (/oauth/check_token and /oauth/token_key) which are by default protected behind denyAll(). tokenKeyAccess() and checkTokenAccess() methods open these endpoints for use.
<a href="https://howtodoinjava.com/spring-boot2/oauth2-auth-server/" target="_blank" rel="noopener noreferrer">Spring Boot 2 – OAuth2 Auth and Resource Server<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <h3 id="_2-2-implicit"><a href="#_2-2-implicit" class="header-anchor">#</a> 2.2 Implicit</h3> <pre><code> +----------+
 | Resource |
 |  Owner   |
 |          |
 +----------+
      ^
      |
     (B)
 +----|-----+          Client Identifier     +---------------+
 |         -+----(A)-- &amp; Redirection URI ---&gt;|               |
 |  User-   |                                | Authorization |
 |  Agent  -|----(B)-- User authenticates --&gt;|     Server    |
 |          |                                |               |
 |          |&lt;---(C)--- Redirection URI ----&lt;|               |
 |          |          with Access Token     +---------------+
 |          |            in Fragment
 |          |                                +---------------+
 |          |----(D)--- Redirection URI ----&gt;|   Web-Hosted  |
 |          |          without Fragment      |     Client    |
 |          |                                |    Resource   |
 |     (F)  |&lt;---(E)------- Script ---------&lt;|               |
 |          |                                +---------------+
 +-|--------+
   |    |
  (A)  (G) Access Token
   |    |
   ^    v
 +---------+
 |         |
 |  Client |
 |         |
 +---------+
</code></pre> <p>Note: The lines illustrating steps (A) and (B) are broken into two
parts as they pass through the user-agent.</p> <pre><code>                   Figure 4: Implicit Grant Flow
</code></pre> <p>(A)  The client initiates the flow by directing the resource owner's user-agent to the authorization endpoint.<br>
The client includes its client identifier, requested scope, local state, and a redirection URI to which the authorization server will send the user-agent back once access is granted (or denied).</p> <p>(B)  The authorization server authenticates the resource owner (via the user-agent) and establishes whether the resource owner grants or denies the client's access request.</p> <p>(C)  Assuming the resource owner grants access, the authorization server redirects the user-agent back to the client using the redirection URI provided earlier.<br>
The redirection URI includes the access token in the URI fragment.</p> <p>(D)  The user-agent follows the redirection instructions by making a request to the web-hosted client resource (which does not include the fragment per [RFC2616]).<br>
The user-agent retains the fragment information locally.
浏览器还会帮忙retain fragment information？这个需要继续了解，不过感觉到这步就结束了，后面三步不太明白为啥要写这么细，因为我想已经redirect到client这边了，client的服务器端自然会读取Access token，
然后set cookie，不清楚为什么后面三步要写的这么具体，还说要javascript来读取这个url的Access token， 我猜测是不是为了防止CSRF攻击，
最终在rfc6819#section-4.4.2找到答案,因为url的fragment就是#部分不会发送到服务器端，所以只能用前端脚本去解读出来！</p> <blockquote><p>In the implicit grant type flow, the access token is directly returned to the client as a fragment part of the redirect URI.<br>
It is assumed that the token is not sent to the redirect URI target, as <strong>HTTP user agents do not send the fragment part of URIs to HTTP servers.</strong><br>
Thus, an attacker cannot eavesdrop the access token on this communication path, and the token cannot leak through HTTP referrer headers.
https://tools.ietf.org/html/rfc6819#section-4.4.2</p></blockquote> <blockquote><p>浏览器的redirect_uri是一个不安全信道，此方式不适合于传递敏感数据（如access_token）。因为uri可能通过HTTP referrer被传递给其它恶意站点，也可能存在于浏览器cacher或log文件中，这就给攻击者盗取access_token带来了很多机会。另外，此协议也不应该假设RO用户代理的行为是可信赖的，因为RO的浏览器可能早已被攻击者植入了跨站脚本用来监听access_token。因此，access_token通过RO的用户代理传递给Client，会显著扩大access_token被泄露的风险。 但authorization_code可以通过redirect_uri方式来传递，是因为authorization_code并不像access_token一样敏感。即使authorization_code被泄露，攻击者也无法直接拿到access_token，因为拿authorization_code去交换access_token是需要验证Client的真实身份。也就是说，除了Client之外，其他人拿authorization_code是没有用的。 此外，access_token应该只颁发给Client使用，其他任何主体（包括RO）都不应该获取access_token。协议的设计应能保证Client是唯一有能力获取access_token的主体。引入authorization_code之后，便可以保证Client是access_token的唯一持有人。当然，Client也是唯一的有义务需要保护access_token不被泄露。
http://dearcharles.cn/2017/11/15/OAuth2-0%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</p></blockquote> <p>(E)  The web-hosted client resource returns a web page (typically an HTML document with an embedded script) capable of accessing the full redirection URI including the fragment retained by the user-agent,
and extracting the access token (and other parameters) contained in the fragment.</p> <p>(F)  The user-agent executes the script provided by the web-hosted client resource locally, which extracts the access token.</p> <p>(G)  The user-agent passes the access token to the client.</p> <p>设计思想：</p> <p>The implicit grant is a simplified authorization code flow optimized for clients implemented in a browser using a scripting language such as JavaScript.<br>
In the implicit flow, instead of issuing the client an authorization code, the client is issued an access token directly (as the result of the resource owner authorization).<br>
The grant type is implicit, as no intermediate credentials (such as an authorization code) are issued (and later used to obtain an access token).</p> <p>When issuing an access token during the implicit grant flow, the authorization server does not authenticate the client.<br>
In some cases, the client identity can be verified via the redirection URI used to deliver the access token to the client.<br>
The access token may be exposed to the resource owner or other applications with access to the resource owner's user-agent.</p> <p>Implicit grants improve the responsiveness and efficiency of some clients (such as a client implemented as an in-browser application),
since it reduces the number of round trips required to obtain an access token.<br>
However, this convenience should be weighed against the security implications of using implicit grants, such as those described in Sections 10.3 and 10.16, especially when the authorization code grant type is available.</p> <h3 id="_2-3-resource-owner-password-credentials"><a href="#_2-3-resource-owner-password-credentials" class="header-anchor">#</a> 2.3 Resource Owner Password Credentials</h3> <pre><code> +----------+
 | Resource |
 |  Owner   |
 |          |
 +----------+
      v
      |    Resource Owner
     (A) Password Credentials
      |
      v
 +---------+                                  +---------------+
 |         |&gt;--(B)---- Resource Owner -------&gt;|               |
 |         |         Password Credentials     | Authorization |
 | Client  |                                  |     Server    |
 |         |&lt;--(C)---- Access Token ---------&lt;|               |
 |         |    (w/ Optional Refresh Token)   |               |
 +---------+                                  +---------------+

        Figure 5: Resource Owner Password Credentials Flow
</code></pre> <p>(A)  The resource owner provides the client with its username and password.</p> <p>(B)  The client requests an access token from the authorization server's token endpoint by including the credentials received from the resource owner.<br>
When making the request, the client authenticates with the authorization server.</p> <p>(C)  The authorization server authenticates the client and validates the resource owner credentials, and if valid, issues an access token.</p> <p>场景：</p> <ul><li>内部系统，用户直接向client提供用户名密码</li> <li>外部系统application级别的验证访问，相当于前面提到的client id和client secret注册！</li></ul> <p>设计思想：</p> <p>The resource owner password credentials (i.e., username and password) can be used directly as an authorization grant to obtain an access token.<br>
The credentials should only be used when there is a high degree of trust between the resource owner and the client
(e.g., the client is part of the device operating system or a highly privileged application),
and when other authorization grant types are not available (such as an authorization code).</p> <p>Even though this grant type requires direct client access to the resource owner credentials,
the resource owner credentials are used for a single request and are exchanged for an access token.<br>
This grant type can eliminate the need for the client to store the resource owner credentials for future use, by exchanging the credentials with a long-lived access token or refresh token.</p> <h3 id="_2-4-client-credentials"><a href="#_2-4-client-credentials" class="header-anchor">#</a> 2.4 Client Credentials</h3> <pre><code> +---------+                                  +---------------+
 |         |                                  |               |
 |         |&gt;--(A)- Client Authentication ---&gt;| Authorization |
 | Client  |                                  |     Server    |
 |         |&lt;--(B)---- Access Token ---------&lt;|               |
 |         |                                  |               |
 +---------+                                  +---------------+

                 Figure 6: Client Credentials Flow
</code></pre> <p>(A)  The client authenticates with the authorization server and requests an access token from the token endpoint.</p> <p>(B)  The authorization server authenticates the client, and if valid, issues an access token.</p> <p>场景：
通常就是外部系统application级别的验证访问，相当于前面提到的client id和client secret注册！这种情况下比前一种“Resource Owner Password Credentials”更适合！</p> <p>设计思想：</p> <p>The client credentials (or other forms of client authentication) can be used as an authorization grant when the authorization scope is limited to the protected resources under the control of the client,
or to protected resources previously arranged with the authorization server.<br>
Client credentials are used as an authorization grant typically when the client is acting on its own behalf (the client is also the resource owner) or is requesting access to protected resources based on an authorization previously arranged with the authorization server.</p> <h2 id="_3-oauth2-0-implementation："><a href="#_3-oauth2-0-implementation：" class="header-anchor">#</a> 3.Oauth2.0 implementation：</h2> <p>https://docs.spring.io/spring-security-oauth2-boot/docs/current/reference/htmlsingle/</p> <p>https://www.oauth.com/oauth2-servers/the-resource-server/
Spring Boot OAuth 2.0 separating Authorization Service and Resource Service
https://medium.com/@buddhiprabhath/spring-boot-oauth-2-0-separating-authorization-service-and-resource-service-1641ebced1f0
https://github.com/buddhiprab/springboot-oauth2-separating-authorization_server-and-resource_server</p> <p>https://github.com/Baeldung/spring-security-oauth
https://github.com/longfeizheng/sso-merryyou
https://github.com/fengcharly/spring-security-oauth2.0
https://github.com/lyhistory/oauth2-sso-demo</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/docs/assets/js/app.a7a7691a.js" defer></script><script src="/docs/assets/js/2.dc5756d7.js" defer></script><script src="/docs/assets/js/57.bc28ee9c.js" defer></script>
  </body>
</html>
