<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>计算机基础教程</title>
    <meta name="generator" content="VuePress 1.9.7">
    <script async="true" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9742852210287449" crossorigin="anonymous"></script>
    <script>
			(function() { // DON'T EDIT BELOW THIS LINE
			
			})();
		 </script>
    <meta name="description" content="软件开发教程，白帽黑客入门教程，区块链入门教程，物联网，大数据">
    
    <link rel="preload" href="/docs/assets/css/0.styles.af9f351a.css" as="style"><link rel="preload" href="/docs/assets/js/app.64832df0.js" as="script"><link rel="preload" href="/docs/assets/js/2.19baf9f4.js" as="script"><link rel="preload" href="/docs/assets/js/122.f623e692.js" as="script"><link rel="preload" href="/docs/assets/js/11.0d0890d4.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.e545244a.js"><link rel="prefetch" href="/docs/assets/js/100.63f608be.js"><link rel="prefetch" href="/docs/assets/js/101.4ae8f59d.js"><link rel="prefetch" href="/docs/assets/js/102.3293e86a.js"><link rel="prefetch" href="/docs/assets/js/103.5a9023b5.js"><link rel="prefetch" href="/docs/assets/js/104.c768ad07.js"><link rel="prefetch" href="/docs/assets/js/105.14b9b23d.js"><link rel="prefetch" href="/docs/assets/js/106.9e159ce3.js"><link rel="prefetch" href="/docs/assets/js/107.0f7de4f1.js"><link rel="prefetch" href="/docs/assets/js/108.fe1556a2.js"><link rel="prefetch" href="/docs/assets/js/109.cbdfdefd.js"><link rel="prefetch" href="/docs/assets/js/110.5284a344.js"><link rel="prefetch" href="/docs/assets/js/111.35a41924.js"><link rel="prefetch" href="/docs/assets/js/112.6a3b3198.js"><link rel="prefetch" href="/docs/assets/js/113.cc02a720.js"><link rel="prefetch" href="/docs/assets/js/114.45007c2e.js"><link rel="prefetch" href="/docs/assets/js/115.3bae9b66.js"><link rel="prefetch" href="/docs/assets/js/116.0cfa20ef.js"><link rel="prefetch" href="/docs/assets/js/117.6743bd9c.js"><link rel="prefetch" href="/docs/assets/js/118.ff55b74d.js"><link rel="prefetch" href="/docs/assets/js/119.c3ebf222.js"><link rel="prefetch" href="/docs/assets/js/12.eec9a325.js"><link rel="prefetch" href="/docs/assets/js/120.456fd27b.js"><link rel="prefetch" href="/docs/assets/js/121.9432c51a.js"><link rel="prefetch" href="/docs/assets/js/123.73c570b7.js"><link rel="prefetch" href="/docs/assets/js/124.45e3cd07.js"><link rel="prefetch" href="/docs/assets/js/125.70d22396.js"><link rel="prefetch" href="/docs/assets/js/126.50b53101.js"><link rel="prefetch" href="/docs/assets/js/127.aa4d612f.js"><link rel="prefetch" href="/docs/assets/js/128.1391f2a7.js"><link rel="prefetch" href="/docs/assets/js/129.f2da8316.js"><link rel="prefetch" href="/docs/assets/js/13.d57f15d3.js"><link rel="prefetch" href="/docs/assets/js/130.0683370f.js"><link rel="prefetch" href="/docs/assets/js/131.f13f8c6b.js"><link rel="prefetch" href="/docs/assets/js/132.293d18d2.js"><link rel="prefetch" href="/docs/assets/js/133.c05f3b26.js"><link rel="prefetch" href="/docs/assets/js/134.fc2c97da.js"><link rel="prefetch" href="/docs/assets/js/135.ba67113b.js"><link rel="prefetch" href="/docs/assets/js/136.43f371aa.js"><link rel="prefetch" href="/docs/assets/js/137.79fb6c22.js"><link rel="prefetch" href="/docs/assets/js/138.a4e7fbcb.js"><link rel="prefetch" href="/docs/assets/js/139.6d4da451.js"><link rel="prefetch" href="/docs/assets/js/14.d62fcd5d.js"><link rel="prefetch" href="/docs/assets/js/140.1b8440ed.js"><link rel="prefetch" href="/docs/assets/js/141.e2c4db5f.js"><link rel="prefetch" href="/docs/assets/js/142.d3fcf62d.js"><link rel="prefetch" href="/docs/assets/js/143.983618a9.js"><link rel="prefetch" href="/docs/assets/js/144.c24a7663.js"><link rel="prefetch" href="/docs/assets/js/145.48234026.js"><link rel="prefetch" href="/docs/assets/js/146.a60f176a.js"><link rel="prefetch" href="/docs/assets/js/147.3ad8d2f0.js"><link rel="prefetch" href="/docs/assets/js/148.51117f39.js"><link rel="prefetch" href="/docs/assets/js/149.92c0b080.js"><link rel="prefetch" href="/docs/assets/js/15.eedbe3b9.js"><link rel="prefetch" href="/docs/assets/js/150.ba9636e3.js"><link rel="prefetch" href="/docs/assets/js/151.9a5cf0b6.js"><link rel="prefetch" href="/docs/assets/js/152.7f277305.js"><link rel="prefetch" href="/docs/assets/js/153.94da8b5b.js"><link rel="prefetch" href="/docs/assets/js/154.c7cd0ac1.js"><link rel="prefetch" href="/docs/assets/js/155.0e1860c3.js"><link rel="prefetch" href="/docs/assets/js/156.e7ca9739.js"><link rel="prefetch" href="/docs/assets/js/157.02ac3b09.js"><link rel="prefetch" href="/docs/assets/js/158.8b8fade9.js"><link rel="prefetch" href="/docs/assets/js/159.3322cbb4.js"><link rel="prefetch" href="/docs/assets/js/16.048bfae7.js"><link rel="prefetch" href="/docs/assets/js/160.c921ac3f.js"><link rel="prefetch" href="/docs/assets/js/161.935e5c46.js"><link rel="prefetch" href="/docs/assets/js/162.167c61b3.js"><link rel="prefetch" href="/docs/assets/js/163.e87e7ce2.js"><link rel="prefetch" href="/docs/assets/js/164.8a8f187c.js"><link rel="prefetch" href="/docs/assets/js/165.2d5be48b.js"><link rel="prefetch" href="/docs/assets/js/166.159287ba.js"><link rel="prefetch" href="/docs/assets/js/167.b98bc30d.js"><link rel="prefetch" href="/docs/assets/js/168.69b92ac2.js"><link rel="prefetch" href="/docs/assets/js/169.022bb7c8.js"><link rel="prefetch" href="/docs/assets/js/17.b11fd960.js"><link rel="prefetch" href="/docs/assets/js/170.ec3b03eb.js"><link rel="prefetch" href="/docs/assets/js/171.0abb6415.js"><link rel="prefetch" href="/docs/assets/js/172.57a96e6c.js"><link rel="prefetch" href="/docs/assets/js/173.a35a581d.js"><link rel="prefetch" href="/docs/assets/js/174.3f2af236.js"><link rel="prefetch" href="/docs/assets/js/175.495c2084.js"><link rel="prefetch" href="/docs/assets/js/176.61de1fa7.js"><link rel="prefetch" href="/docs/assets/js/177.97aa8abf.js"><link rel="prefetch" href="/docs/assets/js/178.440cb8cb.js"><link rel="prefetch" href="/docs/assets/js/179.c64e681c.js"><link rel="prefetch" href="/docs/assets/js/18.604891ba.js"><link rel="prefetch" href="/docs/assets/js/180.d7c87176.js"><link rel="prefetch" href="/docs/assets/js/181.2d23ffcc.js"><link rel="prefetch" href="/docs/assets/js/182.7fb237f6.js"><link rel="prefetch" href="/docs/assets/js/183.beea0d94.js"><link rel="prefetch" href="/docs/assets/js/184.2cfbd567.js"><link rel="prefetch" href="/docs/assets/js/185.e075e873.js"><link rel="prefetch" href="/docs/assets/js/186.3f9117be.js"><link rel="prefetch" href="/docs/assets/js/187.d6348ac2.js"><link rel="prefetch" href="/docs/assets/js/188.874753c7.js"><link rel="prefetch" href="/docs/assets/js/189.f3355ab6.js"><link rel="prefetch" href="/docs/assets/js/19.407acead.js"><link rel="prefetch" href="/docs/assets/js/190.24362a63.js"><link rel="prefetch" href="/docs/assets/js/191.04fdf257.js"><link rel="prefetch" href="/docs/assets/js/192.ae278e7c.js"><link rel="prefetch" href="/docs/assets/js/193.510ce0f8.js"><link rel="prefetch" href="/docs/assets/js/194.c94fbbe7.js"><link rel="prefetch" href="/docs/assets/js/195.692c1845.js"><link rel="prefetch" href="/docs/assets/js/196.dffb79fe.js"><link rel="prefetch" href="/docs/assets/js/197.8a67d2e7.js"><link rel="prefetch" href="/docs/assets/js/198.1c8e4d56.js"><link rel="prefetch" href="/docs/assets/js/199.1553c20f.js"><link rel="prefetch" href="/docs/assets/js/20.9925f427.js"><link rel="prefetch" href="/docs/assets/js/200.7694a6c9.js"><link rel="prefetch" href="/docs/assets/js/201.1f929085.js"><link rel="prefetch" href="/docs/assets/js/202.4118cfe6.js"><link rel="prefetch" href="/docs/assets/js/203.e1e7e48f.js"><link rel="prefetch" href="/docs/assets/js/204.68099e53.js"><link rel="prefetch" href="/docs/assets/js/205.7ee7330b.js"><link rel="prefetch" href="/docs/assets/js/206.522cf66e.js"><link rel="prefetch" href="/docs/assets/js/207.25f6c082.js"><link rel="prefetch" href="/docs/assets/js/208.b1a89740.js"><link rel="prefetch" href="/docs/assets/js/209.e3163a24.js"><link rel="prefetch" href="/docs/assets/js/21.c3769576.js"><link rel="prefetch" href="/docs/assets/js/210.7b0612b3.js"><link rel="prefetch" href="/docs/assets/js/211.085daffb.js"><link rel="prefetch" href="/docs/assets/js/212.d904db17.js"><link rel="prefetch" href="/docs/assets/js/213.a9d7437a.js"><link rel="prefetch" href="/docs/assets/js/214.ec1e4fe7.js"><link rel="prefetch" href="/docs/assets/js/215.6217d5fe.js"><link rel="prefetch" href="/docs/assets/js/216.4656a213.js"><link rel="prefetch" href="/docs/assets/js/217.b15716dc.js"><link rel="prefetch" href="/docs/assets/js/218.8415ad4e.js"><link rel="prefetch" href="/docs/assets/js/219.57817a8f.js"><link rel="prefetch" href="/docs/assets/js/22.e6438179.js"><link rel="prefetch" href="/docs/assets/js/220.6e4973f3.js"><link rel="prefetch" href="/docs/assets/js/221.5f48a436.js"><link rel="prefetch" href="/docs/assets/js/222.55f9358a.js"><link rel="prefetch" href="/docs/assets/js/223.c69f5f36.js"><link rel="prefetch" href="/docs/assets/js/224.78d53625.js"><link rel="prefetch" href="/docs/assets/js/225.15739a9f.js"><link rel="prefetch" href="/docs/assets/js/226.706e8d85.js"><link rel="prefetch" href="/docs/assets/js/227.542a373a.js"><link rel="prefetch" href="/docs/assets/js/228.e2b33dc0.js"><link rel="prefetch" href="/docs/assets/js/229.701a066f.js"><link rel="prefetch" href="/docs/assets/js/23.6df087e1.js"><link rel="prefetch" href="/docs/assets/js/230.72cdf84a.js"><link rel="prefetch" href="/docs/assets/js/231.e5378e32.js"><link rel="prefetch" href="/docs/assets/js/232.efe67bed.js"><link rel="prefetch" href="/docs/assets/js/233.0d2a7edb.js"><link rel="prefetch" href="/docs/assets/js/234.18a21aef.js"><link rel="prefetch" href="/docs/assets/js/235.453ac012.js"><link rel="prefetch" href="/docs/assets/js/236.80da5e98.js"><link rel="prefetch" href="/docs/assets/js/237.e16f04ea.js"><link rel="prefetch" href="/docs/assets/js/238.7f6c6491.js"><link rel="prefetch" href="/docs/assets/js/239.d19d8927.js"><link rel="prefetch" href="/docs/assets/js/24.f20169ea.js"><link rel="prefetch" href="/docs/assets/js/240.0d51d8f0.js"><link rel="prefetch" href="/docs/assets/js/241.5c006b5a.js"><link rel="prefetch" href="/docs/assets/js/242.7d4b5220.js"><link rel="prefetch" href="/docs/assets/js/243.1e5c8535.js"><link rel="prefetch" href="/docs/assets/js/244.7806a030.js"><link rel="prefetch" href="/docs/assets/js/245.6707e4db.js"><link rel="prefetch" href="/docs/assets/js/246.aaee60ec.js"><link rel="prefetch" href="/docs/assets/js/247.0a56a570.js"><link rel="prefetch" href="/docs/assets/js/25.4a5c8826.js"><link rel="prefetch" href="/docs/assets/js/26.5cc03951.js"><link rel="prefetch" href="/docs/assets/js/27.610aeeac.js"><link rel="prefetch" href="/docs/assets/js/28.21fb8622.js"><link rel="prefetch" href="/docs/assets/js/29.d3108f7c.js"><link rel="prefetch" href="/docs/assets/js/3.6dd5840b.js"><link rel="prefetch" href="/docs/assets/js/30.7cb7920a.js"><link rel="prefetch" href="/docs/assets/js/31.90abc299.js"><link rel="prefetch" href="/docs/assets/js/32.c142261d.js"><link rel="prefetch" href="/docs/assets/js/33.f14851ee.js"><link rel="prefetch" href="/docs/assets/js/34.7d14726b.js"><link rel="prefetch" href="/docs/assets/js/35.c06a5f71.js"><link rel="prefetch" href="/docs/assets/js/36.2ff4e237.js"><link rel="prefetch" href="/docs/assets/js/37.e76e6a95.js"><link rel="prefetch" href="/docs/assets/js/38.1dbf013a.js"><link rel="prefetch" href="/docs/assets/js/39.56dd00ad.js"><link rel="prefetch" href="/docs/assets/js/4.0bc48456.js"><link rel="prefetch" href="/docs/assets/js/40.7e036ccd.js"><link rel="prefetch" href="/docs/assets/js/41.432e30be.js"><link rel="prefetch" href="/docs/assets/js/42.1ba7f136.js"><link rel="prefetch" href="/docs/assets/js/43.d7b85626.js"><link rel="prefetch" href="/docs/assets/js/44.22954c01.js"><link rel="prefetch" href="/docs/assets/js/45.7824d9e7.js"><link rel="prefetch" href="/docs/assets/js/46.c9deb644.js"><link rel="prefetch" href="/docs/assets/js/47.d07bd58e.js"><link rel="prefetch" href="/docs/assets/js/48.c43d68e7.js"><link rel="prefetch" href="/docs/assets/js/49.7c643eb1.js"><link rel="prefetch" href="/docs/assets/js/5.4d243203.js"><link rel="prefetch" href="/docs/assets/js/50.03baec6f.js"><link rel="prefetch" href="/docs/assets/js/51.25772b9a.js"><link rel="prefetch" href="/docs/assets/js/52.ded28c0c.js"><link rel="prefetch" href="/docs/assets/js/53.a6239b62.js"><link rel="prefetch" href="/docs/assets/js/54.8ab5e7de.js"><link rel="prefetch" href="/docs/assets/js/55.f9f6165f.js"><link rel="prefetch" href="/docs/assets/js/56.7769da48.js"><link rel="prefetch" href="/docs/assets/js/57.18251768.js"><link rel="prefetch" href="/docs/assets/js/58.9d0c59ac.js"><link rel="prefetch" href="/docs/assets/js/59.a3cfbf73.js"><link rel="prefetch" href="/docs/assets/js/6.2645c37f.js"><link rel="prefetch" href="/docs/assets/js/60.a0f45ad4.js"><link rel="prefetch" href="/docs/assets/js/61.68134f80.js"><link rel="prefetch" href="/docs/assets/js/62.e949f090.js"><link rel="prefetch" href="/docs/assets/js/63.72f4601b.js"><link rel="prefetch" href="/docs/assets/js/64.fa584f9a.js"><link rel="prefetch" href="/docs/assets/js/65.6d88f682.js"><link rel="prefetch" href="/docs/assets/js/66.985f03af.js"><link rel="prefetch" href="/docs/assets/js/67.88a98e0a.js"><link rel="prefetch" href="/docs/assets/js/68.c7c47d1b.js"><link rel="prefetch" href="/docs/assets/js/69.33da3796.js"><link rel="prefetch" href="/docs/assets/js/7.85512783.js"><link rel="prefetch" href="/docs/assets/js/70.81f7edaf.js"><link rel="prefetch" href="/docs/assets/js/71.a85b93c4.js"><link rel="prefetch" href="/docs/assets/js/72.c774fb81.js"><link rel="prefetch" href="/docs/assets/js/73.7e1860e6.js"><link rel="prefetch" href="/docs/assets/js/74.0facc009.js"><link rel="prefetch" href="/docs/assets/js/75.d7abddf6.js"><link rel="prefetch" href="/docs/assets/js/76.34705196.js"><link rel="prefetch" href="/docs/assets/js/77.a13405a1.js"><link rel="prefetch" href="/docs/assets/js/78.78be9378.js"><link rel="prefetch" href="/docs/assets/js/79.5bf0c9a8.js"><link rel="prefetch" href="/docs/assets/js/8.496b7fc7.js"><link rel="prefetch" href="/docs/assets/js/80.992eb29f.js"><link rel="prefetch" href="/docs/assets/js/81.937a6202.js"><link rel="prefetch" href="/docs/assets/js/82.b89edfad.js"><link rel="prefetch" href="/docs/assets/js/83.b40dc6aa.js"><link rel="prefetch" href="/docs/assets/js/84.298a1afc.js"><link rel="prefetch" href="/docs/assets/js/85.3dc32b0f.js"><link rel="prefetch" href="/docs/assets/js/86.e1552d1c.js"><link rel="prefetch" href="/docs/assets/js/87.de879dc3.js"><link rel="prefetch" href="/docs/assets/js/88.3deecdb2.js"><link rel="prefetch" href="/docs/assets/js/89.28496a48.js"><link rel="prefetch" href="/docs/assets/js/9.14fb868b.js"><link rel="prefetch" href="/docs/assets/js/90.3659f703.js"><link rel="prefetch" href="/docs/assets/js/91.ccc29941.js"><link rel="prefetch" href="/docs/assets/js/92.b913c04e.js"><link rel="prefetch" href="/docs/assets/js/93.f04f0b9f.js"><link rel="prefetch" href="/docs/assets/js/94.65205100.js"><link rel="prefetch" href="/docs/assets/js/95.d34ca9ef.js"><link rel="prefetch" href="/docs/assets/js/96.424773ef.js"><link rel="prefetch" href="/docs/assets/js/97.278092eb.js"><link rel="prefetch" href="/docs/assets/js/98.f16322fc.js"><link rel="prefetch" href="/docs/assets/js/99.d53624d0.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.af9f351a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><!----> <span class="site-name">计算机基础教程</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/docs/" class="nav-link">
  机器指令
</a></div><div class="nav-item"><a href="/docs/software/" class="nav-link router-link-active">
  软件基础
</a></div><div class="nav-item"><a href="/docs/coder2hacker/" class="nav-link">
  白帽黑客
</a></div><div class="nav-item"><a href="/docs/blockchain/" class="nav-link">
  区块链
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/docs/" class="nav-link">
  机器指令
</a></div><div class="nav-item"><a href="/docs/software/" class="nav-link router-link-active">
  软件基础
</a></div><div class="nav-item"><a href="/docs/coder2hacker/" class="nav-link">
  白帽黑客
</a></div><div class="nav-item"><a href="/docs/blockchain/" class="nav-link">
  区块链
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/software/buildingblock/kafka_producer.html#关键配置" class="sidebar-link">关键配置</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#producer-client" class="sidebar-link">Producer Client</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#brokers" class="sidebar-link">Brokers</a></li></ul></li><li><a href="/docs/software/buildingblock/kafka_producer.html#客户端关键api及源码解读" class="sidebar-link">客户端关键API及源码解读</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#data-flow" class="sidebar-link">Data Flow</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#_1-finding-a-transaction-coordinator-the-findcoordinatorrequest" class="sidebar-link" style="padding-left:3rem;">1. Finding a transaction coordinator -- the FindCoordinatorRequest</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#_2-getting-a-producer-id-the-initpidrequest" class="sidebar-link" style="padding-left:3rem;">2. Getting a producer Id -- the InitPidRequest</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#_2-1-when-a-transactionalid-is-specified" class="sidebar-link" style="padding-left:4rem;">2.1 When a TransactionalId is specified</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#_2-2-when-a-transactionalid-is-not-specified" class="sidebar-link" style="padding-left:4rem;">2.2 When a TransactionalId is not specified</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#_3-starting-a-transaction-the-begintransaction-api" class="sidebar-link" style="padding-left:3rem;">3. Starting a Transaction -- the beginTransaction API</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#_4-the-consume-transform-produce-loop" class="sidebar-link" style="padding-left:3rem;">4. The consume-transform-produce loop</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#_4-1-addpartitionstotxnrequest" class="sidebar-link" style="padding-left:4rem;">4.1 AddPartitionsToTxnRequest</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#_4-2-producerequest" class="sidebar-link" style="padding-left:4rem;">4.2 ProduceRequest</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#_4-3-addoffsetstotxnrequest" class="sidebar-link" style="padding-left:4rem;">4.3 AddOffsetsToTxnRequest</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#_4-4-txnoffsetcommitrequest" class="sidebar-link" style="padding-left:4rem;">4.4 TxnOffsetCommitRequest</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#_5-committing-or-aborting-a-transaction" class="sidebar-link" style="padding-left:3rem;">5. Committing or Aborting a Transaction</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#_5-1-endtxnrequest" class="sidebar-link" style="padding-left:4rem;">5.1 EndTxnRequest</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#_5-2-writetxnmarkerrequest" class="sidebar-link" style="padding-left:4rem;">5.2 WriteTxnMarkerRequest</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#_5-3-writing-the-final-commit-or-abort-message" class="sidebar-link" style="padding-left:4rem;">5.3 Writing the final Commit or Abort Message</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#事务型-transactional-producer" class="sidebar-link">事务型 Transactional Producer</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#_1-inittransactions" class="sidebar-link" style="padding-left:3rem;">1. initTransactions</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#sender-就是kafkaproducer-新建并启动的新的线程runnable-sender" class="sidebar-link" style="padding-left:4rem;">Sender: 就是KafkaProducer 新建并启动的新的线程Runnable Sender</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#_2-begintransaction" class="sidebar-link" style="padding-left:3rem;">2. beginTransaction</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#_3-send" class="sidebar-link" style="padding-left:3rem;">3. send</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#send-详解" class="sidebar-link" style="padding-left:4rem;">Send 详解</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#_4-sendoffsetstotransaction" class="sidebar-link" style="padding-left:3rem;">4. sendOffsetsToTransaction</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#_5-committransaction-aborttransaction" class="sidebar-link" style="padding-left:3rem;">5. commitTransaction/abortTransaction</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#fence机制实例" class="sidebar-link" style="padding-left:3rem;">Fence机制实例</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#幂等性-idempotent-producer" class="sidebar-link">幂等性 idempotent producer</a></li></ul></li><li><a href="/docs/software/buildingblock/kafka_producer.html#brokers-服务端" class="sidebar-link">brokers 服务端</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#transaction-coordinator" class="sidebar-link">Transaction Coordinator</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#transaction-log" class="sidebar-link" style="padding-left:3rem;">Transaction Log</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#transaction-coordinator-startup" class="sidebar-link" style="padding-left:3rem;">Transaction Coordinator Startup</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#transaction-coordinator-request-handling" class="sidebar-link" style="padding-left:3rem;">Transaction Coordinator Request Handling</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#coordinator-side-transaction-expiration" class="sidebar-link" style="padding-left:3rem;">Coordinator-side Transaction Expiration</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#coordinator-transactionalid-expiration" class="sidebar-link" style="padding-left:3rem;">Coordinator TransactionalId Expiration</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#broker" class="sidebar-link">Broker</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#consumer-coordinator" class="sidebar-link">Consumer Coordinator</a></li></ul></li><li><a href="/docs/software/buildingblock/kafka_producer.html#troubleshooting" class="sidebar-link">Troubleshooting</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#error-codes" class="sidebar-link">ERROR CODES</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#inittransactions-timeoutexception" class="sidebar-link" style="padding-left:3rem;">initTransactions - TimeoutException</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#begintransaction-sendoffsetstotransaction-committransaction-aborttransaction-producerfencedexception" class="sidebar-link" style="padding-left:3rem;">beginTransaction / sendOffsetsToTransaction / commitTransaction / abortTransaction - ProducerFencedException</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#kafka某个节点所在机房突然断电又恢复后-transactional-producer异常" class="sidebar-link">kafka某个节点所在机房突然断电又恢复后 transactional producer异常</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#producerfencedexception" class="sidebar-link" style="padding-left:3rem;">ProducerFencedException</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#事情过程" class="sidebar-link" style="padding-left:4rem;">事情过程</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#the-client-hasn-t-received-acknowledgment-for-some-previously-sent-messages-and-can-no-longer-retry-them-it-isn-t-safe-to-continue" class="sidebar-link" style="padding-left:3rem;">The client hasn't received acknowledgment for some previously sent messages and can no longer retry them. It isn't safe to continue.</a></li><li class="sidebar-sub-header"><a href="/docs/software/buildingblock/kafka_producer.html#尝试解决" class="sidebar-link" style="padding-left:3rem;">尝试解决：</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>Since the 0.11.0.0 release, Kafka has added support to allow its producers to send messages to different topic partitions in a transactional and idempotent manner https://kafka.apache.org/documentation/#semantics</p> <p>https://kafka.apache.org/23/javadoc/index.html?org/apache/kafka/clients/producer/KafkaProducer.html</p> <h2 id="关键配置"><a href="#关键配置" class="header-anchor">#</a> 关键配置</h2> <h3 id="producer-client"><a href="#producer-client" class="header-anchor">#</a> Producer Client</h3> <ul><li><p>enable.idempotence
Whether or not idempotence is enabled (false by default). If disabled, the producer will not set the PID field in produce requests and the current producer delivery semantics will be in effect. Note that idempotence must be enabled in order to use transactions.</p> <p>When idempotence is enabled, we enforce that acks=all, retries &gt; 1, and max.inflight.requests.per.connection=1. Without these values for these configurations, we cannot guarantee idempotence. If these settings are not explicitly overridden by the application, the producer will set acks=all, retries=Integer.MAX_VALUE, and max.inflight.requests.per.connection=1 when idempotence is enabled.</p></li> <li><p>transactional.id</p> <p>For instance, in a distributed stream processing application, suppose topic-partition tp0 was originally processed by transactional.id T0. If, at some point later, it could be mapped to another producer with transactional.id T1, there would be no fencing between T0 and T1. So it is possible for messages from tp0 to be reprocessed, violating the exactly once processing guarantee.</p> <p>Practically, one would either have to store the mapping between input partitions and transactional.ids in an external store（存储每个partition和这个transactional.id的map）, or have some static encoding of it（设置为静态的变量，比如the transactionId Prefix appended with &lt;group.id&gt;.<topic>.<partition>.The drawback is that it will require separate transactional producer for each partition）.</partition></topic></p> <p>Note that enable.idempotence must be enabled if a TransactionalId is configured.</p></li> <li><p>delivery.timeout.ms
An upper bound on the time to report success or failure after a call to send() returns. This limits the total time that a record will be delayed prior to sending, the time to await acknowledgement from the broker (if expected), and the time allowed for retriable send failures. The producer may report failure to send a record earlier than this config if either an unrecoverable error is encountered, the retries have been exhausted, or the record is added to a batch which reached an earlier delivery expiration deadline. The value of this config should be greater than or equal to the sum of request.timeout.ms and linger.ms.</p> <p>Type:	int
Default:	120000 (2 minutes)
Valid Values:	[0,...]
Importance:	medium</p></li> <li><p>producer.id.expiration.ms
The time in ms that a topic partition leader will wait before expiring producer IDs. Producer IDs will not expire while a transaction associated to them is still ongoing. Note that producer IDs may expire sooner if the last write from the producer ID is deleted due to the topic's retention settings. Setting this value the same or higher than delivery.timeout.ms can help prevent expiration during retries and protect against message duplication, but the default should be reasonable for most use cases.
Type:	int
Default:	86400000 (1 day)
Valid Values:	[1,...]
Importance:	low
Update Mode:	cluster-wide</p></li> <li><p>transactional.id.expiration.ms
The time in ms that the transaction coordinator will wait without receiving any transaction status updates for the current transaction before expiring its transactional id. Transactional IDs will not expire while a the transaction is still ongoing.</p> <p>Type:	int
Default:	604800000 (7 days)
Valid Values:	[1,...]
Importance:	high
Update Mode:	read-only</p> <p>Internally broker keeps a map of producer IDs to transaction IDs to maintain aforementioned fencing functionality. However broker will expire these entries based on transactional.id.expiration.ms setting which is by default 604800000 ms or 1 week.</p> <p>This means that if your producer sends messages slower than once a week it will be fenced (crash) every time it tries to send after that prolonged period. One could put that value to Integer.MAX, but that still will be around 24 days. In case of very rare events, this should be solved differently, e.g. by having separate producer ping topic, that producer will periodically send messages to.</p></li> <li><p>transaction.timeout.ms
The maximum amount of time in ms that the transaction coordinator will wait for a transaction status update from the producer before proactively aborting the ongoing transaction.If this value is larger than the transaction.max.timeout.ms setting in the broker, the request will fail with a InvalidTxnTimeoutException error.</p> <p>This config value will be sent to the transaction coordinator along with the InitPidRequest.</p> <p>Default is 60000. This makes a transaction to not block downstream consumption more than a minute, which is generally allowable in real-time apps.</p> <p>Type:	int
Default:	60000 (1 minute)
Valid Values:	
Importance:	low</p></li> <li><p>retries = 2147483647
The default value for the producer's retries config was changed to Integer.MAX_VALUE, as we introduced delivery.timeout.ms in KIP-91, which sets an upper bound on the total time between sending a record and receiving acknowledgement from the broker. By default, the delivery timeout is set to 2 minutes.</p></li> <li><p>retry.backoff.ms = 150
The amount of time to wait before attempting to retry a failed request to a given topic partition. This avoids repeatedly sending requests in a tight loop under some failure scenarios.</p></li></ul> <h3 id="brokers"><a href="#brokers" class="header-anchor">#</a> Brokers</h3> <ul><li><p>transactional.id.expiration.ms	
The maximum amount of time in ms that the transaction coordinator will wait before proactively expire a producer TransactionalId without receiving any transaction status updates from it.</p> <p>Default is 604800000 (7 days). This allows periodic weekly producer jobs to maintain its id.</p></li> <li><p>max.transaction.timeout.ms	
The maximum allowed timeout for transactions. If a client’s requested transaction time exceeds this, then the broker will return an error in InitPidRequest. This prevents a client from too large of a timeout, which can stall consumers reading from topics included in the transaction.</p> <p>efault is 900000 (15 min). This is a conservative upper bound on the period of time a transaction of messages will need to be sent.</p></li> <li><p>transaction.state.log.min.isr	
The minimum number of insync replicas for the transaction state topic.
Default: 2</p></li> <li><p>transaction.state.log.replication.factor	
The number of replicas for the transaction state topic.
Default: 3</p></li> <li><p>transaction.state.log.num.partitions	
The number of partitions for the transaction state topic.
Default: 50</p></li> <li><p>transaction.state.log.segment.bytes	
The segment size for the transaction state topic.
Default: 104857600 bytes.</p></li> <li><p>transaction.state.log.load.buffer.size	
The loading buffer size for the transaction stat topic.
Default: 5242880 bytes.</p></li></ul> <h2 id="客户端关键api及源码解读"><a href="#客户端关键api及源码解读" class="header-anchor">#</a> 客户端关键API及源码解读</h2> <ul><li><p><strong>transaction coordinator</strong>
The first part of the design is to enable producers to send a group of messages as a single transaction that either succeeds or fails atomically. In order to achieve this, we introduce a new server-side module called transaction coordinator, to manage transactions of messages sent by producers, and commit / abort the appends of these messages as a whole.</p></li> <li><p><strong>transaction log</strong>
The transaction coordinator maintains a transaction log, which is stored as an internal topic (we call it the transaction topic) to persist transaction status for recovery. Similar to the “offsets log” which maintains consumer offsets and group state in the internal __consumer_offsets topic, producers do not read or write directly to the transaction topic. Instead they talk to their transaction coordinator who is the leader broker of the hosted partition of the topic. The coordinator can then append the new state of the indicated transactions to its owned transaction topic partition.</p></li> <li><p><strong>control message</strong>
For messages appended to Kafka log partitions, in order to indicate whether they are committed or aborted, a special type of message called control message will be used (some of the motivations are already discussed in KAFKA-1639). Control messages do not contain application data in the value payload and should not be exposed to applications. It is only used for internal communication between brokers and clients.</p></li> <li><p><strong>transaction markers</strong>
For producer transactions, we will introduce a set of transaction markers implemented as control messages, such that the consumer client can interpret them to determine whether any given message has been committed or aborted. And based on the transaction status, the consumer client can then determine whether and when to return these messages to the application.</p></li> <li><p><strong>Producer Identifiers and Idempotency</strong></p> <ul><li><strong>sequence number</strong>
Within a transaction, we also need to make sure that there is no duplicate messages generated by the producer. To achieve this, we are going to add sequence numbers to messages to allow the brokers to de-duplicate messages per producer and topic partition. For each topic partition that is written to, the producer maintains a sequence number counter and assigns the next number in the sequence for each new message. The broker verifies that the next message produced has been assigned the next number and otherwise returns an error.</li> <li><strong>TransactionalId &amp; epoch number</strong>
In addition, since the sequence number is per producer and topic partition, we also need to uniquely identify a producer across multiple sessions (i.e. when the producer fails and recreates, etc). Hence we introduce a new TransactionalId to distinguish producers, along with an epoch number so that zombie writers with the same TransactionalId can be fenced.</li></ul></li></ul> <p>producer id VS transaction id, transaction id是client端给Transactional producer设置的，而producer id是broker分配的，如果是Transactional producer，borker会维护 producer id和Transaction id的mapping:
[Producer clientId=producer-3, transactionalId=TEST-PROGRAM-TID-0]</p> <ul><li><strong>CorrelationId</strong>
This is a user-supplied integer. It will be passed back in the response by the server, unmodified. It is useful for matching request and response between the client and server.
correlationId is a per TCP connection artifact that allows the client (producer or consumer) to map a response from the broker to a previous request by the client, it has no meaning outside that specific TCP connection.</li></ul> <h3 id="data-flow"><a href="#data-flow" class="header-anchor">#</a> Data Flow</h3> <p><img src="/docs/docs_image/software/buildingblock/kafka/kafka_transactional_messaging_dataflow.png" alt=""></p> <p>In the diagram above, the sharp edged boxes represent distinct machines. The rounded boxes at the bottom represent Kafka topic partitions, and the diagonally rounded boxes represent logical entities which run inside brokers.
Each arrow represents either an RPC, or a write to a Kafka topic. These operations occur in the sequence indicated by the numbers next to each arrow. The sections below are numbered to match the operations in the diagram above, and describe the operation in question.</p> <h4 id="_1-finding-a-transaction-coordinator-the-findcoordinatorrequest"><a href="#_1-finding-a-transaction-coordinator-the-findcoordinatorrequest" class="header-anchor">#</a> 1. Finding a transaction coordinator -- the FindCoordinatorRequest</h4> <p>Since the transaction coordinator is at the center assigning PIDs and managing transactions,the first thing a producer has to do is issue a FindCoordinatorRequest (previously known as GroupCoordinatorRequest, but renamed for general usage) to any broker to discover the location of its coordinator. Note that if no TransactionalId is specified in the configuration, this step can be skipped.</p> <h4 id="_2-getting-a-producer-id-the-initpidrequest"><a href="#_2-getting-a-producer-id-the-initpidrequest" class="header-anchor">#</a> 2. Getting a producer Id -- the InitPidRequest</h4> <p>The producer must send an InitPidRequest to get idempotent delivery or to use transactions. Which semantics are allowed depends on whether or not the transactional.id configuration is provided or not.</p> <h5 id="_2-1-when-a-transactionalid-is-specified"><a href="#_2-1-when-a-transactionalid-is-specified" class="header-anchor">#</a> 2.1 When a TransactionalId is specified</h5> <p>After discovering the location of its coordinator, the next step is to retrieve the producer’s PID. This is achieved by sending an InitPidRequest to the transaction coordinator.
The TransactionalId is passed in the InitPidRequest along with the transaction timeout, and the mapping to the corresponding PID is logged in the transaction log in step 2a. This enables us to return the same PID for the TransactionalId to future instances of the producer, and hence enables recovering or aborting previously incomplete transactions.</p> <p>In addition to returning the PID, the InitPidRequest performs the following tasks:</p> <ul><li>Bumps up the epoch of the PID, so that any previous zombie instance of the producer is fenced off and cannot move forward with its transaction.</li> <li>Recovers (rolls forward or rolls back) any transaction left incomplete by the previous instance of the producer.</li></ul> <p>The handling of the InitPidRequest is synchronous. Once it returns, the producer can send data and start new transactions.</p> <h5 id="_2-2-when-a-transactionalid-is-not-specified"><a href="#_2-2-when-a-transactionalid-is-not-specified" class="header-anchor">#</a> 2.2 When a TransactionalId is not specified</h5> <p>If no TransactionalId is specified in the configuration, the InitPidRequest can be sent to any broker. A fresh PID is assigned, and the producer only enjoys idempotent semantics and transactional semantics within a single session.</p> <h4 id="_3-starting-a-transaction-the-begintransaction-api"><a href="#_3-starting-a-transaction-the-begintransaction-api" class="header-anchor">#</a> 3. Starting a Transaction -- the beginTransaction API</h4> <p>The new KafkaProducer will have a beginTransaction() method which has to be called to signal the start of a new transaction. The producer records local state indicating that the transaction has begun, but the transaction won’t begin from the coordinator’s perspective until the first record is sent.</p> <h4 id="_4-the-consume-transform-produce-loop"><a href="#_4-the-consume-transform-produce-loop" class="header-anchor">#</a> 4. The consume-transform-produce loop</h4> <p>In this stage, the producer begins to consume-transform-produce the messages that comprise the transaction. This is a long phase and is potentially comprised of multiple requests.</p> <h5 id="_4-1-addpartitionstotxnrequest"><a href="#_4-1-addpartitionstotxnrequest" class="header-anchor">#</a> 4.1 AddPartitionsToTxnRequest</h5> <p>The producer sends this request to the transaction coordinator the first time a new TopicPartition is written to as part of a transaction. The addition of this TopicPartition to the transaction is logged by the coordinator in step 4.1a. We need this information so that we can write the commit or abort markers to each TopicPartition (see section 5.2 for details). If this is the first partition added to the transaction, the coordinator will also start the transaction timer.</p> <h5 id="_4-2-producerequest"><a href="#_4-2-producerequest" class="header-anchor">#</a> 4.2 ProduceRequest</h5> <p>The producer writes a bunch of messages to the user’s TopicPartitions through one or more ProduceRequests (fired from the send method of the producer). These requests include the PID, epoch, and sequence number as denoted in 4.2a.</p> <h5 id="_4-3-addoffsetstotxnrequest"><a href="#_4-3-addoffsetstotxnrequest" class="header-anchor">#</a> 4.3 AddOffsetsToTxnRequest</h5> <p>The producer has a new sendOffsets API method, which enables the batching of consumed and produced messages. This method takes a map of the offsets to commit and a groupId argument, which corresponds to the name of the associated consumer group.
The sendOffsets method sends an AddOffsetsToTxnRequests with the groupId to the transaction coordinator, from which it can deduce the TopicPartition for this consumer group in the internal __consumer_offsets topic. The transaction coordinator logs the addition of this topic partition to the transaction log in step 4.3a.</p> <h5 id="_4-4-txnoffsetcommitrequest"><a href="#_4-4-txnoffsetcommitrequest" class="header-anchor">#</a> 4.4 TxnOffsetCommitRequest</h5> <p>Also as part of sendOffsets, the producer will send a TxnOffsetCommitRequest to the consumer coordinator to persist the offsets in the __consumer_offsets topic (step 4.4a). The consumer coordinator validates that the producer is allowed to make this request (and is not a zombie) by using the PID and producer epoch which are sent as part of this request.
The consumed offsets are not visible externally until the transaction is committed, the process for which we will discuss now.</p> <h4 id="_5-committing-or-aborting-a-transaction"><a href="#_5-committing-or-aborting-a-transaction" class="header-anchor">#</a> 5. Committing or Aborting a Transaction</h4> <p>Once the data has been written, the user must call the new commitTransaction or abortTransaction methods of the KafkaProducer. These methods will begin the process of committing or aborting the transaction respectively.</p> <h5 id="_5-1-endtxnrequest"><a href="#_5-1-endtxnrequest" class="header-anchor">#</a> 5.1 EndTxnRequest</h5> <p>When a producer is finished with a transaction, the newly introduced KafkaProducer.commitTranaction or KafkaProducer.abortTransaction must be called. The former makes the data produced in step 4 above available to downstream consumers. The latter effectively erases the produced data from the log: it will never be accessible to the user (at the READ_COMMITTED isolation level), ie. downstream consumers will read and discard the aborted messages.
Regardless of which producer method is called, the producer issues an EndTxnRequest to the transaction coordinator, with a field indicating whether the transaction is to be committed or aborted. Upon receiving this request, the coordinator:</p> <ol><li>Writes a PREPARE_COMMIT or PREPARE_ABORT message to the transaction log. (step 5.1a)</li> <li>Begins the process of writing the command messages known as COMMIT (or ABORT) markers to the user logs through the WriteTxnMarkerRequest. (see section 5.2 below).</li> <li>Finally writes the COMMITTED (or ABORTED) message to transaction log. (see 5.3 below).</li></ol> <h5 id="_5-2-writetxnmarkerrequest"><a href="#_5-2-writetxnmarkerrequest" class="header-anchor">#</a> 5.2 WriteTxnMarkerRequest</h5> <p>This request is issued by the transaction coordinator to the leader of each TopicPartition which is part of the transaction. Upon receiving this request, each broker will write a COMMIT(PID) or ABORT(PID) control message to the log. (step 5.2a)
This message indicates to consumers whether messages with the given PID should be delivered or dropped. As such, the broker will not return messages which have a PID (meaning these messages are part of a transaction) until it reads a corresponding COMMIT or ABORT message of that PID, at which point it will deliver or skip the messages respectively. In addition, in order to maintain offset ordering in message delivery, brokers would maintain an offset called last stable offset (LSO) below which all transactional messages have either been committed or aborted.
Note that, if the __consumer_offsets topic is one of the TopicPartitions in the transaction, the commit (or abort) marker is also written to the log, and the consumer coordinator is notified that it needs to materialize these offsets in the case of a commit or ignore them in the case of an abort (step 5.2a on the left).</p> <h5 id="_5-3-writing-the-final-commit-or-abort-message"><a href="#_5-3-writing-the-final-commit-or-abort-message" class="header-anchor">#</a> 5.3 Writing the final Commit or Abort Message</h5> <p>After all the commit or abort markers are written the data logs, the transaction coordinator writes the final COMMITTED or ABORTED message to the transaction log, indicating that the transaction is complete (step 5.3 in the diagram). At this point, most of the messages pertaining to the transaction in the transaction log can be removed.
We only need to retain the PID of the completed transaction along with a timestamp, so we can eventually remove the TransactionalId-&gt;PID mapping for the producer. See the Expiring PIDs section below.</p> <p>In the rest of this design doc we will provide a detailed description of the above data flow along with the proposed changes on different modules.</p> <h3 id="事务型-transactional-producer"><a href="#事务型-transactional-producer" class="header-anchor">#</a> 事务型 Transactional Producer</h3> <p><strong>Powers the applications to produce to multiple TopicPartitions atomically.</strong> All writes to these TopicPartitions will either succeed or fail as a single unit. The application must provide a unique id, TransactionalId, to the producer which is stable across all sessions of the application. There is a 1-1 mapping between TransactionalId and PID.</p> <p><img src="/docs/docs_image/software/buildingblock/kafka/kafka_producer_0.png" alt=""></p> <ul><li>initTransactions - Sets up a producer to use transactions.</li> <li>beginTransaction - Starts a new transaction.</li> <li>send messages - Almost ordinary production of messages, but with an extra step. We will get to it in a minute.</li> <li>sendOffsetsToTransaction - Notifies the broker about consumed offsets, which should be committed at the same time as the transaction.</li> <li>commitTransaction - This includes committing consumed offsets and marking produced messages as committed.</li></ul> <h4 id="_1-inittransactions"><a href="#_1-inittransactions" class="header-anchor">#</a> 1. initTransactions</h4> <p>**Summary: **
If you want to use transactions, you have to initialize some things upfront. This should be called once in the lifetime of your producer. This call involves resolving the state of the previous transactions, which might have been started by the previous instance of this producer. Maybe it crashed before committing a transaction, and we have to clean it up. This is the place where the fencing of an old producer is done.</p> <p>The following steps will be taken when initTransactions() is called:</p> <ol><li>If no TransactionalId has been provided in configuration, skip to step 3.</li> <li>Send a FindCoordinatorRequest with the configured TransactionalId and with CoordinatorType encoded as “transaction” to a random broker. Block for the corresponding response, which will return the assigned transaction coordinator for this producer.</li> <li>Send an InitPidRequest to the transaction coordinator or to a random broker if no TransactionalId was provided in configuration. Block for the corresponding response to get the returned PID.</li></ol> <p>**<a href="https://github.com/apache/kafka/blob/2.3/clients/src/main/java/org/apache/kafka/clients/producer/KafkaProducer.java#L618" target="_blank" rel="noopener noreferrer">SourceCode<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>: **</p> <div class="language- extra-class"><pre class="language-text"><code>    public void initTransactions() {
        throwIfNoTransactionManager();
        throwIfProducerClosed();
[4]     TransactionalRequestResult result = transactionManager.initializeTransactions();
        sender.wakeup();
        result.await(maxBlockTimeMs, TimeUnit.MILLISECONDS);
    }
</code></pre></div><p>We can see some preliminary checks. The first one ensures that we have set the transactional.id property.</p> <p>What is a transactional.id? It is a value that identifies a producer instance across restarts. If your particular service instance has a transactional.id 1234, after the restart it should still have a value of 1234. Although, it is tricky if you are using auto-assignment of partitions and multiple instances. This case is covered in the section: <a href="#fence%E6%9C%BA%E5%88%B6%E5%AE%9E%E4%BE%8B">“When Kafka transactions might fail”</a></p> <ul><li>In line 4 we are initializing producer’s internal transactionManager,
which is responsible for managing all transactions features of producer. The implementation looks like this <a href="https://github.com/apache/kafka/blob/2.3/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java#L275" target="_blank" rel="noopener noreferrer">(source code)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>:</li></ul> <div class="language- extra-class"><pre class="language-text"><code>    public synchronized TransactionalRequestResult initializeTransactions() {
        return handleCachedTransactionRequestResult(() -&gt; {
            transitionTo(State.INITIALIZING);
[4]         setProducerIdAndEpoch(ProducerIdAndEpoch.NONE);
[5]         InitProducerIdRequestData requestData = new InitProducerIdRequestData()
[6]                .setTransactionalId(transactionalId)
[7]                .setTransactionTimeoutMs(transactionTimeoutMs);
[8]         InitProducerIdHandler handler = new InitProducerIdHandler(new InitProducerIdRequest.Builder(requestData));
            enqueueRequest(handler);
            return handler.result;
        }, State.INITIALIZING);
    }

    private void enqueueRequest(TxnRequestHandler requestHandler) {
        log.debug(&quot;Enqueuing transactional request {}&quot;, requestHandler.requestBuilder());
        pendingRequests.add(requestHandler);
    }
</code></pre></div><p>The most important logic is contacting the remote transaction coordinator, which resides on a broker. This involves two steps:</p> <ul><li>Line 4 - 7 - We are preparing a request to the broker’s transaction coordinator. The producer includes transactional.id, and transaction timeout. This request is called InitProducerId.</li> <li>Line 8 - The aforementioned request is enqueued for sending. The class that is responsible for sending enqueued requests is called Sender, and it is a background thread created by every producer. Eventually, the request will be sent.</li></ul> <h5 id="sender-就是kafkaproducer-新建并启动的新的线程runnable-sender"><a href="#sender-就是kafkaproducer-新建并启动的新的线程runnable-sender" class="header-anchor">#</a> Sender: 就是KafkaProducer 新建并启动的新的线程Runnable Sender</h5> <div class="language- extra-class"><pre><code>```
KafkaProducer(Map&lt;String, Object&gt; configs,
              Serializer&lt;K&gt; keySerializer,
              Serializer&lt;V&gt; valueSerializer,
              Metadata metadata,
              KafkaClient kafkaClient,
              ProducerInterceptors interceptors,
              Time time) {
                this.sender = newSender(logContext, kafkaClient, this.metadata);
                String ioThreadName = NETWORK_THREAD_PREFIX + &quot; | &quot; + clientId;
                this.ioThread = new KafkaThread(ioThreadName, this.sender, true);
                this.ioThread.start();
｝
public class Sender implements Runnable {
    void run(long now) {
        if (transactionManager != null) {
        ........ 
                } else if (transactionManager.hasInFlightTransactionalRequest() || maybeSendTransactionalRequest(now)) {
            ........
    private boolean maybeSendTransactionalRequest(long now) {
        if (transactionManager.isCompleting() &amp;&amp; accumulator.hasIncomplete()) {
            if (transactionManager.isAborting())
                accumulator.abortUndrainedBatches(new KafkaException(&quot;Failing batch since transaction was aborted&quot;));
            // There may still be requests left which are being retried. Since we do not know whether they had
            // been successfully appended to the broker log, we must resend them until their final status is clear.
            // If they had been appended and we did not receive the error, then our sequence number would no longer
            // be correct which would lead to an OutOfSequenceException.
            if (!accumulator.flushInProgress())
                accumulator.beginFlush();
        }

        TransactionManager.TxnRequestHandler nextRequestHandler = transactionManager.nextRequestHandler(accumulator.hasIncomplete());
        if (nextRequestHandler == null)
            return false;

        AbstractRequest.Builder&lt;?&gt; requestBuilder = nextRequestHandler.requestBuilder();
        while (!forceClose) {
            Node targetNode = null;
            try {
                if (nextRequestHandler.needsCoordinator()) {
                    targetNode = transactionManager.coordinator(nextRequestHandler.coordinatorType());
                    if (targetNode == null) {
                        transactionManager.lookupCoordinator(nextRequestHandler);
                        break;
                    }
                    if (!NetworkClientUtils.awaitReady(client, targetNode, time, requestTimeoutMs)) {
                        transactionManager.lookupCoordinator(nextRequestHandler);
                        break;
                    }
                } else {
                    targetNode = awaitLeastLoadedNodeReady(requestTimeoutMs);
                }

                if (targetNode != null) {
                    if (nextRequestHandler.isRetry())
                        time.sleep(nextRequestHandler.retryBackoffMs());
                    ClientRequest clientRequest = client.newClientRequest(
                        targetNode.idString(), requestBuilder, now, true, requestTimeoutMs, nextRequestHandler);
                    transactionManager.setInFlightTransactionalRequestCorrelationId(clientRequest.correlationId());
                    log.debug(&quot;Sending transactional request {} to node {}&quot;, requestBuilder, targetNode);
                    client.send(clientRequest, now);
                    return true;
                }
            } catch (IOException e) {
                log.debug(&quot;Disconnect from {} while trying to send request {}. Going &quot; +
                        &quot;to back off and retry.&quot;, targetNode, requestBuilder, e);
                if (nextRequestHandler.needsCoordinator()) {
                    // We break here so that we pick up the FindCoordinator request immediately.
                    transactionManager.lookupCoordinator(nextRequestHandler);
                    break;
                }
            }
            time.sleep(retryBackoffMs);
            metadata.requestUpdate();
        }
        transactionManager.retry(nextRequestHandler);
        return true;
    }
```
</code></pre></div><p>What does the group coordinator do when it received an initProducerId call? First, it checks if it has any more information on this transactional.id.</p> <p>Here come the transaction states. A transaction is in one particular state and is allowed to switch to different states according to some rules. States and transitions look like this:</p> <p><img src="/docs/docs_image/software/buildingblock/kafka/kafka_transaction_state.png" alt=""></p> <p>In case there is no information about the transaction, the coordinator creates an Empty state. However, if there is already a transaction for this id, there are three possible results. Those depend on the transaction state:</p> <ul><li>Ongoing - There is an ongoing transaction started by the previous instance of the producer, so the broker will assume the old producer is dead, and abort this transaction. It has to do some cleaning, so it asks the new producer instance to retry later. While aborting the transaction, the broker will fence off the old producer preventing him from committing the transaction, if it was not dead but just disappear for a while.</li> <li>PrepareAbort or PrepareCommit - The transaction is in the middle of finishing. The coordinator is waiting for nodes taking part in the transaction to respond. When all of them will respond, the transaction will transition to CompleteAbort or CompleteCommit state, and the new producer can continue. In the meantime, the coordinator is asking the new producer to retry this request.</li> <li>CompleteAbort, CompleteCommit or Empty - There is no transaction in progress, so the new producer receives a producerId and a new epoch and can continue with making new transactions.</li></ul> <p>The response on a producer side is handled in InitProducerIdHandler in this way <a href="https://github.com/apache/kafka/blob/2.3/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java#L1126" target="_blank" rel="noopener noreferrer">(source code)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>:</p> <div class="language- extra-class"><pre class="language-text"><code>private class InitProducerIdHandler extends TxnRequestHandler {
    ........
    @Override
    public void handleResponse(AbstractResponse response) {
        InitProducerIdResponse initProducerIdResponse = (InitProducerIdResponse) response;
        Errors error = initProducerIdResponse.error();

        if (error == Errors.NONE) {
            ProducerIdAndEpoch producerIdAndEpoch = new ProducerIdAndEpoch(initProducerIdResponse.data.producerId(),
                    initProducerIdResponse.data.producerEpoch());
            setProducerIdAndEpoch(producerIdAndEpoch);
            transitionTo(State.READY);
            lastError = null;
            result.done();
        } else if (error == Errors.NOT_COORDINATOR || error == Errors.COORDINATOR_NOT_AVAILABLE) {
            lookupCoordinator(FindCoordinatorRequest.CoordinatorType.TRANSACTION, transactionalId);
            reenqueue();
        } else if (error == Errors.COORDINATOR_LOAD_IN_PROGRESS || error == Errors.CONCURRENT_TRANSACTIONS) {
            reenqueue();
        } else if (error == Errors.TRANSACTIONAL_ID_AUTHORIZATION_FAILED) {
            fatalError(error.exception());
        } else {
            fatalError(new KafkaException(&quot;Unexpected error in InitProducerIdResponse; &quot; + error.message()));
        }
    }
</code></pre></div><p>As you see, in case of no error, the producer remembers the producerId and producerEpoch. Those values are used for fencing zombie producers. In case this producer becomes a zombie, while another one comes and replaces it when the zombie producer gets back to live, it will realize that it has been replaced, because Kafka will not allow it to do anything with the transaction.</p> <p>On the other hand, if the producer sees an error regarding the coordinator not being wrong or not ready, it will retry the request. Retry will also happen when the broker is in the middle of finishing transaction (states: PrepareAbort and PrepareCommit)</p> <p>Any other error will result in you receiving an exception.</p> <h4 id="_2-begintransaction"><a href="#_2-begintransaction" class="header-anchor">#</a> 2. beginTransaction</h4> <p>**Summary: **
Right now we have a producer ready to start the transaction. It received its producerId and epoch, so Kafka knows about it. We are ready to begin. We start the first transaction by calling beginTransaction.</p> <p>The following steps are executed on the producer when beginTransaction is called:</p> <ol><li>Check if the producer is transactional (i.e. init has been called), if not throw an exception (we omit this step in the rest of the APIs, but they all need to execute it).</li> <li>Check whether a transaction has already been started. If so, raise an exception.</li></ol> <p><a href="https://github.com/apache/kafka/blob/2.3/clients/src/main/java/org/apache/kafka/clients/producer/KafkaProducer.java#L639" target="_blank" rel="noopener noreferrer"><strong>(source code)</strong><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language- extra-class"><pre class="language-text"><code>public void beginTransaction() throws ProducerFencedException {
    throwIfNoTransactionManager();
    throwIfProducerClosed();
    transactionManager.beginTransaction();
}
</code></pre></div><p>This code validates if we are dealing with a transactional producer in the first place, or if we have not closed the producer. After that it forwards the call to the TransactionManager <a href="https://github.com/apache/kafka/blob/2.3/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java#L288" target="_blank" rel="noopener noreferrer">(source code)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>:</p> <div class="language- extra-class"><pre class="language-text"><code>public synchronized void beginTransaction() {
        ensureTransactional();
        maybeFailWithError();
        transitionTo(State.IN_TRANSACTION);
    }
</code></pre></div><p>Here is also some validation. This time we switch producer to the IN_TRANSACTION state. This is it. No fancy calls to the broker. I guess this is just a precaution to prevent some coding errors we might introduce in our code, like forgetting to abort or commit the transaction, but trying to start a new one.</p> <h4 id="_3-send"><a href="#_3-send" class="header-anchor">#</a> 3. send</h4> <p>**Summary: **
we are publishing the events.</p> <p>With an ongoing transaction (i.e. after beginTransaction is called but before commitTransaction or abortTransaction is called), the producer will maintain the set of partitions it has produced to. When send is called, the following steps will be added:</p> <ol><li>Check if the producer has a PID. If not, send an InitPidRequest following the procedure above.</li> <li>Check whether a transaction is ongoing. If so, check if the destination topic partition is in the list of produced partitions. If not, then send an AddPartitionToTxnRequest to the transaction coordinator. Block until the corresponding response is received, and update the set. This ensures that the coordinator knows which partitions have been included in the transaction before any data has been written.</li></ol> <p>Discussion on Thread Safety. The transactional producer can only have one outstanding transaction at any given time. A call to beginTransaction() with another ongoing transaction is treated as an error. Once a transaction begins, it is possible to use the send() API from multiple threads, but there must be one and only one subsequent call to commitTransaction() or abortTransaction().
Note that with a non-transactional producer, the first send call will be blocking for two round trips (GroupCoordinatorRequest and InitPidRequest).</p> <p>Deep inside the send method you can find a call to the transactionManager’s method <a href="https://github.com/apache/kafka/blob/2.3/clients/src/main/java/org/apache/kafka/clients/producer/KafkaProducer.java#L914" target="_blank" rel="noopener noreferrer">(source code)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>:</p> <div class="language- extra-class"><pre class="language-text"><code>private Future&lt;RecordMetadata&gt; doSend(ProducerRecord&lt;K, V&gt; record, Callback callback) {
    .........
    serializedValue = valueSerializer.serialize(record.topic(), record.headers(), record.value());
    .........
    int partition = partition(record, serializedKey, serializedValue, cluster);
    tp = new TopicPartition(record.topic(), partition);
    .........
    if (transactionManager != null &amp;&amp; transactionManager.isTransactional())
        transactionManager.maybeAddPartitionToTransaction(tp);
</code></pre></div><p>If we jump a little further <a href="https://github.com/apache/kafka/blob/2.3/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java#L340" target="_blank" rel="noopener noreferrer">(source code)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>:</p> <div class="language- extra-class"><pre class="language-text"><code>    public synchronized void maybeAddPartitionToTransaction(TopicPartition topicPartition) {
        failIfNotReadyForSend();

        if (isPartitionAdded(topicPartition) || isPartitionPendingAdd(topicPartition))
            return;

        log.debug(&quot;Begin adding new partition {} to transaction&quot;, topicPartition);
[8]     newPartitionsInTransaction.add(topicPartition);
    }
</code></pre></div><p>Take a look at lines 8. Producer is adding partition to newPartitionsInTransaction. It's simple data structures (Set), so do not have any logic, but it remember what partitions take part in a transaction.</p> <p>You might ask, when does the Kafka broker gets to know that those partitions are part of a transaction?</p> <p>The thing is, Kafka producer does not send records immediately. It batches those records, and the internal thread periodically sends them. The aforementioned Sender class takes care of it and in the very same place lies a request informing coordinator about new partitions in a transaction. If you head over to Sender code you can find a method that is responsible for one single run of an almost endless loop. The short version without all the boilerplate looks like this <a href="https://github.com/apache/kafka/blob/2.3/clients/src/main/java/org/apache/kafka/clients/producer/internals/Sender.java#L299" target="_blank" rel="noopener noreferrer">(source code)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>:</p> <div class="language- extra-class"><pre class="language-text"><code>void run(long now) {
        if (transactionManager != null) {
            try {
                if (transactionManager.shouldResetProducerStateAfterResolvingSequences())
                    // Check if the previous run expired batches which requires a reset of the producer state.
                    transactionManager.resetProducerId();
                if (!transactionManager.isTransactional()) {
                    // this is an idempotent producer, so make sure we have a producer id
                    maybeWaitForProducerId();
                } else if (transactionManager.hasUnresolvedSequences() &amp;&amp; !transactionManager.hasFatalError()) {
                    transactionManager.transitionToFatalError(
                        new KafkaException(&quot;The client hasn't received acknowledgment for &quot; +
                            &quot;some previously sent messages and can no longer retry them. It isn't safe to continue.&quot;));
                } else if (transactionManager.hasInFlightTransactionalRequest() || maybeSendTransactionalRequest(now)) {
                    // as long as there are outstanding transactional requests, we simply wait for them to return
                    client.poll(retryBackoffMs, now);
                    return;
                }
</code></pre></div><p>If we jump further to maybeSendTransactionalRequest() implementation, and later on to the transaction manager, we will see <a href="https://github.com/apache/kafka/blob/2.3/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java#L724" target="_blank" rel="noopener noreferrer">(source code)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>:</p> <div class="language- extra-class"><pre class="language-text"><code>private boolean maybeSendTransactionalRequest(long now) {
        if (transactionManager.isCompleting() &amp;&amp; accumulator.hasIncomplete()) {
            if (transactionManager.isAborting())
                accumulator.abortUndrainedBatches(new KafkaException(&quot;Failing batch since transaction was aborted&quot;));
            // There may still be requests left which are being retried. Since we do not know whether they had
            // been successfully appended to the broker log, we must resend them until their final status is clear.
            // If they had been appended and we did not receive the error, then our sequence number would no longer
            // be correct which would lead to an OutOfSequenceException.
            if (!accumulator.flushInProgress())
                accumulator.beginFlush();
        }

        TransactionManager.TxnRequestHandler nextRequestHandler = transactionManager.nextRequestHandler(accumulator.hasIncomplete());
        if (nextRequestHandler == null)
            return false;
=&gt;
这里的newPartitionsInTransaction就是上面doSend里面将新的Transaction添加进入的那个Set，KafkaProducer启动的Sender线程在run的时候会调用这个同步的程序nextRequestHandler，然后前面doSend添加到了newPartitionsInTransaction 所以非空调用 enqueueRequest(addPartitionsToTransactionHandler());
synchronized TxnRequestHandler nextRequestHandler(boolean hasIncompleteBatches) {
        if (!newPartitionsInTransaction.isEmpty())
            enqueueRequest(addPartitionsToTransactionHandler());

        TxnRequestHandler nextRequestHandler = pendingRequests.peek();
        if (nextRequestHandler == null)
            return null;

        // Do not send the EndTxn until all batches have been flushed
        if (nextRequestHandler.isEndTxn() &amp;&amp; hasIncompleteBatches)
            return null;

        pendingRequests.poll();
        if (maybeTerminateRequestWithError(nextRequestHandler)) {
            log.trace(&quot;Not sending transactional request {} because we are in an error state&quot;,
                    nextRequestHandler.requestBuilder());
            return null;
        }

        if (nextRequestHandler.isEndTxn() &amp;&amp; !transactionStarted) {
            nextRequestHandler.result.done();
            if (currentState != State.FATAL_ERROR) {
                log.debug(&quot;Not sending EndTxn for completed transaction since no partitions &quot; +
                        &quot;or offsets were successfully added&quot;);
                completeTransaction();
            }
            nextRequestHandler = pendingRequests.poll();
        }

        if (nextRequestHandler != null)
            log.trace(&quot;Request {} dequeued for sending&quot;, nextRequestHandler.requestBuilder());

        return nextRequestHandler;
    }
=》
enqueueRequest(addPartitionsToTransactionHandler())：
private synchronized TxnRequestHandler addPartitionsToTransactionHandler() {
        pendingPartitionsInTransaction.addAll(newPartitionsInTransaction);
        newPartitionsInTransaction.clear();
        AddPartitionsToTxnRequest.Builder builder = new AddPartitionsToTxnRequest.Builder(transactionalId,
                producerIdAndEpoch.producerId, producerIdAndEpoch.epoch, new ArrayList&lt;&gt;(pendingPartitionsInTransaction));
        return new AddPartitionsToTxnHandler(builder);
    }
private void enqueueRequest(TxnRequestHandler requestHandler) {
        log.debug(&quot;Enqueuing transactional request {}&quot;, requestHandler.requestBuilder());
        pendingRequests.add(requestHandler);
    }
</code></pre></div><h5 id="send-详解"><a href="#send-详解" class="header-anchor">#</a> Send 详解</h5> <div class="language- extra-class"><pre class="language-text"><code> private Future&lt;RecordMetadata&gt; doSend(ProducerRecord&lt;K, V&gt; record, Callback callback) {
        TopicPartition tp = null;
        try {
            throwIfProducerClosed();// 如果Producer已经关闭跑出异常
            // 1.首先确保topic的metadata可用
            ClusterAndWaitTime clusterAndWaitTime;
            try {
                clusterAndWaitTime = waitOnMetadata(record.topic(), record.partition(), maxBlockTimeMs);
            } catch (KafkaException e) {
                // matadata关闭抛出异常
                if (metadata.isClosed())
                    throw new KafkaException(&quot;Producer closed while send in progress&quot;, e);
                throw e;
            }
            long remainingWaitMs = Math.max(0, maxBlockTimeMs - clusterAndWaitTime.waitedOnMetadataMs);
            Cluster cluster = clusterAndWaitTime.cluster;
            // 2.序列化record的topic,header,Key,Value
            byte[] serializedKey;
            try {
                serializedKey = keySerializer.serialize(record.topic(), record.headers(), record.key());
            } catch (ClassCastException cce) {
                throw new SerializationException(&quot;Can't convert key of class &quot; + record.key().getClass().getName() +
                        &quot; to class &quot; + producerConfig.getClass(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG).getName() +
                        &quot; specified in key.serializer&quot;, cce);
            }
            byte[] serializedValue;
            try {
                serializedValue = valueSerializer.serialize(record.topic(), record.headers(), record.value());
            } catch (ClassCastException cce) {
                throw new SerializationException(&quot;Can't convert value of class &quot; + record.value().getClass().getName() +
                        &quot; to class &quot; + producerConfig.getClass(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG).getName() +
                        &quot; specified in value.serializer&quot;, cce);
            }
            // 3.获取record的partition的值(可以在Record指定,也可以根据算法生成)
            int partition = partition(record, serializedKey, serializedValue, cluster);
            tp = new TopicPartition(record.topic(), partition);

            setReadOnly(record.headers());
            Header[] headers = record.headers().toArray();

            int serializedSize = AbstractRecords.estimateSizeInBytesUpperBound(apiVersions.maxUsableProduceMagic(),
                    compressionType, serializedKey, serializedValue, headers);
            ensureValidRecordSize(serializedSize); // 如果record的字节超出限制或大于内存限制,会抛出异常
            long timestamp = record.timestamp() == null ? time.milliseconds() : record.timestamp();
            log.trace(&quot;Sending record {} with callback {} to topic {} partition {}&quot;, record, callback, record.topic(), partition);
            // producer callback will make sure to call both 'callback' and interceptor callback
            Callback interceptCallback = new InterceptorCallback&lt;&gt;(callback, this.interceptors, tp);

            if (transactionManager != null &amp;&amp; transactionManager.isTransactional())
                transactionManager.maybeAddPartitionToTransaction(tp);

            // 4.向accumulator追加数据
            RecordAccumulator.RecordAppendResult result = accumulator.append(tp, timestamp, serializedKey,
                    serializedValue, headers, interceptCallback, remainingWaitMs);
            // 5.如果batch满了,唤醒sender线程发送数据
            if (result.batchIsFull || result.newBatchCreated) {
                log.trace(&quot;Waking up the sender since topic {} partition {} is either full or getting a new batch&quot;, record.topic(), partition);
                this.sender.wakeup();
            }
            return result.future;


</code></pre></div><p>=》获取topic的metadata信息</p> <div class="language- extra-class"><pre class="language-text"><code>// 等待Metadata的更新
private ClusterAndWaitTime waitOnMetadata(String topic, Integer partition, long maxWaitMs) throws InterruptedException {
    // 将topic添加到元数据topic列表（如果尚未存在），并重置过期时间
    Cluster cluster = metadata.fetch();

    if (cluster.invalidTopics().contains(topic))
        throw new InvalidTopicException(topic);

    metadata.add(topic);

    Integer partitionsCount = cluster.partitionCountForTopic(topic); // 如果topic已经存在meta中,则返回该topic的partition数,否则返回null
    // 如果有缓存的元数据,并且记录的分区未定义或在已知分区范围内,则返回该元数据
    if (partitionsCount != null &amp;&amp; (partition == null || partition &lt; partitionsCount))
        return new ClusterAndWaitTime(cluster, 0);

    long begin = time.milliseconds();
    long remainingWaitMs = maxWaitMs;
    long elapsed;
    // 发送metadata请求,直到获取这个topic的metadata或者请求超时
    do {
        log.trace(&quot;Requesting metadata update for topic {}.&quot;, topic);
        metadata.add(topic);
        int version = metadata.requestUpdate(); // 返回当前版本号,初始值为0,每次更新时会自增,并将needUpdate设置为true
        sender.wakeup(); // 唤起sender,发送metadata请求
        try {
            metadata.awaitUpdate(version, remainingWaitMs); // 等待metadata的更新
        } catch (TimeoutException ex) {
            // Rethrow with original maxWaitMs to prevent logging exception with remainingWaitMs
            throw new TimeoutException(&quot;Failed to update metadata after &quot; + maxWaitMs + &quot; ms.&quot;);
        }
        cluster = metadata.fetch();
        elapsed = time.milliseconds() - begin;
        if (elapsed &gt;= maxWaitMs)
            throw new TimeoutException(&quot;Failed to update metadata after &quot; + maxWaitMs + &quot; ms.&quot;); // 超时
        if (cluster.unauthorizedTopics().contains(topic))
            throw new TopicAuthorizationException(topic); // 认证失败
        if (cluster.invalidTopics().contains(topic))
            throw new InvalidTopicException(topic);
        remainingWaitMs = maxWaitMs - elapsed;
        partitionsCount = cluster.partitionCountForTopic(topic);
    } while (partitionsCount == null); // 不停循环,直到partitionsCount不为null(直到metadata出现这个topic的相关信息)

    if (partition != null &amp;&amp; partition &gt;= partitionsCount) {
        throw new KafkaException(
                String.format(&quot;Invalid partition given with record: %d is not in the range [0...%d).&quot;, partition, partitionsCount));
    }

    return new ClusterAndWaitTime(cluster, elapsed);
}
</code></pre></div><p>=&gt;Metadata更新操作</p> <div class="language- extra-class"><pre class="language-text"><code>// 更新metadata信息(根据version值判断)
public synchronized void awaitUpdate(final int lastVersion, final long maxWaitMs) throws InterruptedException {
    if (maxWaitMs &lt; 0)
        throw new IllegalArgumentException(&quot;Max time to wait for metadata updates should not be &lt; 0 milliseconds&quot;);
    long begin = System.currentTimeMillis();
    long remainingWaitMs = maxWaitMs;
    while ((this.version &lt;= lastVersion) &amp;&amp; !isClosed()) { // 不断循环,直到metadata更新成功,version自增
        AuthenticationException ex = getAndClearAuthenticationException();
        if (ex != null)
            throw ex;
        if (remainingWaitMs != 0)
            wait(remainingWaitMs); // 阻塞线程,等待metadata更新
        long elapsed = System.currentTimeMillis() - begin;
        if (elapsed &gt;= maxWaitMs) // 超时
            throw new TimeoutException(&quot;Failed to update metadata after &quot; + maxWaitMs + &quot; ms.&quot;);
        remainingWaitMs = maxWaitMs - elapsed;
    }
    if (isClosed())
        throw new KafkaException(&quot;Requested metadata update after close&quot;);
}
</code></pre></div><p>至此,Producer线程会阻塞在两个while循环中,直到metadata更新.metadata更新主要通过sender.wakeup()来唤醒sender线程,间接唤醒NetworkClient线程,NetworkClient线程来负责发送Metadata请求,并处理Server端的响应.在唤醒NetworkClient后会调用poll方法进行实际操作,如下:</p> <p>唤醒 sender:</p> <div class="language- extra-class"><pre class="language-text"><code>void run(long now) {
        if (transactionManager != null) {
            try {
                .......
                } else if (transactionManager.hasInFlightTransactionalRequest() || maybeSendTransactionalRequest(now)) {
                    // as long as there are outstanding transactional requests, we simply wait for them to return
                    client.poll(retryBackoffMs, now);
                    return;
                }
</code></pre></div><p>client.poll=&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>package org.apache.kafka.clients;
public class NetworkClient implements KafkaClient {
    @Override
    public List&lt;ClientResponse&gt; poll(long timeout, long now) {
        if (!abortedSends.isEmpty()) {
            // If there are aborted sends because of unsupported version exceptions or disconnects,
            // handle them immediately without waiting for Selector#poll.
            List&lt;ClientResponse&gt; responses = new ArrayList&lt;&gt;();
            handleAbortedSends(responses);
            completeResponses(responses);
            return responses;
        }

        long metadataTimeout = metadataUpdater.maybeUpdate(now); // 判断是否需要更新meta,如果需要就更新(请求更新metadata的地方)
        try {
            this.selector.poll(Utils.min(timeout, metadataTimeout, defaultRequestTimeoutMs));
        } catch (IOException e) {
            log.error(&quot;Unexpected error during I/O&quot;, e);
        }

        // process completed actions
        long updatedNow = this.time.milliseconds();
        List&lt;ClientResponse&gt; responses = new ArrayList&lt;&gt;();
        // 通过selector中获取Server端的response
        //  for (Send send : this.selector.completedSends()) {
        handleCompletedSends(responses, updatedNow); 
        // 在返回的handler中,会处理metadata的更新
        // metadataUpdater.handleCompletedMetadataResponse(req.header, now, (MetadataResponse) body);
        handleCompletedReceives(responses, updatedNow); 
        handleDisconnections(responses, updatedNow);
        handleConnections();
        handleInitiateApiVersionRequests(updatedNow);
        handleTimedOutRequests(responses, updatedNow);
        completeResponses(responses);

        return responses;
    }
=&gt; 判断Metadata是否需要更新,如果需要更新,先与Broker建立连接,然后发送更新metadata请求
    public long maybeUpdate(long now) {
        // should we update our metadata?
        // metadata是否应该更新
        long timeToNextMetadataUpdate = metadata.timeToNextUpdate(now); // metadata下次更新的时间(需要判断是强制更新还是metadata过期更新,前者是立马更新,后者是计算metadata的过期时间)
        // 如果一条metadata的fetch请求还未从server收到回复,那么时间设置为waitForMetadataFetch(默认30s)
        long waitForMetadataFetch = this.metadataFetchInProgress ? defaultRequestTimeoutMs : 0;

        long metadataTimeout = Math.max(timeToNextMetadataUpdate, waitForMetadataFetch);

        if (metadataTimeout &gt; 0) { // 时间未到时,直接返回下次应该更新的时间
            return metadataTimeout;
        }

        // 选择一个连接数最小的节点
        Node node = leastLoadedNode(now);
        if (node == null) {
            log.debug(&quot;Give up sending metadata request since no node is available&quot;);
            return reconnectBackoffMs;
        }

        return maybeUpdate(now, node); // 可以发送metadata请求的话,就发送metadata请求
    }

    // 判断是否可以发送请求,可以的话将metadata请求加入到发送列表中
    private long maybeUpdate(long now, Node node) {
        String nodeConnectionId = node.idString();
        if (canSendRequest(nodeConnectionId, now)) { // 通道已经准备好,并且支持发送更多的请求
            this.metadataFetchInProgress = true; // 准备开始发送数据,将metadataFetchInProgress置为true
            MetadataRequest.Builder metadataRequest; // // 创建metadata请求
            if (metadata.needMetadataForAllTopics()) // 强制更新所有topic的metadata(虽然默认不会更新所有topic的 metadata信息,但是每个Broker会保存所有topic的meta信息)
                metadataRequest = MetadataRequest.Builder.allTopics();
            else // 只更新metadata中的topics列表(列表中的topics由metadata.add()得到)
                metadataRequest = new MetadataRequest.Builder(new ArrayList&lt;&gt;(metadata.topics()),
                        metadata.allowAutoTopicCreation());
            log.debug(&quot;Sending metadata request {} to node {}&quot;, metadataRequest, node);
            sendInternalMetadataRequest(metadataRequest, nodeConnectionId, now); // 发送metadata请求
            return defaultRequestTimeoutMs;
        }
        // 如果client正在与任何一个node的连接状态是connecting,那么就进行等待
        if (isAnyNodeConnecting()) {
            // Strictly the timeout we should return here is &quot;connect timeout&quot;, but as we don't
            // have such application level configuration, using reconnect backoff instead.
            return reconnectBackoffMs;
        }
        // 如果没有连接这个node,那就初始化连接
        if (connectionStates.canConnect(nodeConnectionId, now)) {
            // we don't have a connection to this node right now, make one
            log.debug(&quot;Initialize connection to node {} for sending metadata request&quot;, node);
            initiateConnect(node, now); // 初始化连接
            return reconnectBackoffMs;
        }
        // connected, but can't send more OR connecting
        // In either case, we just need to wait for a network event to let us know the selected
        // connection might be usable again.
        return Long.MAX_VALUE;
    }

    // 发送metadata请求
    private void sendInternalMetadataRequest(MetadataRequest.Builder builder,String nodeConnectionId, long now) {
        ClientRequest clientRequest = newClientRequest(nodeConnectionId, builder, now, true);
        doSend(clientRequest, true, now);
    }

    / 处理任何已经完成的接收响应
    private void handleCompletedReceives(List&lt;ClientResponse&gt; responses, long now) {
        for (NetworkReceive receive : this.selector.completedReceives()) {
            String source = receive.source();
            InFlightRequest req = inFlightRequests.completeNext(source);
            Struct responseStruct = parseStructMaybeUpdateThrottleTimeMetrics(receive.payload(), req.header,
                throttleTimeSensor, now);
            if (log.isTraceEnabled()) {
                log.trace(&quot;Completed receive from node {} for {} with correlation id {}, received {}&quot;, req.destination,
                    req.header.apiKey(), req.header.correlationId(), responseStruct);
            }
            // If the received response includes a throttle delay, throttle the connection.
            AbstractResponse body = AbstractResponse.parseResponse(req.header.apiKey(), responseStruct);
            maybeThrottle(body, req.header.apiVersion(), req.destination, now);
            if (req.isInternalRequest &amp;&amp; body instanceof MetadataResponse) // 如果是meta响应
                metadataUpdater.handleCompletedMetadataResponse(req.header, now, (MetadataResponse) body);
            else if (req.isInternalRequest &amp;&amp; body instanceof ApiVersionsResponse)
                handleApiVersionsResponse(responses, req, now, (ApiVersionsResponse) body);
            else
                responses.add(req.completed(body, now));
        }
    }

class DefaultMetadataUpdater implements MetadataUpdater {
    / 处理Server端对Metadata请求处理后的响应
    @Override
    public void handleCompletedMetadataResponse(RequestHeader requestHeader, long now, MetadataResponse response) {
        this.metadataFetchInProgress = false;
        Cluster cluster = response.cluster();

        // If any partition has leader with missing listeners, log a few for diagnosing broker configuration
        // issues. This could be a transient issue if listeners were added dynamically to brokers.
        List&lt;TopicPartition&gt; missingListenerPartitions = response.topicMetadata().stream().flatMap(topicMetadata -&gt;
            topicMetadata.partitionMetadata().stream()
                .filter(partitionMetadata -&gt; partitionMetadata.error() == Errors.LISTENER_NOT_FOUND)
                .map(partitionMetadata -&gt; new TopicPartition(topicMetadata.topic(), partitionMetadata.partition())))
            .collect(Collectors.toList());
        if (!missingListenerPartitions.isEmpty()) {
            int count = missingListenerPartitions.size();
            log.warn(&quot;{} partitions have leader brokers without a matching listener, including {}&quot;,
                    count, missingListenerPartitions.subList(0, Math.min(10, count)));
        }

        // check if any topics metadata failed to get updated
        Map&lt;String, Errors&gt; errors = response.errors();
        if (!errors.isEmpty())
            log.warn(&quot;Error while fetching metadata with correlation id {} : {}&quot;, requestHeader.correlationId(), errors);

        // don't update the cluster if there are no valid nodes...the topic we want may still be in the process of being
        // created which means we will get errors and no nodes until it exists
        if (cluster.nodes().size() &gt; 0) {
            // 更新meta信息
            this.metadata.update(cluster, response.unavailableTopics(), now);
        } else {
            // 如果metadata中node信息无效,则不更新信息
            log.trace(&quot;Ignoring empty metadata response with correlation id {}.&quot;, requestHeader.correlationId());
            this.metadata.failedUpdate(now, null);
        }
    }

</code></pre></div><p>每次Producer请求更新metadata时的情况</p> <div class="language- extra-class"><pre><code>如果node可以发送请求,则直接发送请求
如果该node正在建立连接,则直接返回
如果该node还没建立连接,则向broker初始化连接
</code></pre></div><p>KafkaProducer线程被两个while循环阻塞,直到metadata更新</p> <div class="language- extra-class"><pre><code>sender线程第一次调用poll,初始化与node的连接 if (connectionStates.canConnect(nodeConnectionId, now)) {
sender线程第二次调用poll,发送Metadata请求   if (canSendRequest(nodeConnectionId, now)) {
sender线程第三次调用poll,获取metadataResponse,更新metadata  
</code></pre></div><p>当不阻塞之后,Producer才会开始发送信息
NetworkClient接收到Server端对Metadata请求的响应后,更新metadata信息</p> <p>KafkaProducer第一次发送信息时强制更新,其他时间周期性更新,通过lastRefreshMs,lastSuccessfulRefreshMs两个字段实现
强制更新:调用Metadata.requestUpdate()将needUpdate置为true</p> <p>Metadata更新策略
强制更新触发:
initConnect()初始化连接
poll()对handleDisconnections()处理连接断开情况
poll()对handleTimedOutRequests()处理请求超时
发送信息时找不到partition的leader
处理Producer响应(handleProduceResponse),如果返回关于metadata过期的异常</p> <p>强制更新主要用于处理各种异常情况</p> <p>获取Partition值</p> <div class="language- extra-class"><pre class="language-text"><code>// 1.指明partition的情况下,直接将指明的值作为partition值
// 2.没有指明partition值但有key的情况下,将key的hash值与topic的partition数进行取余得到partition值
// 3.既没有partition值又没有key值,第一次调用时随机生成一个整数(后面每次调用在这个整数上自增),将这个值与topic的partition数进行取余得到partition值(Round-robin算法)

// record有partition值时直接返回,不然调用partitioner的partition方法去计算
private int partition(ProducerRecord&lt;K, V&gt; record, byte[] serializedKey, byte[] serializedValue, Cluster cluster) {
    Integer partition = record.partition();
    return partition != null ?
            partition :
            partitioner.partition(
                    record.topic(), record.key(), serializedKey, record.value(), serializedValue, cluster);
}

// Producer默认使用DefaultPartitioner,可以自定义partition策略
public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) {
    List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);
    int numPartitions = partitions.size();
    if (keyBytes == null) { // 没有Key的情况下
        int nextValue = nextValue(topic); // 第一次生成随机整数,后面每次调用都自增
        List&lt;PartitionInfo&gt; availablePartitions = cluster.availablePartitionsForTopic(topic);
        // leader不为null,即为可用的partition
        if (availablePartitions.size() &gt; 0) {
            int part = Utils.toPositive(nextValue) % availablePartitions.size();
            return availablePartitions.get(part).partition();
        } else {
            // no partitions are available, give a non-available partition
            return Utils.toPositive(nextValue) % numPartitions;
        }
    } else { // 有Key的情况,使用key的hash值进行计算
        // hash the keyBytes to choose a partition
        return Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions;
    }
}

private int nextValue(String topic) {
    AtomicInteger counter = topicCounterMap.get(topic);
    if (null == counter) { // 第一次调用,随机整数
        counter = new AtomicInteger(ThreadLocalRandom.current().nextInt());
        AtomicInteger currentCounter = topicCounterMap.putIfAbsent(topic, counter);
        if (currentCounter != null) {
            counter = currentCounter;
        }
    }
    return counter.getAndIncrement(); // 自增
}      
</code></pre></div><p>向Accumulator写数据</p> <div class="language- extra-class"><pre class="language-text"><code>// Producer先将record写入到buffer中,当达到一个batch.size的大小时,唤起sender线程取发送ProducerBatch
// Producer通过RecordAccumulator实例追加数据,主要变量为ConcurrentMap&lt;TopicPartition, Deque&lt;ProducerBatch&gt;&gt; batches
// 每个TopicPartition都对应一个Deque&lt;ProducerBatch&gt;
// 当添加数据时,会向其topic-partition对应的这个queue最新创建的一个ProducerBatch中添加record
// 而发送数据时,则会先从queue中最老的那个RecordBatch开始发送

// 向accumulator添加一条record,并返回添加后的结果(结果包含,future metadata,batch是否满的标志以及新batch是否创建)
// 其中,maxTimeToBlock是buffer.memory的block的最大时间
public RecordAppendResult append(TopicPartition tp,
                                     long timestamp,
                                     byte[] key,
                                     byte[] value,
                                     Header[] headers,
                                     Callback callback,
                                     long maxTimeToBlock) throws InterruptedException {
    // We keep track of the number of appending thread to make sure we do not miss batches in
    // abortIncompleteBatches().
    appendsInProgress.incrementAndGet();
    ByteBuffer buffer = null;
    if (headers == null) headers = Record.EMPTY_HEADERS;
    try {
        // check if we have an in-progress batch
        Deque&lt;ProducerBatch&gt; dq = getOrCreateDeque(tp); // 每个topicPartition对应一个queue
        synchronized (dq) { // 在对一个queue进行操作时,会保证线程安全
            if (closed)
                throw new KafkaException(&quot;Producer closed while send in progress&quot;);
            RecordAppendResult appendResult = tryAppend(timestamp, key, value, headers, callback, dq); // 追加数据
            if (appendResult != null)
                return appendResult; // 这个topic-partition已经有记录了
        }

        // we don't have an in-progress record batch try to allocate a new batch
        // 为topic-partition创建一个新的ProducerBatch,需要初始化相应的ProducerBatch,要为其分配的大小是:max(batch.size,加上头文件的本条消息的大小)
        byte maxUsableMagic = apiVersions.maxUsableProduceMagic();
        int size = Math.max(this.batchSize, AbstractRecords.estimateSizeInBytesUpperBound(maxUsableMagic, compression, key, value, headers));
        log.trace(&quot;Allocating a new {} byte message buffer for topic {} partition {}&quot;, size, tp.topic(), tp.partition());
        buffer = free.allocate(size, maxTimeToBlock); // 给这个ProducerBatch初始化一个buffer
        synchronized (dq) {
            // Need to check if producer is closed again after grabbing the dequeue lock.
            if (closed)
                throw new KafkaException(&quot;Producer closed while send in progress&quot;);

            RecordAppendResult appendResult = tryAppend(timestamp, key, value, headers, callback, dq);
            if (appendResult != null) { // 如果突然发现这个queue已经存在,直接返回
                // Somebody else found us a batch, return the one we waited for! Hopefully this doesn't happen often...
                return appendResult;
            }

            // 给topic-partition创建一个ProducerBatch
            MemoryRecordsBuilder recordsBuilder = recordsBuilder(buffer, maxUsableMagic);
            ProducerBatch batch = new ProducerBatch(tp, recordsBuilder, time.milliseconds());
            // 向新的ProducerBatch中追加数据
            FutureRecordMetadata future = Utils.notNull(batch.tryAppend(timestamp, key, value, headers, callback, time.milliseconds()));

            // 将RecordBatch添加到对应的queue中
            dq.addLast(batch);
            // 向未ack的batch集合添加这个batch
            incomplete.add(batch);

            // Don't deallocate this buffer in the finally block as it's being used in the record batch
            buffer = null;
            // 如果dp.size()&gt;1就证明这个queue有一个batch是可以发送了
            return new RecordAppendResult(future, dq.size() &gt; 1 || batch.isFull(), true);
        }
    } finally {
        if (buffer != null)
            free.deallocate(buffer);
        appendsInProgress.decrementAndGet();
    }
}
</code></pre></div><p>发送ProducerBatch</p> <div class="language- extra-class"><pre class="language-text"><code>// 当record写入成功后,如果发现ProducerBatch满足发送的条件(通常是queue中有多个Batch,那么最先添加的batch肯定是可以发送的)
// 那么就会唤醒sender线程,发送ProducerBatch
// sender线程对ProducerBatch的处理是在run()方法中进行的
void run(long now) {
    if (transactionManager != null) {
        try {
            if (transactionManager.shouldResetProducerStateAfterResolvingSequences())
                // Check if the previous run expired batches which requires a reset of the producer state.
                transactionManager.resetProducerId();
            if (!transactionManager.isTransactional()) {
                // this is an idempotent producer, so make sure we have a producer id
                maybeWaitForProducerId();
            } else if (transactionManager.hasUnresolvedSequences() &amp;&amp; !transactionManager.hasFatalError()) {
                transactionManager.transitionToFatalError(
                    new KafkaException(&quot;The client hasn't received acknowledgment for &quot; +
                        &quot;some previously sent messages and can no longer retry them. It isn't safe to continue.&quot;));
            } else if (transactionManager.hasInFlightTransactionalRequest() || maybeSendTransactionalRequest(now)) {
                // as long as there are outstanding transactional requests, we simply wait for them to return
                client.poll(retryBackoffMs, now);
                return;
            }

            // do not continue sending if the transaction manager is in a failed state or if there
            // is no producer id (for the idempotent case).
            if (transactionManager.hasFatalError() || !transactionManager.hasProducerId()) {
                RuntimeException lastError = transactionManager.lastError();
                if (lastError != null)
                    maybeAbortBatches(lastError);
                client.poll(retryBackoffMs, now);
                return;
            } else if (transactionManager.hasAbortableError()) {
                accumulator.abortUndrainedBatches(transactionManager.lastError());
            }
        } catch (AuthenticationException e) {
            // This is already logged as error, but propagated here to perform any clean ups.
            log.trace(&quot;Authentication exception while processing transactional request: {}&quot;, e);
            transactionManager.authenticationFailed(e);
        }
    }

    // 发送Producer数据
    long pollTimeout = sendProducerData(now);
    client.poll(pollTimeout, now);
}

private long sendProducerData(long now) {
    Cluster cluster = metadata.fetch();
    // 获取那些已经可以发送的ProducerBatch对应的nodes
    RecordAccumulator.ReadyCheckResult result = this.accumulator.ready(cluster, now);

    // 如果有topic-partition的leader是未知的,就强制更新metadata
    if (!result.unknownLeaderTopics.isEmpty()) {
        for (String topic : result.unknownLeaderTopics)
            this.metadata.add(topic);

        log.debug(&quot;Requesting metadata update due to unknown leader topics from the batched records: {}&quot;,
            result.unknownLeaderTopics);
        this.metadata.requestUpdate();
    }

    // 如果与node没有连接(如果可以连接,同时初始化该连接),就证明该node暂时不能发送数据,暂时移除该node
    Iterator&lt;Node&gt; iter = result.readyNodes.iterator();
    long notReadyTimeout = Long.MAX_VALUE;
    while (iter.hasNext()) {
        Node node = iter.next();
        if (!this.client.ready(node, now)) {
            iter.remove();
            notReadyTimeout = Math.min(notReadyTimeout, this.client.pollDelayMs(node, now));
        }
    }

    // 返回该node对应的所有可以发送的ProducerBatch组成的batches(key是node.id),并将ProducerBatch从对应的queue中移除
    Map&lt;Integer, List&lt;ProducerBatch&gt;&gt; batches = this.accumulator.drain(cluster, result.readyNodes, this.maxRequestSize, now);
    addToInflightBatches(batches);
    if (guaranteeMessageOrder) {
        // 记录将要发送的ProducerBatch
        for (List&lt;ProducerBatch&gt; batchList : batches.values()) {
            for (ProducerBatch batch : batchList)
                this.accumulator.mutePartition(batch.topicPartition);
        }
    }

    accumulator.resetNextBatchExpiryTime();
    List&lt;ProducerBatch&gt; expiredInflightBatches = getExpiredInflightBatches(now);
    List&lt;ProducerBatch&gt; expiredBatches = this.accumulator.expiredBatches(now);
    expiredBatches.addAll(expiredInflightBatches);

    if (!expiredBatches.isEmpty())
        log.trace(&quot;Expired {} batches in accumulator&quot;, expiredBatches.size());
    // 将由于元数据不可用而导致发送超时的ProducerBatch移除
    for (ProducerBatch expiredBatch : expiredBatches) {
        String errorMessage = &quot;Expiring &quot; + expiredBatch.recordCount + &quot; record(s) for &quot; + expiredBatch.topicPartition
            + &quot;:&quot; + (now - expiredBatch.createdMs) + &quot; ms has passed since batch creation&quot;;
        failBatch(expiredBatch, -1, NO_TIMESTAMP, new TimeoutException(errorMessage), false);
        if (transactionManager != null &amp;&amp; expiredBatch.inRetry()) {
            transactionManager.markSequenceUnresolved(expiredBatch.topicPartition);
        }
    }
    sensors.updateProduceRequestMetrics(batches);

    long pollTimeout = Math.min(result.nextReadyCheckDelayMs, notReadyTimeout);
    pollTimeout = Math.min(pollTimeout, this.accumulator.nextExpiryTimeMs() - now);
    pollTimeout = Math.max(pollTimeout, 0);
    if (!result.readyNodes.isEmpty()) {
        log.trace(&quot;Nodes with data ready to send: {}&quot;, result.readyNodes);
        pollTimeout = 0;
    }
    // 发送ProducerBatch
    sendProduceRequests(batches, now);
    return pollTimeout;
}

private void sendProduceRequests(Map&lt;Integer, List&lt;ProducerBatch&gt;&gt; collated, long now) {
    for (Map.Entry&lt;Integer, List&lt;ProducerBatch&gt;&gt; entry : collated.entrySet())
        sendProduceRequest(now, entry.getKey(), acks, requestTimeoutMs, entry.getValue());
}

// 发送哦Produce请求
// 将batches中leader为同一个node的所有ProducerBatch放在一个请求中进行发送
private void sendProduceRequest(long now, int destination, short acks, int timeout, List&lt;ProducerBatch&gt; batches) {
    if (batches.isEmpty())
        return;

    Map&lt;TopicPartition, MemoryRecords&gt; produceRecordsByPartition = new HashMap&lt;&gt;(batches.size());
    final Map&lt;TopicPartition, ProducerBatch&gt; recordsByPartition = new HashMap&lt;&gt;(batches.size());

    // find the minimum magic version used when creating the record sets
    byte minUsedMagic = apiVersions.maxUsableProduceMagic();
    for (ProducerBatch batch : batches) {
        if (batch.magic() &lt; minUsedMagic)
            minUsedMagic = batch.magic();
    }

    for (ProducerBatch batch : batches) {
        TopicPartition tp = batch.topicPartition;
        MemoryRecords records = batch.records();

        // down convert if necessary to the minimum magic used. In general, there can be a delay between the time
        // that the producer starts building the batch and the time that we send the request, and we may have
        // chosen the message format based on out-dated metadata. In the worst case, we optimistically chose to use
        // the new message format, but found that the broker didn't support it, so we need to down-convert on the
        // client before sending. This is intended to handle edge cases around cluster upgrades where brokers may
        // not all support the same message format version. For example, if a partition migrates from a broker
        // which is supporting the new magic version to one which doesn't, then we will need to convert.
        if (!records.hasMatchingMagic(minUsedMagic))
            records = batch.records().downConvert(minUsedMagic, 0, time).records();
        produceRecordsByPartition.put(tp, records);
        recordsByPartition.put(tp, batch);
    }

    String transactionalId = null;
    if (transactionManager != null &amp;&amp; transactionManager.isTransactional()) {
        transactionalId = transactionManager.transactionalId();
    }
    ProduceRequest.Builder requestBuilder = ProduceRequest.Builder.forMagic(minUsedMagic, acks, timeout,
            produceRecordsByPartition, transactionalId);
    RequestCompletionHandler callback = new RequestCompletionHandler() {
        public void onComplete(ClientResponse response) {
            handleProduceResponse(response, recordsByPartition, time.milliseconds());
        }
    };

    String nodeId = Integer.toString(destination);
    ClientRequest clientRequest = client.newClientRequest(nodeId, requestBuilder, now, acks != 0,
            requestTimeoutMs, callback);
    client.send(clientRequest, now);
    log.trace(&quot;Sent produce request to {}: {}&quot;, nodeId, requestBuilder);
}
</code></pre></div><h4 id="_4-sendoffsetstotransaction"><a href="#_4-sendoffsetstotransaction" class="header-anchor">#</a> 4. sendOffsetsToTransaction</h4> <p>**Summary: **
Apart from adding newly produced messages to the transaction, we have to take care of consumed offsets, as those should be committed at the same time as the transaction,
adding those offsets to the transaction, so the transaction coordinator can commit them when we are done with the transaction.</p> <p>The following steps are executed on the producer when sendOffsetsToTransaction is called:</p> <ol><li>Check if it is currently within a transaction, if not throw an exception; otherwise proceed to the next step.</li> <li>Check if this function has ever been called for the given groupId within this transaction. If not then send an AddOffsetsToTxnRequest to the transaction coordinator, block until the corresponding response is received; otherwise proceed to the next step.</li> <li>Send a TxnOffsetCommitRequest to the coordinator return from the response in the previous step, block until the corresponding response is received.</li></ol> <p>**<a href="https://github.com/apache/kafka/blob/2.3/clients/src/main/java/org/apache/kafka/clients/producer/KafkaProducer.java#L669" target="_blank" rel="noopener noreferrer">SourceCode<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>: **</p> <div class="language- extra-class"><pre class="language-text"><code>    public void sendOffsetsToTransaction(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets,
                                     String consumerGroupId) throws ProducerFencedException {
        throwIfNoTransactionManager();
        throwIfProducerClosed();
[5]     TransactionalRequestResult result = transactionManager.sendOffsetsToTransaction(offsets, consumerGroupId);
[6]     sender.wakeup();
        result.await();
    }
</code></pre></div><p>This is fairly simple:</p> <div class="language- extra-class"><pre><code>Line 5 - We are preparing a request with consumed offsets and queueing it to be sent.
Line 6 - Here, the Sender thread is being wakened up. It will send the aforementioned request.
</code></pre></div><h4 id="_5-committransaction-aborttransaction"><a href="#_5-committransaction-aborttransaction" class="header-anchor">#</a> 5. commitTransaction/abortTransaction</h4> <p>**Summary: **
As a last step, the producer is informing the transaction coordinator that it should finish the transaction and inform all involved nodes about that:</p> <p>The following steps are executed on the producer when commitTransaction is called:</p> <ol><li>Check if there is an active transaction, if not throw an exception; otherwise proceed to the next step.</li> <li>Call flush to make sure all sent messages in this transactions are acknowledged.</li> <li>Send an EndTxnRequest with COMMIT command to the transaction coordinator, block until the corresponding response is received.</li></ol> <p>The following steps are executed on the producer when abortTransaction is called:</p> <ol><li>Check if there is an active transaction, if not throw an exception; otherwise proceed to the next step.</li> <li>Immediately fail and drop any buffered messages that are transactional. Await any in-flight messages which haven’t been acknowledged.</li> <li>Send an EndTxnRequest with ABORT command to the transaction coordinator, block until the corresponding response is received.</li></ol> <p>**<a href="https://github.com/apache/kafka/blob/2.3/clients/src/main/java/org/apache/kafka/clients/producer/KafkaProducer.java#L701" target="_blank" rel="noopener noreferrer">SourceCode<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>: **</p> <div class="language- extra-class"><pre class="language-text"><code>public void commitTransaction() throws ProducerFencedException {
    throwIfNoTransactionManager();
    throwIfProducerClosed();
    TransactionalRequestResult result = transactionManager.beginCommit();
    sender.wakeup();
    result.await(maxBlockTimeMs, TimeUnit.MILLISECONDS);
}
</code></pre></div><p>Similarly, to the sendOffsetsToTransaction, we see some simple validation, as well as preparation of a request, and queuing of it.</p> <p>What happens on a transaction coordinator’s side? I would like to cite the code, however, it is too complicated and fragmented. However, it is changing the transaction state to the PrepareCommit state, notifying all participants - partitions that have consumed offsets to commit and produced messages to mark as committed.</p> <p>After it collects all the responses it will change the state to CompleteCommit state. After that, you can be sure that the offsets are committed, and messages you have produced are available for consumption.</p> <h4 id="fence机制实例"><a href="#fence机制实例" class="header-anchor">#</a> Fence机制实例</h4> <p>下面图示来自<a href="https://tgrez.github.io/posts/2019-04-13-kafka-transactions.html" target="_blank" rel="noopener noreferrer">When Kafka transactions might fail<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
wrong:
<img src="/docs/docs_image/software/buildingblock/kafka/kafka_producer_1.png" alt=""> <img src="/docs/docs_image/software/buildingblock/kafka/kafka_producer_2.png" alt=""> <img src="/docs/docs_image/software/buildingblock/kafka/kafka_producer_3.png" alt=""> <img src="/docs/docs_image/software/buildingblock/kafka/kafka_producer_4.png" alt=""> <img src="/docs/docs_image/software/buildingblock/kafka/kafka_producer_5.png" alt=""> <img src="/docs/docs_image/software/buildingblock/kafka/kafka_producer_6.png" alt=""> <img src="/docs/docs_image/software/buildingblock/kafka/kafka_producer_7.png" alt=""></p> <p>correct:
<img src="/docs/docs_image/software/buildingblock/kafka/kafka_producer_8.png" alt=""> <img src="/docs/docs_image/software/buildingblock/kafka/kafka_producer_9.png" alt=""></p> <p>代码示例：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
<span class="token operator">--</span><span class="token operator">-</span> 正确：使用固定的 TRANSACTIONAL_ID_CONFIG
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
<span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> configs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
configs<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">ProducerConfig</span><span class="token punctuation">.</span>BOOTSTRAP_SERVERS_CONFIG<span class="token punctuation">,</span> <span class="token string">&quot;localhost:9092&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
configs<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">ProducerConfig</span><span class="token punctuation">.</span>KEY_SERIALIZER_CLASS_CONFIG<span class="token punctuation">,</span> <span class="token class-name">StringSerializer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
configs<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">ProducerConfig</span><span class="token punctuation">.</span>VALUE_SERIALIZER_CLASS_CONFIG<span class="token punctuation">,</span> <span class="token class-name">StringSerializer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
configs<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">ProducerConfig</span><span class="token punctuation">.</span>TRANSACTIONAL_ID_CONFIG<span class="token punctuation">,</span> <span class="token string">&quot;anyValue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">KafkaProducer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">KafkaProducer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>configs<span class="token punctuation">)</span><span class="token punctuation">;</span>
producer<span class="token punctuation">.</span><span class="token function">initTransactions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
producer<span class="token punctuation">.</span><span class="token function">beginTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ProducerRecord</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token string">&quot;Topic-Test&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;thisIsMessageKey&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;thisIsMessageValue1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
<span class="token class-name">KafkaProducer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> producer2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">KafkaProducer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>configs<span class="token punctuation">)</span><span class="token punctuation">;</span>
producer2<span class="token punctuation">.</span><span class="token function">initTransactions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
producer2<span class="token punctuation">.</span><span class="token function">beginTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

producer2<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ProducerRecord</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token string">&quot;Topic-Test&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;thisIsMessageKey&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;thisIsMessageValue2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

producer2<span class="token punctuation">.</span><span class="token function">commitTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

# <span class="token punctuation">.</span>/bin<span class="token operator">/</span>kafka<span class="token operator">-</span>dump<span class="token operator">-</span>log<span class="token punctuation">.</span>sh <span class="token operator">--</span>files <span class="token punctuation">.</span>/kafka<span class="token operator">-</span>logs<span class="token operator">/</span><span class="token class-name">Topic</span><span class="token operator">-</span><span class="token class-name">Test</span><span class="token operator">-</span><span class="token number">0</span><span class="token operator">/</span><span class="token number">00000000000000000192.l</span>og <span class="token operator">--</span>print<span class="token operator">-</span>data<span class="token operator">-</span>log
<span class="token class-name">Starting</span> offset<span class="token operator">:</span> <span class="token number">0</span>
offset<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> producerId<span class="token operator">:</span> <span class="token number">0</span> producerEpoch<span class="token operator">:</span> <span class="token number">5</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> payload<span class="token operator">:</span> thisIsMessageValue1
offset<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> producerId<span class="token operator">:</span> <span class="token number">0</span> producerEpoch<span class="token operator">:</span> <span class="token number">6</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> endTxnMarker<span class="token operator">:</span> ABORT coordinatorEpoch<span class="token operator">:</span> <span class="token number">0</span>
offset<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> producerId<span class="token operator">:</span> <span class="token number">0</span> producerEpoch<span class="token operator">:</span> <span class="token number">7</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> payload<span class="token operator">:</span> thisIsMessageValue2
offset<span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> producerId<span class="token operator">:</span> <span class="token number">0</span> producerEpoch<span class="token operator">:</span> <span class="token number">7</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> endTxnMarker<span class="token operator">:</span> COMMIT coordinatorEpoch<span class="token operator">:</span> <span class="token number">0</span>
    
<span class="token class-name">In</span> such scenario<span class="token punctuation">,</span> second producer tries <span class="token keyword">to</span> <span class="token namespace">initiate</span> transactions <span class="token keyword">for</span> the same transactional <span class="token class-name"><span class="token namespace">id<span class="token punctuation">.</span></span> This</span> results in ABORT marker written directly into the partition<span class="token punctuation">,</span> together <span class="token keyword">with</span> <span class="token namespace">data<span class="token punctuation">.</span></span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
<span class="token operator">--</span><span class="token operator">-</span> 错误：使用不固定的 TRANSACTIONAL_ID_CONFIG
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
configs<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">ProducerConfig</span><span class="token punctuation">.</span>TRANSACTIONAL_ID_CONFIG<span class="token punctuation">,</span> <span class="token string">&quot;differentValue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">KafkaProducer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> producer2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">KafkaProducer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>configs<span class="token punctuation">)</span><span class="token punctuation">;</span>
producer2<span class="token punctuation">.</span><span class="token function">initTransactions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

# <span class="token punctuation">.</span>/bin<span class="token operator">/</span>kafka<span class="token operator">-</span>dump<span class="token operator">-</span>log<span class="token punctuation">.</span>sh <span class="token operator">--</span>files <span class="token punctuation">.</span>/kafka<span class="token operator">-</span>logs<span class="token operator">/</span><span class="token class-name">Topic</span><span class="token operator">-</span><span class="token class-name">Test</span><span class="token operator">-</span><span class="token number">0</span><span class="token operator">/</span><span class="token number">00000000000000000192.l</span>og <span class="token operator">--</span>print<span class="token operator">-</span>data<span class="token operator">-</span>log
<span class="token class-name">Starting</span> offset<span class="token operator">:</span> <span class="token number">0</span>
offset<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> producerId<span class="token operator">:</span> <span class="token number">0</span> producerEpoch<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> payload<span class="token operator">:</span> thisIsMessageValue1
offset<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> producerId<span class="token operator">:</span> <span class="token number">1</span> producerEpoch<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> payload<span class="token operator">:</span> thisIsMessageValue2
offset<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> producerId<span class="token operator">:</span> <span class="token number">1</span> producerEpoch<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> endTxnMarker<span class="token operator">:</span> COMMIT coordinatorEpoch<span class="token operator">:</span> <span class="token number">0</span>

<span class="token class-name">There</span> is no <span class="token class-name">ABORT</span> marker<span class="token punctuation">,</span> so first producer could still commit its <span class="token class-name"><span class="token namespace">transaction<span class="token punctuation">.</span></span> Epoch</span> numbers are not incremented<span class="token punctuation">.</span>
    
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
<span class="token operator">--</span><span class="token operator">-</span> 实际项目代码
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
<span class="token class-name">ProducerConfig</span><span class="token punctuation">.</span>java<span class="token operator">:</span>
<span class="token keyword">public</span> <span class="token class-name">Properties</span> <span class="token function">prepareFor</span><span class="token punctuation">(</span><span class="token class-name">String</span> transactionId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Properties</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        properties<span class="token punctuation">.</span><span class="token function">stringPropertyNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>name <span class="token operator">-&gt;</span> result<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">hasText</span><span class="token punctuation">(</span>transactionId<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            result<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>producer<span class="token punctuation">.</span></span>ProducerConfig</span><span class="token punctuation">.</span>TRANSACTIONAL_ID_CONFIG<span class="token punctuation">,</span> transactionId<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token class-name">String</span> transactionId <span class="token operator">=</span> partition<span class="token operator">-</span>id <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">&quot;%s-TID-%d&quot;</span><span class="token punctuation">,</span> config<span class="token punctuation">.</span><span class="token function">getApplicationName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> partition<span class="token operator">-</span>id<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">&quot;TID&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>rawProducer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">KafkaProducer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>config<span class="token punctuation">.</span><span class="token function">prepareFor</span><span class="token punctuation">(</span>transactionId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>rawProducer<span class="token punctuation">.</span><span class="token function">initTransactions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果出现</p> <div class="language- extra-class"><pre class="language-text"><code>org.apache.kafka.common.errors.ProducerFencedException: Producer attempted an operation with 
an old epoch. Either there is a newer producer with the same transactionalId, or the producer's 
transaction has been expired by the broker.
</code></pre></div><h3 id="幂等性-idempotent-producer"><a href="#幂等性-idempotent-producer" class="header-anchor">#</a> 幂等性 idempotent producer</h3> <p>https://cwiki.apache.org/confluence/display/KAFKA/Idempotent+Producer</p> <p>Idempotent producer ensures <strong>exactly once message delivery per partition</strong></p> <blockquote><p>To enable idempotence, the enable.idempotence configuration must be set  to true. If set, the retries config will be defaulted to  Integer.MAX_VALUE, the max.in.flight.requests.per.connection config will be defaulted to 1, and acks config will be defaulted to all. There are  no API changes for the idempotent producer, so existing applications  will not need to be modified to take advantage of this feature.</p></blockquote> <p>简单说幂等性就是，当发生网络异常或者其他情况时，producer会重试，但是kafka集群会保证消息不重复，重试某条信息1万次即使全部成功，kafka集群也只会保存一条信息，</p> <p>设置 enable.idempotence=true 即可，</p> <p><strong>尽量不要设置retries这个配置参数，使用默认的最大值即可，不然可能会丢失数据</strong>，如果显示设置了retries就一定要设置 max.in.flight.requests.per.connection=1，不然可能会乱序</p> <p>Setting a value greater than zero will cause the client to resend any record whose send fails with a potentially transient error. Note that this retry is no different than if the client resent the record upon receiving the error. Allowing retries without setting  MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION to 1 will potentially change the ordering of records because if two batches are sent to a single partition, and the first fails and is retried but the second succeeds, then the records in the second batch may appear first.</p> <p>https://stackoverflow.com/questions/55192852/transactional-producer-vs-just-idempotent-producer-java-exception-outoforderseq/66579532#66579532</p> <p>How does this feature work? Under the  covers, it works in a way similar to TCP: each batch of messages sent to Kafka will contain a sequence number that the broker will use to dedupe any duplicate send. Unlike TCP, though—which provides guarantees only  within a transient in-memory connection—this sequence number is  persisted to the replicated log, so even if the leader fails, any broker that takes over will also know if a resend is a duplicate. The overhead of this mechanism is quite low: it’s just a few extra numeric fields  with each batch of messages. As you will see later in this article, this feature adds negligible performance overhead over the non-idempotent  producer.</p> <h2 id="brokers-服务端"><a href="#brokers-服务端" class="header-anchor">#</a> brokers 服务端</h2> <h3 id="transaction-coordinator"><a href="#transaction-coordinator" class="header-anchor">#</a> Transaction Coordinator</h3> <p>Each broker will construct a transaction coordinator module during the initialization process. The transaction coordinator handles requests from the transactional producer to keep track of their transaction status, and at the same time maintain their PIDs across multiple sessions via client-provided TransactionalIds. The transaction coordinator maintains the following information in memory:</p> <ol><li>A map from TransactionalId to assigned PID, plus current epoch number, and 2) the transaction timeout value.</li> <li>A map from PID to the current ongoing transaction status of the producer indicated by the PID, plus the participant topic-partitions, and the last time when this status was updated.
In addition, the transaction coordinator also persists both mappings to the transaction topic partitions it owns, so that they can be used for recovery.</li></ol> <h4 id="transaction-log"><a href="#transaction-log" class="header-anchor">#</a> Transaction Log</h4> <p>the transaction log is stored as an internal transaction topic partitioned among all the brokers. Log compaction is turned on by default on the transaction topic. Messages stored in this topic have versions for both the key and value fields:</p> <div class="language- extra-class"><pre class="language-text"><code>/* Producer TransactionalId mapping message */
Key =&gt; Version TransactionalId  
  Version =&gt; 0 (int16)
  TransactionalId =&gt; String
Value =&gt; Version ProducerId ProducerEpoch TxnTimeoutDuration TxnStatus [TxnPartitions] TxnEntryLastUpdateTime TxnStartTime
  Version =&gt; 0 (int16)
  ProducerId =&gt; int64
  ProducerEpoch =&gt; int16
  TxnTimeoutDuration =&gt; int32
  TxnStatus =&gt; int8
  TxnPartitions =&gt; [Topic [Partition]]
     Topic =&gt; String
     Partition =&gt; int32
  TxnLastUpdateTime =&gt; int64
  TxnStartTime =&gt; int64

</code></pre></div><p>The status field above has the following possible values:
BEGIN	The transaction has started.
PREPARE_COMMIT	The transaction will be committed.
PREPARE_ABORT	The transaction will be aborted.
COMPLETE_COMMIT	The transaction was committed.
COMPLETE_ABORT	The transaction was aborted.</p> <p>Writing of the PREPARE_XX transaction message can be treated as the synchronization point: once it is appended (and replicated) to the log, the transaction is guaranteed to be committed or aborted. And even when the coordinator fails, upon recovery, this transaction will be rolled forward or rolled back as well.
Writing of the TransactionalId message can be treated as persisting the creation or update of the TransactionalId -&gt; PID entry. Note that if there are more than one transaction topic partitions owned by the transaction coordinator, the transaction messages are written only to the partition that the TransactionalId entry belongs to.
We will use the timestamp of the transaction status message in order to determine when the transaction has timed out using the transaction timeout from the InitPidRequest (which is stored in the TransactionalId mapping message). Once the difference between the current time and the timestamp from the status message exceeds the timeout, the transaction will be aborted.
This works similarly for expiration of the TransactionalId, but note 1) that the transactionalId will not be expired if there is an on-going transaction, and 2) if the client corresponding to a transactionalId has not begun any transactions, we use the timestamp from the mapping message for expiration.
When a transaction is completed (whether aborted or committed), the transaction state of the producer is changed to Completed and we clear the set of topic partitions associated with the completed transaction.</p> <h4 id="transaction-coordinator-startup"><a href="#transaction-coordinator-startup" class="header-anchor">#</a> Transaction Coordinator Startup</h4> <p>Upon assignment of one of the transaction log partitions by the controller (i.e., upon getting elected as the leader of the partition), the coordinator will execute the following steps:</p> <ol><li>Read its currently assigned transaction topic partitions and bootstrap the Transaction status cache. The coordinator will scan the transaction log from the beginning, verify basic consistency, and materialize the entries. It performs the following actions as it reads the entries from the transaction log:
a.	Check whether there is a previous entry with the same TransactionalId and a higher epoch. If so, throw an exception. In particular, this indicates the log is corrupt. All future transactional RPCs to this coordintaor will result in a <code>NotCoordinatorForTransactionalId</code> error code, and this partition of the log will be effectively disabled.
b.	Update the transaction status cache for the transactionalId in question with the contents of the current log entry, including the last update time, and partitions in the transaction, and status. If there are multiple log entries with the same transactionalId, the last copy will be the one which remains materialized in the cache. The log cleaner will eventually compact out the older copies.</li></ol> <p>When committing a transaction, the following steps will be executed by the coordinator:</p> <ol><li>Send an WriteTxnMarkerRequest with the COMMIT marker to all the leaders of the transaction’s added partitions.</li> <li>When all the responses have been received, append a COMPLETE_COMMIT transaction message to the transaction topic. We do not need to wait for this record to be fully replicated since otherwise we will just redo this protocol again.</li></ol> <p>When aborting a transaction, the following steps will be executed by the coordinator:</p> <ol><li>Send an WriteTxnMarkerRequest with the ABORT marker to all the host brokers of the transaction partitions.</li> <li>When all the responses have been received, append a COMPLETE_ABORT transaction message to the transaction topic. Do not need to wait for this record to be fully replicated since otherwise we will just redo this protocol again.</li></ol> <p>Discussion on Unavailable Partitions. When committing or aborting a transaction, if one of the partitions involved in the commit is unavailable, then the transaction will be unable to be completed. Concretely, say that we have appended a PREPARE_COMMIT message to the transaction log, and we are about to send the WriteTxnMarkerRequest, but one of the partitions is unavailable. We cannot complete the commit until the partition comes back online, at which point the “roll forward” logic will be executed again. This may cause a transaction to be delayed longer than the transaction timeout, but there is no alternative since consumers may be blocking awaiting the transaction’s completion. It is important to keep in mind that we  strongly rely on partition availability for progress. Note, however, that consumers in READ_COMMITTED mode will only be blocked from consumption on the unavailable partition; other partitions included in the transaction can be consumed before the transaction has finished rolling forward.</p> <h4 id="transaction-coordinator-request-handling"><a href="#transaction-coordinator-request-handling" class="header-anchor">#</a> Transaction Coordinator Request Handling</h4> <p>When receiving the InitPidRequest from a producer with a non-empty TransactionalId (see here for handling the empty case), the following steps will be executed in order to send back the response:</p> <ol><li>Check if it is the assigned transaction coordinator for the TransactionalId, if not reply with the NotCoordinatorForTransactionalId error code.</li> <li>If there is already an entry with the TransactionalId in the mapping, check whether there is an ongoing transaction for the PID. If there is and it has not been completed, then follow the abort logic. If the transaction has been prepared, but not completed, await its completion. We will only move to the next step after there is no incomplete transaction for the PID.</li> <li>Increment the epoch number, append the updated TransactionalId message. If there is no entry with the TransactionalId in the mapping, construct a PID with the initialized epoch number; append an TransactionalId message into the transaction topic, insert into the mapping and reply with the PID / epoch / timestamp.</li> <li>Respond with the latest PID and Epoch for the TransactionalId.
Note that coordinator’s PID construction logic does NOT guarantee that it will always result in the same PID for a given TransactionalId (more details discussed here). In fact, in this design we make minimal assumptions about the PID returned from this API, other than that it is unique (across the Kafka cluster) and will never be assigned twice. One potential way to do this is to use Zookeeper to reserve blocks of the PID space on each coordinator. For example, when broker 0 is first initialized, it can reserve PIDs 0-100, while broker 1 can reserve 101-200. In this way, the broker can ensure that it provides unique PIDs without incurring too much additional overhead.</li></ol> <p>When receiving the AddPartitionsToTxnRequest from a producer, the following steps will be executed in order to send back the response.</p> <ol><li>If the TransactionalId does not exist in the TransactionalId mapping or if the mapped PID is different from that in the request, reply with InvalidPidMapping; otherwise proceed to next step.</li> <li>If the PID’s epoch number is different from the current TransactionalId PID mapping, reply with the InvalidProducerEpoch error code; otherwise proceed to next step.</li> <li>Check if there is already an entry in the transaction status mapping.
a.	If there is already an entry in the transaction status mapping, check if its status is BEGIN and the epoch number is correct, if yes append an transaction status message into the transaction topic with the updated partition list, wait for this message to be replicated, update the transaction status entry and timestamp in the TransactionalId map and reply OK; otherwise reply with InvalidTxnRequest error code.
b.	Otherwise append a BEGIN transaction message into the transaction topic, wait for this message to be replicated and then insert it into the transaction status mapping and update the timestamp in the TransactionalId map and reply OK.</li></ol> <p>When receiving the AddOffsetsToTxnRequest from a producer, the following steps will be executed in order to send back the response.</p> <ol><li>If the TransactionalId does not exist in the TransactionalId mapping or if the mapped PID is different from that in the request, reply with InvalidPidMapping; otherwise proceed to next step.</li> <li>If the PID’s epoch number is different from the current TransactionalId mapping, reply with the InvalidProducerEpoch error code; otherwise proceed to next step.</li> <li>If there is already an entry in the transaction status mapping, check if its status is BEGIN and the epoch number is correct, if yes calculate the internal offset topic partition based on the ConsumerGroupID field, append a BEGIN transaction message into the transaction topic with updated partition list, wait for this message to be replicated, update the transaction status entry and the timestamp in the TransactionalId map and reply OK with the calculated partition’s lead broker as the consumer coordinator; otherwise reply with InvalidTxnRequest error code.</li> <li>If there is no entry in the transaction status mapping reply with InvalidTxnRequest error code.</li></ol> <p>When receiving the EndTxnRequest from a producer, the following steps will be executed in order to send back the response.</p> <ol><li>If the TransactionalId does not exist in the TransactionalId mapping or if the mapped PID is different from that in the request, reply with InvalidPidMapping; otherwise proceed to next step.</li> <li>Check if the PID’s epoch number is correct against the TransactionalId mapping. If not, reply with the InvalidProducerEpoch error code; otherwise proceed to the next step.</li> <li>If there is already an entry in the transaction status mapping, check its status
a.	If the status is BEGIN, go on to step 4.
b.	If the status is COMPLETE_COMMIT and the command from the EndTxnRequest is COMMIT, return OK.
c.	If the status is COMPLETE_ABORT and the command from the EndTxnRequest is ABORT, return OK.
d.	Otherwise, reply with InvalidTxnRequest error code.</li> <li>Update the timestamp in the TransactionalId map.</li> <li>Depending on the command field of the request, append a PREPARE_XX transaction message to the transaction topic with all the transaction partitions kept in the transaction status map, wait until the message is replicated.</li> <li>Commit or abort the transaction following the procedure depending on the command field.</li> <li>Reply OK.</li></ol> <p>Discussion on Coordinator Committing Transactions. The main motivation for having the transaction coordinator complete the commit / abort protocol after the PREPARE_XXX transaction message is appended to the transaction log is to keep the producer client thin (i.e. not letting producers to send the request to brokers to write transaction markers), and to ensure that transactions will always eventually be completed. However, it comes with an overhead of increased inter-broker communication traffic: suppose there are N producers sending messages in transactions, and each producer’s transaction rate is M/sec, and each transaction touches P topic partitions on average, inter-broker communications will be increased by M * N * P round trips per sec. We need to conduct some system performance test to make sure this additional inter-broker traffic would not largely impact the broker cluster.</p> <p>Discussion on Coordinator Failure During Transaction Completion: It is possible for the coordinator to fail at any time during the completion of a transaction. In general, the client responds by finding the new coordinator and retrying the EndTxnRequest. If the coordinator had already written the PREPARE_COMMIT or PREPARE_ABORT status to the transaction log, and had begun writing the corresponding markers to the data partitions, then the new coordinator may repeat some of this work (i.e. there may be duplicate COMMIT or ABORT markers in the log), but this is not a problem as long as no new transactions have been started by the same producer. It is also possible for the coordinator to fail after writing the COMPLETE_COMMIT or COMPLETE_ABORT status, but before the EndTxnRequest had returned to the user. In this case, the client will retry the EndTxnRequest after finding the new coordinator. As long as the command matches the completed state of the transaction after coordinator recovery, the coordinator will return a successful response. If not for this, there would be no way for the client to determine what happened to the transaction.</p> <h4 id="coordinator-side-transaction-expiration"><a href="#coordinator-side-transaction-expiration" class="header-anchor">#</a> Coordinator-side Transaction Expiration</h4> <p>When a producer fails, its transaction coordinator should be able to pro-actively expire its ongoing transaction. In order to do so, the transaction coordinator will periodically trigger the following procedure:</p> <ol><li>Scan the transaction status map in memory. For each transaction:
a.	If its status is BEGIN, and its corresponding expire timestamp is smaller than the current timestamp, pro-actively expire the transaction by doing the following:
i.	First void the PID by bumping up the epoch number in the TransactionalId map and writing a new TransactionalId message into the transaction log. Wait for it to be fully replicated.
ii.	Then rollback the transaction following the procedure with the bumped up epoch number, so that brokers can update their cached PID as well in order to fence Zombie writers (see more discussions below).
b.	If its status is PREPARE_COMMIT, then complete the committing process of the transaction.
c.	If its status is PREPARE_ABORT, then complete the aborting process of the transaction.</li></ol> <p>Discussion on Pro-active Transaction Timeout. One motivation to let transaction coordinator to pro-actively timeout transactions is that upon producer failure, we do not want to rely on the producer eventually recovering and completing the transaction: for example, if a producer fails within a transaction and the coordinator does not pro-actively abort it, this transaction will become a “dangling” transaction that will not be completed until the producer resumes with the same TransactionalId, and any consumers fetching on the partitions included in this transaction in READ_COMMITTED will be effectively blocked waiting for the LSO to advance. This issue will be more severe if one topic partition has multiple transactional producers writing to it in an interleaving交错 manner, since one dangling transaction will cause all other transactions to not be able to be consumed due to the offset ordering.
One question though, is whether a pro-active timeout of a transaction will still fence a zombie writer. The short answer is yes. Upon timing out and aborting the transaction, the coordinator will bump the epoch associated with the PID and write ABORT markers to all partitions which had been included in the transaction. If the zombie is still attempting to write to any of these partitions, it will be fenced as soon as the ABORT marker is written. Alternatively, if it attempts to commit or abort the transaction, it will also be fenced by the coordinator.</p> <h4 id="coordinator-transactionalid-expiration"><a href="#coordinator-transactionalid-expiration" class="header-anchor">#</a> Coordinator TransactionalId Expiration</h4> <p>Ideally, we would like to keep TransactionalId entries in the mapping forever, but for practical purposes we want to evict the ones that are not used any longer to avoid having the mapping growing without bounds. Consequently, we need a mechanism to detect inactivity and evict the corresponding identifiers. In order to do so, the transaction coordinator will periodically trigger the following procedure:</p> <ol><li>Scan the TransactionalId map in memory. For each TransactionalId -&gt; PID entry, if it does NOT have a current ongoing transaction in the transaction status map, AND the age of the last completed transaction is greater than the TransactionalId expiration config, remove the entry from the map. We will write the tombstone for the TransactionalId, but do not care if it fails, since in the worst case the TransactionalId will persist for a little longer (ie. the transactional.id.expration.ms duration).</li></ol> <p>Discussion on PID Expiration: It is possible for a producer to continue using the PID that its TransactionalId was mapped to in a non-transactional way even after the TransactionalId has been expired. If the producer continues writing to partitions without starting a new transaction, its PID will remain in the broker’s sequence table as long as the messages are still present in the log. It is possible for another producer using the same TransactionalId to then acquire a new PID from the transaction coordinator and either begin using transactions or “idempotent mode.” This does not violate any of the guarantees of either the idempotent or transactional producers.</p> <ol><li>For the transactional producer, we guarantee that there can be only one active producer at any time. Since we ensure that active transactions are completed before expiring an TransactionalId, we can guarantee that a zombie producer will be fenced when it tries to start another one (whether or not a new producer with the same TransactionalId has generated a new PID mapping).</li> <li>For the idempotent producer (i.e., producer that do not use transactional APIs), currently we do not make any cross-session guarantees in any case. In the future, we can extend this guarantee by having the producer to periodically send InitPidRequest to the transaction coordinator to keep the TransactionalId from expiring, which preserves the producer’s zombie defence.</li></ol> <h3 id="broker"><a href="#broker" class="header-anchor">#</a> Broker</h3> <p>Besides fencing duplicate messages and Zombie writers based on the PID, epoch and sequence number in the produce request as described in the Transactional Producer section, each broker must also handle requests sent from the transaction coordinators for writing the commit and abort markers into the log.
At the same time, brokers also need to handle requests from clients asking for their assigned coordinator, which will be the leader broker of the transaction topic’s partition calculated from the producer’s TransactionalId.</p> <h3 id="consumer-coordinator"><a href="#consumer-coordinator" class="header-anchor">#</a> Consumer Coordinator</h3> <p>As mentioned in the summary, many Kafka streaming applications need to both consume from input topics and produce to output topics at the same time. When consumer offsets are committed for the input topics, they need to be done along with the produced transactions as well, such that for each message consumed from the input Kafka topics, the result message(s) of processing this message will be reflected in the output Kafka topics exactly once, even under failures.
In order to support this scenario, we need to make the consumer coordinator transaction-aware. More specifically, we need a new API which allows the producer to send offset commits as part of a transaction. For this we introduce the TxnOffsetCommitRequest API.</p> <h2 id="troubleshooting"><a href="#troubleshooting" class="header-anchor">#</a> Troubleshooting</h2> <h3 id="error-codes"><a href="#error-codes" class="header-anchor">#</a> ERROR CODES</h3> <ul><li>InvalidProducerEpoch:
this is a fatal error, meaning the producer itself is a zombie since another instance of the producer has been up and running, stop this producer and throw an exception.</li> <li>InvalidPidMapping:
the coordinator has no current PID mapping for this TransactionalId.  Establish a new one via the InitPidRequest with the TransactionalId.</li> <li>NotCoordinatorForTransactionalId:
the coordinator is not assigned with the TransactionalId, try to re-discover the transaction coordinator from brokers via the FindCoordinatorRequest with the TransactionalId.</li> <li>InvalidTxnRequest:
the transaction protocol is violated, this should not happen with the correct client implementation; so if it ever happens it means your client implementation is wrong.</li> <li>CoordinatorNotAvailable:
the transaction coordinator is still initializing, just retry after backing off.</li> <li>DuplicateSequenceNumber:
the sequence number from ProduceRequest is lower than the expected sequence number. In this case, the messages are duplicates and hence the producer can ignore this error and proceed to the next messages queued to be sent.</li> <li>InvalidSequenceNumber:
this is a fatal error indicating the sequence number from ProduceRequest is larger than expected sequence number. Assuming a correct client, this should only happen if the broker loses data for the respective partition (i.e. log may have been truncated). Hence we should stop this producer and raise to the user as a fatal exception.</li> <li>InvalidTransactionTimeout:
fatal error sent from an InitPidRequest indicating that the timeout value passed by the producer is invalid (not within the allowable timeout range).</li></ul> <h4 id="inittransactions-timeoutexception"><a href="#inittransactions-timeoutexception" class="header-anchor">#</a> initTransactions - TimeoutException</h4> <p>Gets the internal producer id and epoch, used in all future transactional messages issued by the producer. Note that this method will raise TimeoutException if the transactional state cannot be initialized before expiration of max.block.ms.
Additionally, it will raise InterruptException if interrupted. It is safe to retry in either case, but once the transactional state has been successfully initialized, this method should no longer be used.</p> <h4 id="begintransaction-sendoffsetstotransaction-committransaction-aborttransaction-producerfencedexception"><a href="#begintransaction-sendoffsetstotransaction-committransaction-aborttransaction-producerfencedexception" class="header-anchor">#</a> beginTransaction / sendOffsetsToTransaction / commitTransaction / abortTransaction - ProducerFencedException</h4> <p>这些方法都会抛 ProducerFencedException 原理就是调用这些方法之前必须要先调用 initTransactions， initTransactions会分配每个transaction.id新的epoch，从而阻止zombie程序继续发送kafka transaction;
当然也会由于服务端的问题导致client这边Producer Transaction timeout从而引发reset pid和epoch 造成后续请求ProducerFencedException</p> <h3 id="kafka某个节点所在机房突然断电又恢复后-transactional-producer异常"><a href="#kafka某个节点所在机房突然断电又恢复后-transactional-producer异常" class="header-anchor">#</a> kafka某个节点所在机房突然断电又恢复后 transactional producer异常</h3> <div class="language- extra-class"><pre class="language-text"><code>2023-02-08 15:42:18.189 [32m INFO[m [35m21664GG[m [TEST-MANAGER] [36mo.a.k.c.FetchSessionHandler[m : 
[Consumer clientId=consumer-1, groupId=TEST-PRICEENGINE-SZL] 
Error sending fetch request (sessionId=132458226, epoch=271322) to node 0: org.apache.kafka.common.errors.DisconnectException.

2023-02-08 15:42:22.815 [33m WARN[m [35m21664GG[m [ad | producer-3] [36mo.a.k.c.p.i.Sender[m : 
[Producer clientId=producer-3, transactionalId=TEST-TID-0] 
Got error produce response with correlation id 851515 on topic-partition T-QUOTATION-SNP-0, retrying (2147483646 attempts left). Error: REQUEST_TIMED_OUT

2023-02-08 15:42:52.967 [33m WARN[m [35m21664GG[m [ad | producer-3] [36mo.a.k.c.p.i.Sender[m : 
[Producer clientId=producer-3, transactionalId=TEST-TID-0] 
Got error produce response with correlation id 851516 on topic-partition T-QUOTATION-SNP-0, retrying (2147483645 attempts left). Error: REQUEST_TIMED_OUT

2023-02-08 15:43:21.260 [32mDEBUG[m [35m21664GG[m [TEST-MANAGER] [36mc.q.c.c.b.SimpleWorkerManager[m : 
	Received 2 message(s)
2023-02-08 15:43:21.260 [32mDEBUG[m [35m21664GG[m [TEST-MANAGER] [36mc.q.c.c.b.SimpleWorkerManager[m : 
	Message header payload:P=0,O=2520208,C=com.lyhistory.test.TestMsgToKafka,V=1
2023-02-08 15:43:21.260 [32mDEBUG[m [35m21664GG[m [TEST-MANAGER] [36mc.q.c.c.b.SimpleWorkerManager[m : 
	Message header payload:P=0,O=2520209,C=com.lyhistory.test.TestMsgToKafka,V=1
2023-02-08 15:43:21.260 [32mDEBUG[m [35m21664GG[m [TEST-p0-1] [36mc.q.c.c.b.AbstractWorker[m : 
	R=false, P=0, O=2520208, F=com.lyhistory.test.TestMsgToKafka
2023-02-08 15:43:21.260 [32m INFO[m [35m21664GG[m [TEST-p0-1] [36mc.q.c.p.h.TestMsgHandler[m : 
	Offset [2520208], Partition [0], Handling TestMsgToKafka{tradableInstrumentId='BTC2303', priceType=LAST, marketPriceSource=EXTERNAL, price=23.465000, currency='USD', publishTime=1675842201252, updateUser='null', updateTime=1675842201252, tradeDate='20230208'}
2023-02-08 15:43:21.262 [32m INFO[m [35m21664GG[m [TEST-p0-1] [36mc.q.c.p.h.TestMsgHandler[m : 
	Updated spot rate in price engine storage and REDIS. trade-date [20230208], tradable-instrument-id [BTC2303], price-type [LAST], price [23.465000]
2023-02-08 15:43:21.262 [32mDEBUG[m [35m21664GG[m [TEST-p0-1] [36mc.q.c.c.b.AbstractWorker[m : 
	R=false, P=0, O=2520209, F=com.lyhistory.test.TestMsgToKafka
2023-02-08 15:43:21.262 [32m INFO[m [35m21664GG[m [TEST-p0-1] [36mc.q.c.p.h.TestMsgHandler[m : 
	Offset [2520209], Partition [0], Handling TestMsgToKafka{tradableInstrumentId='BTC2302', priceType=LAST, marketPriceSource=EXTERNAL, price=23.320000, currency='USD', publishTime=1675842201252, updateUser='null', updateTime=1675842201252, tradeDate='20230208'}
2023-02-08 15:43:21.263 [32m INFO[m [35m21664GG[m [TEST-p0-1] [36mc.q.c.p.h.TestMsgHandler[m : 
	Updated spot rate in price engine storage and REDIS. trade-date [20230208], tradable-instrument-id [BTC2302], price-type [LAST], price [23.320000]
2023-02-08 15:43:22.789 [32m INFO[m [35m21664GG[m [EENGINE-TID-0-1] [36mc.l.d.IgnoreExceptionHandler[m : 
	Exception processing: 309941 ProduceActionWrapper{}

org.apache.kafka.common.KafkaException: Cannot execute transactional method because we are in an error state
	at org.apache.kafka.clients.producer.internals.TransactionManager.maybeFailWithError(TransactionManager.java:785)
	at org.apache.kafka.clients.producer.internals.TransactionManager.beginAbort(TransactionManager.java:230)
	at org.apache.kafka.clients.producer.KafkaProducer.abortTransaction(KafkaProducer.java:716)
	at com.lyhistory.core.producer.DisruptorProducer.realProduce(DisruptorProducer.java:66)
	at com.lyhistory.core.producer.DisruptorProducer$$Lambda$914/1553377810.onEvent(Unknown Source)
	at com.lmax.disruptor.BatchEventProcessor.processEvents(BatchEventProcessor.java:168)
	at com.lmax.disruptor.BatchEventProcessor.run(BatchEventProcessor.java:125)
	at java.lang.Thread.run(Thread.java:745)
Caused by: org.apache.kafka.common.errors.ProducerFencedException: Producer attempted an operation with an old epoch. Either there is a newer producer with the same transactionalId, or the producer's transaction has been expired by the broker.
.....


2023-02-08 16:03:38.938 [32m INFO[m [35m21664GG[m [EENGINE-TID-2-1] [36mc.l.d.IgnoreExceptionHandler[m : Exception processing: 120 ProduceActionWrapper{}

org.apache.kafka.common.KafkaException: Cannot execute transactional method because we are in an error state
	at org.apache.kafka.clients.producer.internals.TransactionManager.maybeFailWithError(TransactionManager.java:785)
	at org.apache.kafka.clients.producer.internals.TransactionManager.beginAbort(TransactionManager.java:230)
	at org.apache.kafka.clients.producer.KafkaProducer.abortTransaction(KafkaProducer.java:716)
	at com.lyhistory.core.producer.DisruptorProducer.realProduce(DisruptorProducer.java:66)
	at com.lyhistory.core.producer.DisruptorProducer$$Lambda$914/1553377810.onEvent(Unknown Source)
	at com.lmax.disruptor.BatchEventProcessor.processEvents(BatchEventProcessor.java:168)
	at com.lmax.disruptor.BatchEventProcessor.run(BatchEventProcessor.java:125)
	at java.lang.Thread.run(Thread.java:745)
Caused by: org.apache.kafka.common.KafkaException: The client hasn't received acknowledgment for some previously sent messages and can no longer retry them. It isn't safe to continue.
	at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:283)
	at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:235)
	... 1 more

.......


</code></pre></div><p>可以清楚的看到有两类错误信息，下面分别分析</p> <h4 id="producerfencedexception"><a href="#producerfencedexception" class="header-anchor">#</a> ProducerFencedException</h4> <p>2023-02-08 15:43:22.789 [32m INFO[m [35m21664GG[m [EENGINE-TID-0-1] [36mc.l.d.IgnoreExceptionHandler[m :
Exception processing: 309941 ProduceActionWrapper{}</p> <p>org.apache.kafka.common.KafkaException: Cannot execute transactional method because we are in an error state
at org.apache.kafka.clients.producer.internals.TransactionManager.maybeFailWithError(TransactionManager.java:785)
at org.apache.kafka.clients.producer.internals.TransactionManager.beginAbort(TransactionManager.java:230)
at org.apache.kafka.clients.producer.KafkaProducer.abortTransaction(KafkaProducer.java:716)
at com.lyhistory.core.producer.DisruptorProducer.realProduce(DisruptorProducer.java:66)
at com.lyhistory.core.producer.DisruptorProducer$$Lambda$914/1553377810.onEvent(Unknown Source)
at com.lmax.disruptor.BatchEventProcessor.processEvents(BatchEventProcessor.java:168)
at com.lmax.disruptor.BatchEventProcessor.run(BatchEventProcessor.java:125)
at java.lang.Thread.run(Thread.java:745)
Caused by: org.apache.kafka.common.errors.ProducerFencedException: Producer attempted an operation with an old epoch. Either there is a newer producer with the same transactionalId, or the producer's transaction has been expired by the broker.</p> <div class="language- extra-class"><pre class="language-text"><code>#at org.apache.kafka.clients.producer.internals.TransactionManager.maybeFailWithError(TransactionManager.java:785)
private void maybeFailWithError() {
        if (hasError())
            throw new KafkaException(&quot;Cannot execute transactional method because we are in an error state&quot;, lastError);
    }
synchronized boolean hasError() {
        return currentState == State.ABORTABLE_ERROR || currentState == State.FATAL_ERROR;
    }
《=
at org.apache.kafka.clients.producer.internals.TransactionManager.beginAbort(TransactionManager.java:230)
public synchronized TransactionalRequestResult beginAbort() {
        ensureTransactional();
        if (currentState != State.ABORTABLE_ERROR)
            maybeFailWithError();
        transitionTo(State.ABORTING_TRANSACTION);

        // We're aborting the transaction, so there should be no need to add new partitions
        newPartitionsInTransaction.clear();
        return beginCompletingTransaction(TransactionResult.ABORT);
    }
所以确认 currentState == State.FATAL_ERROR
《=
at org.apache.kafka.clients.producer.KafkaProducer.abortTransaction(KafkaProducer.java:716)
 /**
     * Aborts the ongoing transaction. Any unflushed produce messages will be aborted when this call is made.
     * This call will throw an exception immediately if any prior {@link #send(ProducerRecord)} calls failed with a
     * {@link ProducerFencedException} or an instance of {@link org.apache.kafka.common.errors.AuthorizationException}.
     *
     * @throws IllegalStateException if no transactional.id has been configured or no transaction has been started
     * @throws ProducerFencedException fatal error indicating another producer with the same transactional.id is active
     * @throws org.apache.kafka.common.errors.UnsupportedVersionException fatal error indicating the broker
     *         does not support transactions (i.e. if its version is lower than 0.11.0.0)
     * @throws org.apache.kafka.common.errors.AuthorizationException fatal error indicating that the configured
     *         transactional.id is not authorized. See the exception for more details
     * @throws KafkaException if the producer has encountered a previous fatal error or for any other unexpected error
     */
    public void abortTransaction() throws ProducerFencedException {
        throwIfNoTransactionManager();
        TransactionalRequestResult result = transactionManager.beginAbort();
        sender.wakeup();
        result.await();
    }
《=
at com.lyhistory.core.producer.DisruptorProducer.realProduce(DisruptorProducer.java:66)
            try {
                rawProducer.commitTransaction();
                logger.debug(&quot;处理进度：P={}, BS={}, QO={}&quot;, id, transactionSize, queueOffset);
            } catch (Exception ex) {
                rawProducer.abortTransaction();
                throw new RuntimeException(&quot;处理信息时出现故障&quot;, ex);
            } finally {
                inTransactions = false;
            }

66行也就是rawProducer.abortTransaction();  
为什么此处的&quot;处理信息时出现故障&quot;没有打印出来，看到这里只是throw出去，然后实际上代码里用的是disruptor：

public DisruptorProducer(ProducerConfig config, int id) {
        this.config = Objects.requireNonNull(config, &quot;生产配置信息不能为null&quot;);
        this.id = id;
        String transactionId = id &gt;= 0 ? String.format(&quot;%s-TID-%d&quot;, config.getApplicationName(), id) : &quot;TID-BLAST&quot;;
        this.rawProducer = new KafkaProducer&lt;&gt;(config.prepareFor(transactionId));
        this.rawProducer.initTransactions();

        this.disruptor = new Disruptor&lt;&gt;(ProduceActionWrapper::new, 1 &lt;&lt; config.getQueueBitSize(), new NamedThreadFactory(transactionId));
        this.disruptor.handleEventsWith(this::realProduce);
        this.disruptor.setDefaultExceptionHandler(new IgnoreExceptionHandler());
        this.disruptor.start();
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private void realProduce(ProduceActionWrapper eventWrapper, long queueOffset, boolean endOfBatch) {
        if (!inTransactions) {
            rawProducer.beginTransaction();
            inTransactions = true;
            transactionSize = 0;
        }

        ProduceAction[] actions = eventWrapper.getActions();
        transactionSize = transactionSize + 1;
        for (ProduceAction action : actions) {
            rawProducer.send(action.getProducerRecord(), action.getCallback());
        }
        if (transactionSize &gt;= config.getBatchSize() || endOfBatch) {
            try {
                rawProducer.commitTransaction();
                logger.debug(&quot;处理进度：P={}, BS={}, QO={}&quot;, id, transactionSize, queueOffset);
            } catch (Exception ex) {
                rawProducer.abortTransaction();
                throw new RuntimeException(&quot;处理信息时出现故障&quot;, ex);
            } finally {
                inTransactions = false;
            }
        }
    }

设置的是默认的这个 this.disruptor.setDefaultExceptionHandler(new IgnoreExceptionHandler());

public final class IgnoreExceptionHandler implements ExceptionHandler&lt;Object&gt;
{

    @Override
    public void handleEventException(final Throwable ex, final long sequence, final Object event)
    {
        logger.log(Level.INFO, &quot;Exception processing: &quot; + sequence + &quot; &quot; + event, ex);
    }
所以对应上了整个输出是INFO
2023-02-08 15:43:22.789 [32m INFO[m [35m21664GG[m [EENGINE-TID-0-1] [36mc.l.d.IgnoreExceptionHandler[m : 
	Exception processing: 309941 ProduceActionWrapper{}
但是为啥没有打印出“处理信息时出现故障”？IgnoreExceptionHandler拿到的ex不是 new RuntimeException(&quot;处理信息时出现故障&quot;, ex)？
又或者IgnoreExceptionHandler并不是处理这里throw的Exception的，所以外部也没有catch到这个exception？

anyway，我们确定的是最后的这段Exception是由 66行也就是rawProducer.abortTransaction() 引发的，然后引发的原因也分析了是因为有FATAL_ERROR，所以执行失败，而触发
} catch (Exception ex) {
                rawProducer.abortTransaction();
这段逻辑的cause则是：

Caused by: org.apache.kafka.common.errors.ProducerFencedException: Producer attempted an operation with an old epoch. Either there is a newer producer with the same transactionalId, or the producer's transaction has been expired by the broker.

并没有给出stack trace 而是只给了这个ProducerFencedException，但是肯定是在执行
try {
                rawProducer.commitTransaction();
                logger.debug(&quot;处理进度：P={}, BS={}, QO={}&quot;, id, transactionSize, queueOffset);
            } catch (Exception ex) {
                rawProducer.abortTransaction();
这个try的这段的时候出错的，也就是在commitTransaction的时候抓到的，
=&gt;
package org.apache.kafka.clients.producer;
public class KafkaProducer&lt;K, V&gt; implements Producer&lt;K, V&gt; {
    /**
     * Commits the ongoing transaction. This method will flush any unsent records before actually committing the transaction.
     *
     * Further, if any of the {@link #send(ProducerRecord)} calls which were part of the transaction hit irrecoverable
     * errors, this method will throw the last received exception immediately and the transaction will not be committed.
     * So all {@link #send(ProducerRecord)} calls in a transaction must succeed in order for this method to succeed.
     *
     * @throws IllegalStateException if no transactional.id has been configured or no transaction has been started
     * @throws ProducerFencedException fatal error indicating another producer with the same transactional.id is active
     * @throws org.apache.kafka.common.errors.UnsupportedVersionException fatal error indicating the broker
     *         does not support transactions (i.e. if its version is lower than 0.11.0.0)
     * @throws org.apache.kafka.common.errors.AuthorizationException fatal error indicating that the configured
     *         transactional.id is not authorized. See the exception for more details
     * @throws KafkaException if the producer has encountered a previous fatal or abortable error, or for any
     *         other unexpected error
     */
    public void commitTransaction() throws ProducerFencedException {
        throwIfNoTransactionManager();
        TransactionalRequestResult result = transactionManager.beginCommit();
        sender.wakeup();
        result.await();
    }

    public synchronized TransactionalRequestResult beginCommit() {
        ensureTransactional();
        maybeFailWithError();
        transitionTo(State.COMMITTING_TRANSACTION);
        return beginCompletingTransaction(TransactionResult.COMMIT);
    }
    private void maybeFailWithError() {
        if (hasError())
            throw new KafkaException(&quot;Cannot execute transactional method because we are in an error state&quot;, lastError);
    }
    synchronized boolean hasError() {
        return currentState == State.ABORTABLE_ERROR || currentState == State.FATAL_ERROR;
    }

倒查状态：
package org.apache.kafka.clients.producer.internals;
    public class TransactionManager {
        synchronized void transitionToAbortableError(RuntimeException exception) {
            if (currentState == State.ABORTING_TRANSACTION) {
                log.debug(&quot;Skipping transition to abortable error state since the transaction is already being &quot; +
                        &quot;aborted. Underlying exception: &quot;, exception);
                return;
            }
            transitionTo(State.ABORTABLE_ERROR, exception);
        }

        synchronized void transitionToFatalError(RuntimeException exception) {
            transitionTo(State.FATAL_ERROR, exception);
        }
《=
    private void failBatch(ProducerBatch batch, long baseOffset, long logAppendTime, RuntimeException exception,
        boolean adjustSequenceNumbers) {
        if (transactionManager != null) {
            if (exception instanceof OutOfOrderSequenceException
                    &amp;&amp; !transactionManager.isTransactional()
                    &amp;&amp; transactionManager.hasProducerId(batch.producerId())) {
                log.error(&quot;The broker returned {} for topic-partition &quot; +
                            &quot;{} at offset {}. This indicates data loss on the broker, and should be investigated.&quot;,
                        exception, batch.topicPartition, baseOffset);

                // Reset the transaction state since we have hit an irrecoverable exception and cannot make any guarantees
                // about the previously committed message. Note that this will discard the producer id and sequence
                // numbers for all existing partitions.
                transactionManager.resetProducerId();
            } else if (exception instanceof ClusterAuthorizationException
                    || exception instanceof TransactionalIdAuthorizationException
                    || exception instanceof ProducerFencedException
                    || exception instanceof UnsupportedVersionException) {
                transactionManager.transitionToFatalError(exception);
            } else if (transactionManager.isTransactional()) {
                transactionManager.transitionToAbortableError(exception);
            }
《=
public class Sender implements Runnable {
    private long sendProducerData(long now) {
        ....................
        accumulator.resetNextBatchExpiryTime();
        List&lt;ProducerBatch&gt; expiredInflightBatches = getExpiredInflightBatches(now);
        List&lt;ProducerBatch&gt; expiredBatches = this.accumulator.expiredBatches(now);
        expiredBatches.addAll(expiredInflightBatches);

        // Reset the producer id if an expired batch has previously been sent to the broker. Also update the metrics
        // for expired batches. see the documentation of @TransactionState.resetProducerId to understand why
        // we need to reset the producer id here.
        if (!expiredBatches.isEmpty())
            log.trace(&quot;Expired {} batches in accumulator&quot;, expiredBatches.size());
        for (ProducerBatch expiredBatch : expiredBatches) {
            String errorMessage = &quot;Expiring &quot; + expiredBatch.recordCount + &quot; record(s) for &quot; + expiredBatch.topicPartition
                + &quot;:&quot; + (now - expiredBatch.createdMs) + &quot; ms has passed since batch creation&quot;;
            failBatch(expiredBatch, -1, NO_TIMESTAMP, new TimeoutException(errorMessage), false);
            if (transactionManager != null &amp;&amp; expiredBatch.inRetry()) {
                // This ensures that no new batches are drained until the current in flight batches are fully resolved.
                transactionManager.markSequenceUnresolved(expiredBatch.topicPartition);
            }
        }

        ...................
《=
/**
     * Run a single iteration of sending
     *
     * @param now The current POSIX time in milliseconds
     */
    void run(long now) {
        if (transactionManager != null) {
            try {
                if (transactionManager.shouldResetProducerStateAfterResolvingSequences())
                    // Check if the previous run expired batches which requires a reset of the producer state.
                    transactionManager.resetProducerId();
                if (!transactionManager.isTransactional()) {
                    // this is an idempotent producer, so make sure we have a producer id
                    maybeWaitForProducerId();
                } else if (transactionManager.hasUnresolvedSequences() &amp;&amp; !transactionManager.hasFatalError()) {
                    transactionManager.transitionToFatalError(
                        new KafkaException(&quot;The client hasn't received acknowledgment for &quot; +
                            &quot;some previously sent messages and can no longer retry them. It isn't safe to continue.&quot;));
                } else if (transactionManager.hasInFlightTransactionalRequest() || maybeSendTransactionalRequest(now)) {
                    // as long as there are outstanding transactional requests, we simply wait for them to return
                    client.poll(retryBackoffMs, now);
                    return;
                }

                // do not continue sending if the transaction manager is in a failed state or if there
                // is no producer id (for the idempotent case).
                if (transactionManager.hasFatalError() || !transactionManager.hasProducerId()) {
                    RuntimeException lastError = transactionManager.lastError();
                    if (lastError != null)
                        maybeAbortBatches(lastError);
                    client.poll(retryBackoffMs, now);
                    return;
                } else if (transactionManager.hasAbortableError()) {
                    accumulator.abortUndrainedBatches(transactionManager.lastError());
                }
            } catch (AuthenticationException e) {
                // This is already logged as error, but propagated here to perform any clean ups.
                log.trace(&quot;Authentication exception while processing transactional request: {}&quot;, e);
                transactionManager.authenticationFailed(e);
            }
        }

        long pollTimeout = sendProducerData(now);
        client.poll(pollTimeout, now);
    }
    ...........

猜测事情经过应该是：
Producer send消息，然后sender在批量发送的时候sendProducerData因为broker那边的故障超时了，造成一些batch record处理超时，所以这里Sender会重置ProducerId
if (transactionManager.shouldResetProducerStateAfterResolvingSequences())
                    // Check if the previous run expired batches which requires a reset of the producer state.
                    transactionManager.resetProducerId();

但是继续阅读源码发现不管是failbatch还是resetProducerId都不会改变事务型producer的状态，：
 synchronized void resetProducerId() {
        if (isTransactional())
            throw new IllegalStateException(&quot;Cannot reset producer state for a transactional producer. &quot; +
                    &quot;You must either abort the ongoing transaction or reinitialize the transactional producer instead&quot;);
        setProducerIdAndEpoch(ProducerIdAndEpoch.NONE);
        this.nextSequence.clear();
        this.lastAckedSequence.clear();
        this.inflightBatchesBySequence.clear();
        this.partitionsWithUnresolvedSequences.clear();
        this.lastAckedOffset.clear();
    }

然后注意到failbatch里的
else if (transactionManager.isTransactional()) {
                transactionManager.transitionToAbortableError(exception);
            }

</code></pre></div><p>所以再次猜测事情经过应该是 failbatch这里将状态变成AbortableError，然后触发了前面的 maybeFailWithError 抛出
throw new KafkaException(&quot;Cannot execute transactional method because we are in an error state&quot;, lastError);
然后调用者抛出 commitTransaction 抛出 ProducerFencedException，
也不对，因为caused抛出的信息内容是(注意我这里分析的是stacktrace的第二段caused部分)：
Producer attempted an operation with an old epoch. Either there is a newer producer with the same transactionalId, or the producer's transaction has been expired by the broker.
并非
Cannot execute transactional method because we are in an error state</p> <p>所以查到这个错误信息的error是对应代码的：
https://github.com/apache/kafka/blob/2.2/clients/src/main/java/org/apache/kafka/common/protocol/Errors.java</p> <p>INVALID_PRODUCER_EPOCH(47, &quot;Producer attempted an operation with an old epoch. Either there is a newer producer &quot; +
&quot;with the same transactionalId, or the producer's transaction has been expired by the broker.&quot;,
ProducerFencedException::new),
搜索reference可以发现，都是kafka client这边处理服务器端的response部分的代码：
kafka-clients-2.2.0.jar - C:\Users\yue.liu.m2\repository\org\apache\kafka\kafka-clients\2.2.0
org.apache.kafka.clients.producer.internals
AddOffsetsToTxnHandler
handleResponse(AbstractResponse)
AddPartitionsToTxnHandler
handleResponse(AbstractResponse)
EndTxnHandler
handleResponse(AbstractResponse)
TxnOffsetCommitHandler
handleResponse(AbstractResponse)</p> <p>所以答案实际上是在server端 <a href="#coordinator-side-transaction-expiration">Coordinator-side Transaction Expiration</a></p> <h5 id="事情过程"><a href="#事情过程" class="header-anchor">#</a> 事情过程</h5> <div class="language- extra-class"><pre class="language-text"><code>at com.lyhistory.core.producer.DisruptorProducer.realProduce(DisruptorProducer.java:66)
            try {
                rawProducer.commitTransaction();
                logger.debug(&quot;处理进度：P={}, BS={}, QO={}&quot;, id, transactionSize, queueOffset);
            } catch (Exception ex) {
                rawProducer.abortTransaction();
                throw new RuntimeException(&quot;处理信息时出现故障&quot;, ex);
            } finally {
                inTransactions = false;
            }
=&gt;
 public void commitTransaction() throws ProducerFencedException {
        throwIfNoTransactionManager();
        TransactionalRequestResult result = transactionManager.beginCommit();
        sender.wakeup(); 唤醒sender
        result.await(); 等待
    }
=&gt;
    public synchronized TransactionalRequestResult beginCommit() {
        ensureTransactional();
        maybeFailWithError();
        transitionTo(State.COMMITTING_TRANSACTION);
        return beginCompletingTransaction(TransactionResult.COMMIT);
    }
=&gt;    
    private TransactionalRequestResult beginCompletingTransaction(TransactionResult transactionResult) {
        if (!newPartitionsInTransaction.isEmpty())
            enqueueRequest(addPartitionsToTransactionHandler());
        EndTxnRequest.Builder builder = new EndTxnRequest.Builder(transactionalId, producerIdAndEpoch.producerId,
                producerIdAndEpoch.epoch, transactionResult);
        EndTxnHandler handler = new EndTxnHandler(builder);
        enqueueRequest(handler);
        return handler.result;
    }
服务端返回response
private class EndTxnHandler extends TxnRequestHandler {
        
        @Override
        public void handleResponse(AbstractResponse response) {
            EndTxnResponse endTxnResponse = (EndTxnResponse) response;
            Errors error = endTxnResponse.error();

            if (error == Errors.NONE) {
                completeTransaction();
                result.done();
            } else if (error == Errors.COORDINATOR_NOT_AVAILABLE || error == Errors.NOT_COORDINATOR) {
                lookupCoordinator(FindCoordinatorRequest.CoordinatorType.TRANSACTION, transactionalId);
                reenqueue();
            } else if (error == Errors.COORDINATOR_LOAD_IN_PROGRESS || error == Errors.CONCURRENT_TRANSACTIONS) {
                reenqueue();
            } else if (error == Errors.INVALID_PRODUCER_EPOCH) {
                fatalError(error.exception());
            } else if (error == Errors.TRANSACTIONAL_ID_AUTHORIZATION_FAILED) {
                fatalError(error.exception());
            } else if (error == Errors.INVALID_TXN_STATE) {
                fatalError(error.exception());
            } else {
                fatalError(new KafkaException(&quot;Unhandled error in EndTxnResponse: &quot; + error.message()));
            }
        }
    }
因为client在server端恢复期间通信超过transaction timeout的默认1分钟时间，所以kafka brokers bump epoch，使得当前的producer过期，返回response INVALID_PRODUCER_EPOCH，然后commitTransaction抛出ProducerFencedException被 try catch抓住后执行了 abortTransaction，然后就是前面stacktrace的过程了has error抛出org.apache.kafka.common.KafkaException: Cannot execute transactional method because we are in an error state
</code></pre></div><h4 id="the-client-hasn-t-received-acknowledgment-for-some-previously-sent-messages-and-can-no-longer-retry-them-it-isn-t-safe-to-continue"><a href="#the-client-hasn-t-received-acknowledgment-for-some-previously-sent-messages-and-can-no-longer-retry-them-it-isn-t-safe-to-continue" class="header-anchor">#</a> The client hasn't received acknowledgment for some previously sent messages and can no longer retry them. It isn't safe to continue.</h4> <p>有了上面的基础，这部分时间很简单</p> <p>2023-02-08 16:03:38.938 [32m INFO[m [35m21664GG[m [EENGINE-TID-2-1] [36mc.l.d.IgnoreExceptionHandler[m : Exception processing: 120 ProduceActionWrapper{}</p> <p>org.apache.kafka.common.KafkaException: Cannot execute transactional method because we are in an error state
at org.apache.kafka.clients.producer.internals.TransactionManager.maybeFailWithError(TransactionManager.java:785)
at org.apache.kafka.clients.producer.internals.TransactionManager.beginAbort(TransactionManager.java:230)
at org.apache.kafka.clients.producer.KafkaProducer.abortTransaction(KafkaProducer.java:716)
at com.lyhistory.core.producer.DisruptorProducer.realProduce(DisruptorProducer.java:66)
at com.lyhistory.core.producer.DisruptorProducer$$Lambda$914/1553377810.onEvent(Unknown Source)
at com.lmax.disruptor.BatchEventProcessor.processEvents(BatchEventProcessor.java:168)
at com.lmax.disruptor.BatchEventProcessor.run(BatchEventProcessor.java:125)
at java.lang.Thread.run(Thread.java:745)
Caused by: org.apache.kafka.common.KafkaException: The client hasn't received acknowledgment for some previously sent messages and can no longer retry them. It isn't safe to continue.
at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:283)
at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:235)
... 1 more</p> <div class="language- extra-class"><pre class="language-text"><code>前面这段跟上面的ProducerFencedException的stackstrace完全一样：
org.apache.kafka.common.KafkaException: Cannot execute transactional method because we are in an error state
	at org.apache.kafka.clients.producer.internals.TransactionManager.maybeFailWithError(TransactionManager.java:785)
	at org.apache.kafka.clients.producer.internals.TransactionManager.beginAbort(TransactionManager.java:230)
	at org.apache.kafka.clients.producer.KafkaProducer.abortTransaction(KafkaProducer.java:716)
	at com.lyhistory.core.producer.DisruptorProducer.realProduce(DisruptorProducer.java:66)
	at com.lyhistory.core.producer.DisruptorProducer$$Lambda$914/1553377810.onEvent(Unknown Source)
	at com.lmax.disruptor.BatchEventProcessor.processEvents(BatchEventProcessor.java:168)
	at com.lmax.disruptor.BatchEventProcessor.run(BatchEventProcessor.java:125)
	at java.lang.Thread.run(Thread.java:745)
不过下面一段多了更深入的stacktrace：

然后是 currentState == State.FATAL_ERROR的原因：
at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:283)
at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:235)

package org.apache.kafka.clients.producer.internals;
public class Sender implements Runnable {
 void run(long now) {
        if (transactionManager != null) {
            try {
                if (transactionManager.shouldResetProducerStateAfterResolvingSequences())
                    // Check if the previous run expired batches which requires a reset of the producer state.
                    transactionManager.resetProducerId();
                if (!transactionManager.isTransactional()) {
                    // this is an idempotent producer, so make sure we have a producer id
                    maybeWaitForProducerId();
                } else if (transactionManager.hasUnresolvedSequences() &amp;&amp; !transactionManager.hasFatalError()) {
                    transactionManager.transitionToFatalError(
                        new KafkaException(&quot;The client hasn't received acknowledgment for &quot; +
                            &quot;some previously sent messages and can no longer retry them. It isn't safe to continue.&quot;));
transactionManager.hasUnresolvedSequences() &amp;&amp; !transactionManager.hasFatalError()
=&gt;
package org.apache.kafka.clients.producer.internals;
public class TransactionManager {
    synchronized boolean hasUnresolvedSequences() {
        return !partitionsWithUnresolvedSequences.isEmpty();
    }

    synchronized boolean hasUnresolvedSequence(TopicPartition topicPartition) {
        return partitionsWithUnresolvedSequences.contains(topicPartition);
    }

    synchronized void markSequenceUnresolved(TopicPartition topicPartition) {
        log.debug(&quot;Marking partition {} unresolved&quot;, topicPartition);
        partitionsWithUnresolvedSequences.add(topicPartition);
    }

这里没什么好说的，很直接

</code></pre></div><h4 id="尝试解决"><a href="#尝试解决" class="header-anchor">#</a> 尝试解决：</h4> <p>当前配置</p> <div class="language- extra-class"><pre class="language-text"><code>delivery.timeout.ms = 120000
transaction.timeout.ms = 60000

request.timeout.ms = 30000
retries = 2147483647
retry.backoff.ms = 150
linger.ms = 5
</code></pre></div><p>延长：
transaction.timeout.ms
在服务端故障恢复的几分钟内，让客户端有足够的时间重试而不是直接被服务端expire</p> <p>注意数值不能超过服务端broker的配置（默认15分钟）：
transaction.max.timeout.ms
The maximum allowed timeout for transactions. If a client’s requested transaction time exceed this, then the broker will return an error in InitProducerIdRequest. This prevents a client from too large of a timeout, which can stall consumers reading from topics included in the transaction.</p> <div class="language- extra-class"><pre><code>Type:	int
Default:	900000 (15 minutes)
Valid Values:	[1,...]
Importance:	high
Update Mode:	read-only
</code></pre></div><p><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-691%3A+Enhance+Transactional+Producer+Exception+Handling" target="_blank" rel="noopener noreferrer">未来的改进：KIP-691: Enhance Transactional Producer Exception Handling<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <hr> <p>REFER:
https://www.cnblogs.com/luozhiyun/p/12079527.html
https://docs.spring.io/spring-kafka/reference/#transactional-id
https://www.confluent.io/blog/transactions-apache-kafka/</p> <div id="disqus_thread"></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/docs/assets/js/app.64832df0.js" defer></script><script src="/docs/assets/js/2.19baf9f4.js" defer></script><script src="/docs/assets/js/122.f623e692.js" defer></script><script src="/docs/assets/js/11.0d0890d4.js" defer></script>
  </body>
</html>
