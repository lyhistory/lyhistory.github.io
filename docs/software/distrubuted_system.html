<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>1.关于一致性 | 计算机基础教程</title>
    <meta name="description" content="软件开发教程，渗透测试入门教程，区块链入门教程，物联网，大数据">
    
    
    <link rel="preload" href="/docs/assets/css/0.styles.8afa94d5.css" as="style"><link rel="preload" href="/docs/assets/js/app.8f0e281e.js" as="script"><link rel="preload" href="/docs/assets/js/2.5d2fca3b.js" as="script"><link rel="preload" href="/docs/assets/js/12.035c9802.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.08a340be.js"><link rel="prefetch" href="/docs/assets/js/11.85ed278c.js"><link rel="prefetch" href="/docs/assets/js/13.38339d2a.js"><link rel="prefetch" href="/docs/assets/js/3.8706db6f.js"><link rel="prefetch" href="/docs/assets/js/4.6b1b1ab7.js"><link rel="prefetch" href="/docs/assets/js/5.1b8a14a3.js"><link rel="prefetch" href="/docs/assets/js/6.2e0e4b3e.js"><link rel="prefetch" href="/docs/assets/js/7.4a8eb506.js"><link rel="prefetch" href="/docs/assets/js/8.6e6b7191.js"><link rel="prefetch" href="/docs/assets/js/9.84adc8e5.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.8afa94d5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><!----> <span class="site-name">计算机基础教程</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/docs/" class="nav-link">机器指令</a></div><div class="nav-item"><a href="/docs/software/" class="nav-link router-link-active">软件基础</a></div><div class="nav-item"><a href="/docs/coder2hacker/" class="nav-link">渗透测试</a></div><div class="nav-item"><a href="/docs/blockchain/" class="nav-link">区块链</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/docs/" class="nav-link">机器指令</a></div><div class="nav-item"><a href="/docs/software/" class="nav-link router-link-active">软件基础</a></div><div class="nav-item"><a href="/docs/coder2hacker/" class="nav-link">渗透测试</a></div><div class="nav-item"><a href="/docs/blockchain/" class="nav-link">区块链</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>1.关于一致性</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/software/distrubuted_system.html#_1-关于一致性" class="sidebar-link">1.关于一致性</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/docs/software/distrubuted_system.html#_2-从中心化到去中心化" class="sidebar-link">2.从中心化到去中心化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/software/distrubuted_system.html#_1-1-分布式产品和zookeeper" class="sidebar-link">1.1.分布式产品和zookeeper</a></li><li class="sidebar-sub-header"><a href="/docs/software/distrubuted_system.html#_1-2-build-distributed-system-from-scratch" class="sidebar-link">1.2.Build distributed system from scratch</a></li></ul></li><li><a href="/docs/software/distrubuted_system.html#_3-from-distributed-system-to-distributed-ledger" class="sidebar-link">3.From distributed system to distributed ledger</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="_1-关于一致性"><a href="#_1-关于一致性" class="header-anchor">#</a> 1.关于一致性</h2> <p>基本可以分为两大类：</p> <blockquote><p>最终一致性 eventual consistent，代表协议如gossip/multicast protocols，redis集群就是采用gossip</p></blockquote> <blockquote><p>共识算法一致性 consensus protocols，代表协议有 PBFT, RAFT, 经典的比特币共识算法nakamoto consensus等</p></blockquote> <p>The former includes things like epidemic broadcast trees, bimodal multicast, SWIM, HyParView, and NeEM. These tend to be eventually consistent and/or stochastic.
The latter, which I’ve described in more detail here, includes 2PC/3PC, Paxos, Raft, Zab, and chain replication. These tend to favor strong consistency over availability.
https://bravenewgeek.com/tag/leader-election/</p> <h2 id="_2-从中心化到去中心化"><a href="#_2-从中心化到去中心化" class="header-anchor">#</a> 2.从中心化到去中心化</h2> <p>中心化系统有单点故障的风险，所以引入多个节点，但是多个节点之间如何保持数据同步，基于一致性算法有两种思路：</p> <blockquote><p>1.最直接的办法是动态选出一个leader，只由leader单节点负责管理竞争资源，然后其他节点作为follower保存副本，当leader发生故障，重新从follower中选举新的leader，从而既避免了单点故障又保持了数据一致</p></blockquote> <blockquote><p>2.节点之间通过共识算法保持数据同步，这是个经典的拜占庭将军问题，经典的共识算法是BFT拜占庭共识算法</p></blockquote> <h3 id="_1-1-分布式产品和zookeeper"><a href="#_1-1-分布式产品和zookeeper" class="header-anchor">#</a> 1.1.分布式产品和zookeeper</h3> <blockquote><p>分布式产品</p></blockquote> <blockquote><p>分布式服务框架 zookeeper的ZAP协议</p></blockquote> <blockquote><p>分布式消息队列集群Kafka</p></blockquote> <blockquote><p>分布式实时计算storm以及Hadoop mapreduce2.0</p></blockquote> <blockquote><p>分布式存储系统：hbase基于zookeeper, 而ETCD采用RAFT协议 https://raft.github.io/</p></blockquote> <blockquote><p>分布式任务调度</p></blockquote> <p>可以看几个产品的架构图
<img src="/docs/docs_image/software/distrubuted_system1.png" alt="Kafka"> <img src="/docs/docs_image/software/distrubuted_system2.png" alt="HDFS"> <img src="/docs/docs_image/software/distrubuted_system3.png" alt="HADOOP"></p> <p>Since Hadoop 2.0, ZooKeeper has become an essential service for Hadoop clusters, providing a mechanism for enabling high-availability of former single points of failure, specifically the HDFS NameNode and YARN ResourceManager.
https://www.datadoghq.com/blog/hadoop-architecture-overview/</p> <p>观察可以发现一个问题，为啥大部分都需要依赖分布式框架zookeeper？？</p> <p>简单来说，不要重复造轮子，zookeeper可以用于集群管理，只不过有些可以脱离zookeeper单机部署，有些则是只支持集群模式，跟zookeeper耦合紧密，当然我们谈的是分布式系统，所以这里不讨论单机版本</p> <p>举一个例子：</p> <p><img src="/docs/docs_image/software/distrubuted_system4.png" alt="分布式管理例子">
中央就是zookeeper，本身是集群，政治协商，一个挂掉还会迅速选一个，中央的主要工作是做集群管理，具体的生产生活还要交由Apache/Storm这些地方政府节点来做，
地方节点之间也是一个集群，比如分布式商务系统集群（商务部是集群的leader，向中央注册），分布式农业系统集群等</p> <p>Zookeeper适用的场景：
https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/index.html</p> <blockquote><p>统一命名服务（Name Service）</p></blockquote> <blockquote><p>配置管理（Configuration Management）</p></blockquote> <blockquote><p>集群管理（Group Membership）</p></blockquote> <blockquote><p>共享锁（Locks）：共享锁在同一个进程中很容易实现，但是在跨进程或者在不同 Server 之间就不好实现了</p></blockquote> <h3 id="_1-2-build-distributed-system-from-scratch"><a href="#_1-2-build-distributed-system-from-scratch" class="header-anchor">#</a> 1.2.Build distributed system from scratch</h3> <p>假设我们需要创建一个分布式任务调度，当然是从零开始，不采用市面上的分布式任务调度产品，假设这些任务存在数据库</p> <p>首先我们肯定需要一些干活的workers，负责执行具体任务，想象一下我们创建了一个java程序执行具体的任务逻辑；</p> <p>由于正常情况下一般除非是定制了class loader否则一个java程序是跑在一个单独的jvm实例当中，
所以分布式部署的情况下，每个worker都在一个独立的jvm实例中，部署在多台机器上，多个互相独立的jvm实例之间需要协商分配这些任务，
同时去读写数据库的任务列表很容易造成冲突，显然如果我们不采用共识算法，处理起来会毫无头绪，
最直接简单的想法就是从中找一个特别的worker作为leader来做这个分配，这里就引入了zookeeper，
你可能会说不引入zookeeper，自己写一个单独的leader程序不行吗，确实可以，不过leader程序也要做成集群式的，不可以引入单点故障，
所以为了简单，直接让这些workers都注册zookeeper，不同的java程序微服务之间通过zookeeper的observer监听模式实现同步节点信息，
这样每个worker都可以保存一份同步的worker list，怎么从worker list中选出一个leader呢，两个思路：</p> <blockquote><p>可以简单设计一些规则来实现选举，比如通过配置文件定义好是否是leader候选人，然后选的时候就通过排序找到第一个活着的候选人即可；</p></blockquote> <blockquote><p>通过curator高级API利用zookeeper的共享锁机制自动做的leader选举，take leadership的方式，默认都是普通worker，在take leadership的时候激活为leader，
不过这种方式有个缺点，其他普通的worker无法得知选举结果，所以在某些场景下，当worker需要向leader汇报情况的时候就做不了了，除非没有这种需求；</p></blockquote> <p>现在还没有结束，现在有了动态选举的leader和一群worker，leader要怎么分发任务给worker，他们是互不想干的独立进程，可能部署在不同的机器上，通过zookeeper吗？
zookeeper只支持最简单的推拉消息，每次节点注册时，只会通知各节点有nodechange事件，各节点自行去zookeeper pull拉取具体变化信息，
所以我们无法通过zookeeper实现worker及leader节点之间的要求，这里就引入了rpc通信协议，相比较基于HTTP的web service，基于TCP的rpc性能更优，然后结合proxy代理模式对调用方法接口进行封装，
可以让微服务在调用远程方法的时候就像调用自身方法一样透明。
然后因为所有worker及leader节点都保存了一份节点列表，所以leader分发任务的时候就可以采取一定的策略，比如round robin或load balance方式rpc调用worker分发任务；
至于worker节点，虽然也保存了一份节点列表但一般只需要跟leader通信，当然如果leader挂掉，worker变成leader还是要用这个列表的；</p> <p><img src="/docs/docs_image/software/distrubuted_system5.png" alt="分布式任务调度"></p> <p>还需要思考的问题：</p> <blockquote><p>如何保证leader选举的唯一性，即保证不选出多个leader</p></blockquote> <blockquote><p>如何在leader宕机的瞬间保持数据不丢失，新leader如何恢复旧leader宕机之前的状态</p></blockquote> <h2 id="_3-from-distributed-system-to-distributed-ledger"><a href="#_3-from-distributed-system-to-distributed-ledger" class="header-anchor">#</a> 3.From distributed system to distributed ledger</h2> <p><img src="/docs/docs_image/software/distrubuted_system6.png" alt="网络类型"></p> <p>我们前面谈到的分布式系统都不是不是真正的分布式，只能算是多中心的系统，zookeeper也不是真正的分布式框架，因为其本身集群也是有leader和follower的，
所以基于zookeeper的分布式系统更会不是真的分布式，只有是基于共识算法实现的系统才有可能是真正的分布式系统；</p> <p>谈到去中心化，分布式，最广为人知的就是区块链，区块链技术，又被称作DLT，Distributed Ledger Technology，区块链大致分为permissioned 和 non-permissioned blockchain，前者基本都是私有链和联盟链，后者是公链，
目前来看，只有公链才算是真正意义的分布式系统，因为所有节点基本上都是公平的，可以随时加入退出，不影响公链的运行，大家遵循同一个规则来运行节点，维护网络，
运行节点的目的以及维护网络的方式具体就是挖矿（打包区块），发布交易，验证交易等；</p> <p>关于共识算法，参考我在巴比特上面的文章：
<a href="https://www.8btc.com/media/393154" target="_blank" rel="noopener noreferrer">区块链基础：解密挖矿与共识的误解<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/docs/assets/js/app.8f0e281e.js" defer></script><script src="/docs/assets/js/2.5d2fca3b.js" defer></script><script src="/docs/assets/js/12.035c9802.js" defer></script>
  </body>
</html>
